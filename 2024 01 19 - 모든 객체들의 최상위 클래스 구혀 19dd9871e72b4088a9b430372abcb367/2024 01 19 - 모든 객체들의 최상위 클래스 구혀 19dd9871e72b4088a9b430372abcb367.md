# 2024/01/19 - 모든 객체들의 최상위 클래스 구현, 현재 게임 클라이언트에 대한 관리자 구현

태그: C++, CS, WinAPI, 중급
날짜: 2024/01/19
상위 항목: Week8 (Week8%2097066e5626ef4fb4ac1b17db8d09a64b.md)
주차: 0001_Week1~9

### 모든 객체의 최상위 부모 클래스, CEntity

게임에서 사용할 객체들을 설계하는 데에 사용할 최상위 부모 클래스를 제작해보자

→  `CEntity` 

- 상속시킬 목적으로 제작하는 클래스
- 모든 게임 객체들이 공통적으로 갖고 있을 멤버나 기능을 구현

```cpp
class CEntity
{
private:
	static UINT g_NextID;

	const UINT m_ID;       // 객체별 고유 ID
	wstring m_strName;     // 객체가 string 타입으로 가지는 이름(중복 가능)

public:
	UINT GetID() { return m_ID; }

	void SetName(const wstirng& _Name) { m_strName = _Name; }
	const wstring& GetName() { return m_strName; }

public:
	CEntity();
	virtual ~CEntity();
};
```

```cpp
#include "pch.h"
#include "CEntity.h"

// 구현
UINT CEntity::g_NextID = 0;

CEntity::CEntity()
	: m_ID(g_NextID++)
{
}

CEntity::~CEntity()
{	
}
```

- `static UINT g_NextID;`
    
    : 객체별 고유 ID값을 나타내는 `m_ID` 멤버는,  
    
    1) private으로 선언되어 있으면서 
    
    2) 객체가 생성되면서 정의되어야 하는 const 변수이다
    
    → 즉, 외부에서 값을 설정할 수 없으며, 반드시 생성자에서 초기화되어야 한다
    
    - 그렇기에 전역변수인 `g_NextID`를 활용해, 생성자에서 `m_ID`를 초기화해주고 있다
    - 이때 `g_NextID`를 ***static***으로 선언해주면, 초기화 과정이 한번만 이루어지기 때문에 값이 초기값으로 중복 초기화 될 상황이 없으면서도, private 영역에 선언함으로써 외부에서 값을 변경할 수 없게 된다
        
        → 클래스 내에서 static으로 선언함에 따라 g_NextID는 ***정적 멤버 변수***가 되었고, 클래스 내에서 객체와는 독립적으로 존재하는 변수가 되었다
        
        > 💭 만약 g_NextID를 단순히 전역변수로 정의했다면, 중복 초기화의 위험성과 외부에서 접근함으로써 값을 변경할 위험성이 둘 다 있었을 것이다
        > 
    - static 변수는 구현파일에서 반드시 한번 초기화가 이루어져야 하므로, cpp 파일에서 초기화 해준다 → `UINT CEntity::g_NextID = 0;`
    
    ---
    
    이로써 우리는 정적 변수의 선언위치에 따른 case를 모두 수업의 예제를 통해 접하게 된 것인데, 1) 함수 내  2) 파일 내  3) 클래스 내  의 경우 중, 지금은 클래스 내의 경우를 보게 되었다!
    
    <aside>
    📒 참고/복습 자료 → [8.10 정적(static) 멤버 변수](https://www.notion.so/8-10-static-a1eb717fdbbb4bcdac0b5423aa82de92?pvs=21)
    
    </aside>
    

- `virtual ~CEntity();`
    
    : 상위 클래스의 소멸자는 가상함수로 선언해야 한다. 다형성과 메모리 누수를 방지하기 위해서 → 자식 클래스의 소멸자가 먼저 호출될 수 있도록
    

### CEntity 클래스의 추상 클래스화와 디자인 패턴

```cpp
class CEntity
{
	// ...

public:
	virtual CEntity* Clone() = 0;
};
```

1. **CEntity 클래스의 추상 클래스화**
    
    아까 우리가 CEntity를 정의하려고 했던 목적을 보면, 
    
    > - *상속시킬 목적으로 제작하는 클래스
    - 모든 게임 객체들이 공통적으로 갖고 있을 멤버나 기능을 구현*
    > 
    
    CEntity의 존재 의의 자체는 다른 클래스들을 설계하기 위한 밑바탕, 즉 설계도라고 할 수 있다
    
    → 그렇다면 CEntity는 객체를 생성해서 그 객체를 사용하려는 목적이 아니라, 이 클래스를 상속한 자식 클래스들이 생성한 객체를 사용하려는 목적으로 존재하는 상위 클래스인 것이다!
    
    그렇다면 우리는 굳이 *CEntity의 객체를 생성할 필요가 없으며*, 이는 추상 클래스의 조건에 들어맞는다!
    
    그럼 추상 클래스의 조건은 클래스에 ***순수 가상 함수가 1개 이상 구현***되어 있다는 것인데..  이 점을 기억하고 나머지 기능들을 구현해나가보자
    

1. **프로토타입 패턴 적용**
    
    `CEntity` 클래스에 ⭐`Clone`⭐이라는 기능을 추가하려고 한다
    
    Clone은 자기 자신을 복제해 반환하는 작업을 하는 기능이다. 이를 활용해 새로운 객체를 생성할 때 복제된 객체를 활용해 간단한 세팅과 같은 작업을 간편하게 하는 것!
    
    이런 작업은 ***프로토타입 패턴***에 해당하는 디자인 패턴이다
    
    <aside>
    ✍️ **디자인 패턴(설계 유형)**
    
    : 주로 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제에 대한 일반적인 해결책을 제공하는 재사용 가능한 설계 템플릿이라고 보면 된다!
    
    </aside>
    
    <aside>
    ✍️ **프로토타입 패턴**
    
    : 객체를 생성할 때 기존 객체를 복제하여(clone) 새로운 객체를 생성하는 디자인 패턴이다. 보통 원본(Prototype)을 만들어 놓고 원본 객체를 복사하여 사용하는 방식으로 사용한다. 객체 생성 과정이 복잡하거나 비용이 많이 들 때 유용하게 사용된다. 또 기존 객체의 상태를 유지한 채로 새로운 객체를 생성할 수 있어, 객체 생성 시간 및 리소스를 절약할 수 있다
    정리하자면, 주요 이점은 1) 복잡한 객체 생성, 2) 성능 향상, 3) 상태 유지라고 할 수 있다.
    
    프로토타입 패턴을 구현할 때는 객체 복제를 위한 인터페이스나 메소드를 정의하고, 이를 구체적인 클래스에서 구현한다!
    
    </aside>
    
    현재 코드에서는, `CEntity`라는 객체에 대한 최상위 클래스에서 `clone`이라는 순수 가상함수를 작성해 CEntity를 상속하는 클래스에 대해 ***해당 기능을 반드시 재정의***하도록 작성되었다! 모든 객체마다 객체를 재생산할 기능이 필요하므로!
    
    그리고 여기서 순수 가상함수가 선언됨에 따라서, **CEntity는 추상 클래스가 되어버렸다**.
    
    즉, CEntity만의 객체를 만들 수 없게 되었다!
    

### 현재 게임 클라이언트에 대한 관리자, CEngine

게임 클라이언트에 대한 최상위 관리자를 만들어보도록 하자

그렇다면 관리자에 대한 클래스를 정의하면서, 해당 클래스의 객체는 **단 하나만 생성**되어야 할 것이다!

이렇게 한 클래스에 대해 객체가 하나만 생성되도록 작성하는 것은, 디자인 패턴 중에 **싱글톤 패턴**에 해당된다

<aside>
✍️ **싱글톤 패턴**

: 특정 클래스의 인스턴스가 오직 하나만 생성되도록 보장하면서, 해당 인스턴스에 대한 전역적인 접근을 제공하는 디자인 패턴이다

주요적인 특징은
⭐ 1) **단일 인스턴스**가 존재한다는 것
⭐ 2) 어디서든 인스턴스에 접근할 수 있는 **전역적인 접근점**이 제공된다는 것
3) 인스턴스가 필요한 시점에서 생성되도록 지연 로딩이 가능하다는 것
4) 다중 스레드 환경에서도 동시에 인스턴스를 생성하지 않도록 단일성을 보장한다는 것

보통 다음과 같은 상황에서 주로 사용된다!
- 여러 컴포넌트나 객체가 특정 리소스를 공유해야 할 때
- 시스템 전역에서 사용하는 설정 정보를 단일 인스턴스로 관리할 때
- 로깅이나 트래킹과 같이 시스템 전역세서 사용하는 객체를 유지해야 할 때

</aside>

일단은, 싱글톤 패턴으로 `CEngine`이라는 게임 클라이언트에 대한 관리자를 정의하면서 ⭐ 표시의 기능에 집중해보도록 하자

**싱글톤 패턴 작성 예시 1) - 동적할당을 통한 구현**

```cpp
class CEngine
{
private:
	static CEngine* pEngine;

public:
	// 객체를 1개 만들어서 반환해주는 함수를 구현
	static CEngine* GetEngine()       // 정적 멤버함수
	{
		if(pEngine == nullptr) { pEngine = new CEngine; }
		
		return pEngine;
	}

	static void Destroy()
	{
		if (nullptr != pEngine)
			delete pEngine;
	}
private:
	CEngine();
	CEngine(const CEngine& _other) = delete;

public:
	~CEngine();
};
```

- `static CEngine* pEngine;`
    
    단 하나뿐인 CEngine 객체를 가리키는 포인터 변수인 `pEngine`을 선언했다!
    
    static으로 선언했기 때문에 CEngine 객체의 생성 유무와 상관 없이 접근이 가능하다
    

- `static CEngine* GetEngine() { … }`
    
    객체를 1개 만들어서 해당 객체에 대한 포인터를 반환해주는 함수로, 
    
    - 만약 pEngine이 가리키고 있는 객체가 없다면
        
        → 동적할당을 통해 새로운 Engine 객체를 생성해 pEngine에 저장하고
        
    - pEngine을 반환함으로써 해당 함수를 통해 Engine 객체에 접근할 수 있도록 해준다
    
    `GetEngine()`을 정적 멤버 함수로 정의한 이유는,
    
    - 정적 멤버함수는 this 키워드를 사용하지 않는다.
        
        → 즉, ⭐객체가 없어도 호출이 가능⭐
        
    - ⭐멤버 함수의 특징(해당 클래스의 private 영역에 접근이 가능한 것)을 가진다⭐
    - 단! 정적 멤버함수를 통해서는 해당 클래스의 멤버에 접근이 불가능해진다
        
        (static 정적 멤버 변수는 접근 가능)
        
    
    <aside>
    📒 참고/복습 자료 → [8.11 정적 멤버 함수](https://www.notion.so/8-11-e1183b9a9a8e4f42b8310faacae7f52c?pvs=21)
    
    </aside>
    
     
    
- `static void Destroy()`
    
    동적할당 받은 CEngine 객체를 delete 해주기 위한 작업을 수행하는 함수를 따로 구현해줬다. 이 역시 실질적인 객체 없이도 호출이 가능해야 하기 때문에 static 선언되었다.
    

- `CEngine(const CEngine& _other) = delete;`
    
    복사 생성자를 명시적으로 삭제(delete)하겠다는 의미로, 싱클톤 패턴에서 객체의 복사생성을 금지하기 위한 작업이다!
    
    객체의 복사 생성을 허용한다면, 두 개 이상의 객체가 생성될 수 있기 때문에 막아줘야 한다
    
    ```cpp
    CEngine engine = *pEngine;
    
    // 이런식으로 작성한다면? 복사생성자가 실행되면서 접근이 가능해진다
    ```
    

**싱글톤 패턴 작성 예시 2) - 정적 변수의 선언을 통한 구현**

```cpp
class CEngine
{
private:

public:
	static CEngine* GetEngine()
	{
		static CEngine engine;         // 데이터 영역에 존재하는 CEngine 객체 engine
		return &engine;
	}

private:
};
```

- `static CEngine* GetEngine() { … }`
    
    : 방법 1과 동일하게 GetEngine 정적 함수를 구현해 해당 함수로 객체에 접근할 수 있도록 구현되었다
    
    그런데 내부에서 `static CEngine engine;`을 통해 CEngine 객체를 만들어줬다!
    
    - static으로 선언했기 때문에 데이터 영역에 CEngine 객체를 만들어줬다
    - 초기화 작업은 단 한번만 시행되기 때문에 GetEngine이 첫 호출 시에만 CEngine 객체가 생성되고, 그 후론 계속 호출되어도 engine에 대한 주소값만 반환한다

훨씬 간단하게 싱글톤을 구현할 수 있다는 장점이 있지만,

**프로그램이 실행되는 동안 계속해서 데이터 영역에서 메모리를 차지하고 있는다는 부담**이 있다!