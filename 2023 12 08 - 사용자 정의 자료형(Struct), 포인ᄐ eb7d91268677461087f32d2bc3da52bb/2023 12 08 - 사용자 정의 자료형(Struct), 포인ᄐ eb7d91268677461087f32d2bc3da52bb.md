# 2023/12/08 - 사용자 정의 자료형(Struct), 포인터

태그: C++, CS, 입문
날짜: 2023/12/08
상위 항목: Week2 (Week2%204d4cda48e32a448b92e6b91b7bd876af.md)
주차: 0001_Week1~9

### 사용자 정의 자료형 (User Define Datatype), 그리고 구조체(Struct)

사용자 정의 자료형은 기존에 정의되어 있는 데이터 타입 이외에도 우리가 필요에 따라 직접 만들 수 있다. 이를 통해 더 효율적이고 유연한 데이터 구조를 만들 수 있다!

그 중 이번엔 **구조체**에 대해서 알아볼 것이다!

구조체에 대한 내용은 따배씨 정리 참고하기!

<aside>
📒 구조체 생성 및 변수 선언, 초기화 등등 참조 → [4.10 구조체 struct](https://www.notion.so/4-10-struct-ef59d7ef3cbf49ac9735f937d043b05a?pvs=21)

</aside>

수업에서 조금 더 집중적으로 봤던 내용은, 구조체의 **패딩(padding)**에 대한 내용이었다

### 구조체의 패딩(Padding)

구조체의 패딩은 구조체의 멤버들 사이에 **추가적인 바이트**를 삽입하는 것으로, 이는 컴파일러가 프로그램의 속도 향상을 위 최적화 및 메모리 정렬을 위해 발생하는 것!

→ 정확한 명칭은 **바이트 패딩(byte padding)**이다

구조체는 멤버로 다양한 크기의 타입을 가질 수 있는데, 컴파일러는 메모리의 접근을 쉽게 하기 위해서 **크기가 가장 큰 멤버 변수의 타입을 기준**으로 모든 멤버 변수의 메모리 크기를 맞추게 된다 

→ 따라서 모든 구조체가 크기가 가장 큰 멤버변수의 타입 byte의 배수가 나오게 된다

이때 추가되는 바이트를 패딩 바이트(padding byte)라고 한다

따라서 멤버를 선언할 때에는, 자료형의 크기가 작은 순 → 큰 순으로 나열하는 것이 패딩 바이트를 줄일 수 있는 방법이다

똑같은 구조체를 멤버 변수의 선언 순서만 다르게해서 비교해보자!

1. 멤버 변수의 선언 순서를 마구잡이로 한 경우!

```cpp
struct MyStruct1 
{
	int mem1;
	char mem2;
	long long mem3;   // 이 멤버 변수를 기준으로 메모리 크기를 맞춘다! (8 byte)
	short mem4;
};

MyStruct1 myStr1 = {};

cout << sizeof(myStr1) << endl;             // 24 출력!
```

이때 메모리를 그림으로 확인해보자면

![Untitled](2023%2012%2008%20-%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%92%E1%85%A7%E1%86%BC(Struct),%20%E1%84%91%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%20eb7d91268677461087f32d2bc3da52bb/Untitled.png)

→ 총 9byte의 패딩 바이트가 발생한 것을 알 수 있다! 꽤 낭비되는 메모리가 많다

1. 멤버 변수의 선언 순서를 크기 순으로 정렬한 경우

```cpp
struct MyStruct2
{
	char mem2;           
	short mem4;          
	int mem1;            
	long long mem3;      
};

MyStruct2 myStr2 = {};

cout << sizeof(myStr2) << endl;             // 16 출력!
```

이때 메모리를 그림으로 확인해보자면

![Untitled](2023%2012%2008%20-%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%92%E1%85%A7%E1%86%BC(Struct),%20%E1%84%91%E1%85%A9%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%20eb7d91268677461087f32d2bc3da52bb/Untitled%201.png)

→ 1byte의 패딩 바이트만 발생했다! 

변수를 크기 순으로 정렬하는 것만으로도 8byte의 메모리를 절약할 수 있다

다만, 이렇게 직접 크기를 체크해가면서 변수를 직접 나열하는 것은 번거로울 것이다..

따라서 실제 업무에서는 전처리를 통해 구조체의 크기 확장 규칙을 정한다

→ `#pragma pack(1)` 활용

전처리를 위 코드에 적용하면, 선언 순서에 상관없이 우리가 각각 변수의 타입 크기만 계산했을 때의 값인 15가 출력된다!

### 포인터(Pointer)

포인터란 **메모리 주소를 저장하는 변수**로, 다른 변수의 주소를 가리키는 역할을 한다!

*cf. 여기서 주소란, 물리적인 주소가 아닌, OS가 메모리에 개념적으로 부여한 주소다*

(상수는 안된다. 저장되는 메모리 주소가 있는 value가 아니니까)

 포인터를 사용하면 메모리에 직접 접근하여 데이터를 조작하거나 함수에게 변수의 주소를 전달할 수 있다

→ 이로써 메모리를 효율적으로 관리하고, 복잡한 데이터 구조를 다룰 수 있다.

포인터 변수를 선언하고 사용하는 방법에 대해서는 따배씨에서 정리한 자료를 참고하자

<aside>
📒 포인터의 기본적인 사용법 참조
→ [6.7 포인터의 기본적인 사용법, 널 포인터(Null Pointer)](https://www.notion.so/6-7-Null-Pointer-f604e3623ac74bc3a166d6815505b745?pvs=21)

</aside>

오늘 수업에서 집중적으로 다뤘던 내용은

---

1. NULL과 nullptr의 차이
2. 포인터 변수 자체의 크기
3. 포인터 변수는 왜 가리키는 변수 타입의 포인터 타입으로 선언해야 하는가
4. void 포인터의 활용과 한계
5. 구조체 포인터와 멤버의 접근

---

이었다!! 차근차근 알아보자

### 1. NULL과 nullptr의 차이

`nullptr`은 C++11에서 도입된 값으로, 포인터가 어떤 주소도 가리키지 않는다는 것을 명시적으로 표현하기 위해 사용한다!

`NULL`이란 C 언어에서 사용되는 매크로로, 포인터가 널 값을 가리킨다는 것을 나타냈다. 내부적으로 0이라는 값을 갖고 있었기 때문에 포인터에만 국한되어 사용된 것이 아니라, 모호한 상황이 발생할 수 있었다.

C++에서는 `nullptr`이 도입되었기 때문에 해당 키워드를 사용함으로써 **null 값을 갖고 있는, 아무 주소도 가리키지 않는 포인터 변수**임을 더 명확하게 확인할 수 있게 되었다! 

ex) 만약 typedef를 통해서 `int*` 타입을 MYTYPE이라고 정의해놨다면, MYTYPE의 변수가 NULL로 초기화된 것을 보고 이게 일반 변수인지.. 포인터 변수인지.. 한번에 명확하게 정의내리기 어려웠을 것이다!

그러나 만약 MYTYPE의 변수가 nullptr로 초기화 되었다면, 그 자체만으로 MYTYPE이 포인터 변수라는 것을 알 수 있을 것이다! 

→ 그렇기에, 포인터 변수를 선언하고 초기화하지 않는 경우라면 `nullptr`로 초기화를 진행해 이상한 주소가 지정되지 않도록 잘 활용해보자

### 2. 포인터 변수 자체의 크기

포인터 변수의 크기는 시스템에 따라 다를 수 있지만, 

일반적으로 포인터 변수는 주소를 저장하기 위해 메모리 공간을 차지하므로 4byte 혹은 8byte의 크기를 가집니다 

→ 달라지는 이유는, **타겟 플랫폼**이 다르기 때문에!

64bit OS 타겟이라면, 8byte 단위로 연산이 처리되어 주소체계 역시 8byte이고

32bit OS 타겟이라면, 4byte 단위로 연산이 처리되어 주소체계 역시 4byte이다

따라서 어떤 데이터 타입의 주소를 담든, 타겟 플랫폼에 따라서 4byte 혹은 8byte라고 생각

### 3. 포인터 변수는 왜 가리키는 타입의 변수로 선언해야 하는가

포인터 타입을 선언하게 되면, 해당 포인터 변수는 선언한 타입의 변수의 주소만 담을 수 있다

ex) int*은 int만, double* 은 double만, char*은 char만…

그 이유는, 포인터가 담고 있는 것이 해당 변수가 저장되어있는 곳의 주소값이기 때문에,

1. 해당 포인터 변수를 호출했을 때 얼만큼의 포인터 연산을 수행해서 주소를 읽어야 하는지를 파악할 수 없고, 
2. 역참조(간접 참조)를 수행했을 때에도 어떤 방식으로 데이터를 표현해야 하는지 결정할 단서가 없어지기 때문이다! 
    
    +) 데이터라는 건 값이 동일해도 해석 방식에 따라서 값을 다르게 해석했다
    
    → 데이터 타입이 중요한 이유였음!
    

다만 모든 타입의 포인터를 담을 수 있는 Void 포인터가 있었다

### 4. Void 포인터의 활용과 한계

void 포인터는 어떤 타입의 주소든 가리킬 수 있다

즉, 어떤 타입의 변수라도 그 주소값을 할당할 수 있다는 것!

그렇기 때문에 변수에 따로 담는 것이 아니라, 메모리 할당만 이룬 채 그 주소를 알아야 하는 동적할당 같은 경우에 유용하게 사용할 수 있다

→ 즉, 주소를 들고 있지만 그 내부로 접근(간접 참조)할 목적이 없을 때 주로 활용한다

포인터 연산이 불가능하기 때문에, 접근 및 이동도 불가능해 간접 참조가 불가능하다는 큰 리스크가 있기 때문이다! 

→ 타입이 명시되어 있지 않아, 컴파일러는 포인터가 해당 주소에 가서 얼마만큼 주소를 읽어들이고, 어떤 표현 방식으로 해석해야 하는지를 파악하지 못한다

만약,  해당 주소에 저장된 값을 사용하기 위해서는 타입 캐스팅이 필요하다!

### 5. 구조체 포인터와 멤버의 접근

구조체도 사용자 정의 데이터 타입이기 때문에, 해당 데이터 타입으로 포인터 변수를 만들어 줄 수 있다!

```cpp
Person *ptr = &person;           // 구조체 포인터 
```

또, 해당 포인터를 이용해서 멤버에도 접근이 가능하다

```cpp
(*ptr).age = 20;     // .(접근연산자)가 *(참조연산자)보다 우선순위가 높기 때문에, 
                     // 구조체를 간접참조 하기 위해서는 명확하게 괄호로 지정해줘야 한다

ptr->age = 30;       // 포인터로 멤버에 간접참조로 접근할 때에는 ->를 사용
```

매번 구조체 변수에 간접참조를 한다는 `*`(참조연산자)를 붙이고, 괄호를 씌워 접근하기가 귀찮으니, `->` 를 활용한 축약문을 활용하자!