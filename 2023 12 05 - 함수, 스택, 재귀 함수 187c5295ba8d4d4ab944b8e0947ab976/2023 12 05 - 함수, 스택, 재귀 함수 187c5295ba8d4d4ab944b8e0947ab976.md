# 2023/12/05 - 함수, 스택, 재귀 함수

태그: C++, CS, 입문
날짜: 2023/12/05
상위 항목: Week2 (Week2%204d4cda48e32a448b92e6b91b7bd876af.md)
주차: 0001_Week1~9

### before…

지난 시간에 간략하게 정리했던 메모리 영역에 대해서 다시 한번 정리해보자

- 스택(Stack) : 지역 변수, 함수가 저장되는 공간
- 데이터(Data) : 전역 변수
- 힙(Heap) : 동적 할당
- 코드(Code) → ROM(Read Only Memory) : 코드 및 초기화 데이터

또, 프로그램의 실행 과정에 대해서도 다음 자료를 참조해 간략하게 정리해보자

<aside>
📒 [1.1 프로그램의 구조](https://www.notion.so/1-1-3934a8fac2994bc982a31546e93c8185?pvs=21)

</aside>

- 여러 소스파일 (.cpp)들을 프로그래머가 작성하면
- 선행처리기에 의해서 소스를 재구성한다 (ex. #include, #define 등..)
- 컴파일을 통해 오브젝트 파일(.obj)을 생성한다 → 기계어로 변환하는 과정
- 링킹과정을 통해 여러 obj, cpp, 라이브러리들을 합쳐 하나의 실행 파일(.exe)를 생성

자, 이 다음에 생성된 실행 파일을 생성하면 다음 과정을 거친다

1. OS가 HDD/SDD 등 저장장치로부터 프로그램(코드)를 메모리(RAM, System Memory)로 가져와서 코드 영역에 넣는다
2. OS가 CPU의 RIP 레지스터에 프로그램의 시작점의 명령어가 있는 RAM 내부 주소를 전달한다.
3. CPU는 해당 시작점에 있는 명령어를 처리하고, RIP 레지스터에 저장된 주소에 있는 명령어를 처리하는 과정을 반복한다

<aside>
❓ 나중에 다시 공부해보기…
자료마다 서술하는 내용이 달라 어느걸 참조해야할지 모르겠다 ㅠ
[참고 자료 1](https://namoo-gamedev.tistory.com/8)  // 프로그램이 실행되는 과정
[참고 자료 2](https://80000coding.oopy.io/7819ea91-fc32-4129-96e6-e235b17d4335)  // 컴퓨터 구조 및 컴퓨터 동작 과정
[04. 프로그램의 실행과정](https://www.notion.so/04-99a2cd5647fe4272abfb92091926c973?pvs=21)

</aside>

참고로 메모리의 구조는 다음과 같다

![Untitled](2023%2012%2005%20-%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE,%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8,%20%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20187c5295ba8d4d4ab944b8e0947ab976/Untitled.png)

오늘 주요하게 볼 것은 코드 영역, 스택 영역!

### 코드 영역(Code) - ROM

프로그램의 코드가 저장되는 영역으로, 프로세스가 실행할 코드와 매크로 상수가 기계어의 형태로 저장된 공간!

CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리한다

<aside>
❓ 함수의 인자로 입력된 상수(literal)는 메모리를 할당 받는걸까? 코드 영역에서 바로 가져오는걸까?
→ 코드 영역에서 바로 가져온다!
Debug > Windows > Disassembly 를 통해서 확인해보면

```cpp
// 함수 호출
	int i = Add(200, 400);
// 00007FF7079A1A2E  mov         edx,190h  
// 00007FF7079A1A33  mov         ecx,0C8h  
// 00007FF7079A1A38  call        Add (07FF7079A11D1h)  
// 00007FF7079A1A3D  mov         dword ptr [i],eax
```

이렇게 Add함수가 호출되며 들어가는 인자가 literal일 때,
각각 200, 400을 edx 레지스터, ecx 레지스터로 mov하라는 명령을 볼 수 있다

그러면 함수가 호출되는 시점에서 각각의 인자를 사용할 메모리를 할당하고,

이 레지스터에 담아놓은 값들을 복사해 데이터를 대입한다는 것을 확인할 수 있다

```cpp
int Add(int a, int b)
{
// 00007FF7079A17D0  mov         dword ptr [rsp+10h],edx  
// 00007FF7079A17D4  mov         dword ptr [rsp+8],ecx  
// 00007FF7079A17D8  push        rbp  
// 00007FF7079A17D9  push        rdi  
// 00007FF7079A17DA  sub         rsp,108h  
// 00007FF7079A17E1  lea         rbp,[rsp+20h]  
// 00007FF7079A17E6  lea         rcx,[__AA4D0C39_main_01@cpp (07FF7079B2066h)]  
// 00007FF7079A17ED  call        __CheckForDebuggerJustMyCode (07FF7079A137Fh)
```

</aside>

### 스택(Stack) 영역

먼저 스택(Stack)이라는 것은, 말 그대로 쌓는다는 뜻이다

자료구조에서 의미하는 스택은 데이터를 쌓아올라가고, 제일 위에 있는 것부터 꺼내가는 형태를 의미하는, 즉 후입 선출 방식의 구조를 말한다

→ 메모리에서 의미하는 스택 영역도 동일한 형태를 취한다

이러한 메모리의 스택 영역은 함수의 호출과 관계있는 지역 변수, 매개변수가 저장되는 영역!

함수는 지정된 기능을 동작하기 위해선 메모리 공간이 필요하다

ex) 매개변수를 저장할 공간도 필요하고.. 반복문을 실행하며 사용하는 공간들.. 반환 값을 저장하기 위한 공간들…

이렇게 스택에 저장되는 함수의 호출 정보이자, 

그 함수만의 스택 영역을 구분하기 위하여 생성되는 공간 → **스택 프레임**

스택 영역에 메모리가 적재되고 해제되는 과정을 살펴보자

![Untitled](2023%2012%2005%20-%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE,%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8,%20%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20187c5295ba8d4d4ab944b8e0947ab976/Untitled%201.png)

이렇게 스택 영역은 함수의 호출과 함께 데이터가 할당되고, 함수의 호출이 완료되면 해제된다

- 조금 더 디테일한 스택 영역의 내용 (feat. 함수 호출 규약)
    
    함수 호출 규약(Calling Convention)이라는 것이 있다!
    
    함수를 호출하는 방식에 대한 약속인데, 이에 따라서도 스택 프레임을 정리하는 순서가 달라질 수 있다.
    
    Stack Frame에는 함수를 호출 시 **매개변수**, 함수가 종료될 때 **복귀할 명령어의 주소(return address),** **이전 Stack Frame의 EBP값**을 저장(함수가 끝나면 돌아가야 하니까)하고, 해당 함수의 **지역변수**를 저장하기 위한 공간을 할당한다
    
    `__cdecl` 함수 호출 규약에 의거하면 Caller(호출자)가 스택 프레임을 정리하며 esp 레지스터가 가리키는 스택의 값을 내려 스택을 해제한다.
    
    `__stdcall` 함수 호출 규약은 Callee(피호출자)가 스택 프레임을 정리하는데, 말 그대로 스스로 함수 내에서 스택프레임이 해제된다.
    
    그래서 뭐 반환(return)이 제대로 안되고 스택 프레임이 해제될 수도 있다는 말을 들었는데 사실 자세히는 모르겠음! 나중에 좀 더 공부해부자
    

### 재귀 함수

재귀 함수는 함수가 호출되면서, 자기 자신을 다시 호출하는 구조의 함수다

재귀 함수를 잘못 사용하게 되면 무한 루프가 일어나게 되면서, 스택프레임이 무한정으로 쌓이기 때문에 메모리 누적이 계속해서 발생된다

→ 그럼 스택 오버플로우 발생!!

따라서 **종료조건이 매우 중요하다!**

꽤 위험성이 있는데 왜 사용할까?

→ 간단(간결)하게 문제 해결이 가능한 경우에 사용하기 적합하기 때문

(ex. 계층 구조(트리) 형태 순회 …)

예시로 확인해보자면 두 가지가 있다

1. 팩토리얼 구현하기
    
    팩토리얼은 본인을 포함해 본인보다 작은 정수를 1까지 곱하는 식이다
    
    ```cpp
    5! == 5 * 4 * 3 * 2 * 1
    7! == 7 * 6 * 5 * 4 * 3 * 2 * 1
    ```
    
    재귀함수 없이 팩토리얼을 코드로 작성했다면,
    
    ```cpp
    #include <iostream>
    
    using namespace std;
    
    int Factorial(int _num)
    {
    	int result = 1;
    	
    	for(int i = 0; i < _num; i++)
    	{
    		result *= i + 1;
    	}
    }
    
    int main()
    {
    	cout << Factorial(3);         // 6
    	cout << Factorial(5);         // 120
    
    	return 0;
    }
    ```
    

만약, 재귀함수의 형태로 구현했다면

```cpp
#include <iostream>

using namespace std;

int Factorial_Recusion(int _num)
{
	// n! = n * (n-1)! 이라는 식으로 팩토리얼을 정리할 수 있다 -> 이를 재귀함수로 구현
	
	if(_num == 1)   // 반드시 재귀함수가 종료되는 조건 필요 (무한 루프를 막기 위해서)
	{
		return 1
	}
	else
	{
		return _num * Factorial_Recusion(_num - 1);
	}
}

int main()
{
	cout << Factorial_Recusion(3);
	cout << Factorial_Recusion(5);

	return 0;
}
```

1. 피보나치 수열 구현하기
    
    피보나치 수열은 앞에 나열된 두 숫자를 더해서 자기 자신을 만드는 수의 나열이다
    
    ```cpp
    1 1 2 3 5 8 13 21 34 ...
    ```
    
    재귀함수 없이 피보나치 수열을 구현했다면
    
    ```cpp
    int Fibonacci(int _Num)
    {
    	// 피보나치 수열의 종료 조건 설정 -> 최초의 두 항이 1, 1일 경우
    	// ⭐ || 연산자는 왼쪽 피연산자의 bool값을 먼저 판별해, 참이라면 바로 참을 반환한다 (조건 판별조건 충족)
    	if (1 == _Num || 2 == _Num) 
    	{
    		return 1;
    	}
    
    	// 3항 이상인 경우 처음 두 항(1, 1)부터 누적해서 해당 항을 구해준다
    	int iResult = 0;
    
    	int Prev1 = 1;
    	int Prev2 = 1;
    
    	for (int i = 0; i < _Num - 2; i++)
    	{
    		iResult = Prev1 + Prev2;
    
    		Prev1 = Prev2;
    		Prev2 = iResult;
    	}
    
    	return iResult;
    }
    
    int main()
    {
    	int iReturn = Fibonacci(5);
    
    	return 0;
    }
    
    ```
    
    만약, 재귀함수 형태로 구현했다면
    
    ```cpp
    int Fibonacci_Recursion(int _Num)
    {
    	if (1 == _Num || 2 == _Num) 
    	{
    		return 1;
    	}
    
    	return Fibonacci_Recursion(_Num - 1) + Fibonacci_Recursion(_Num - 2);
    }
    
    int main()
    {
    	int iReturn = Fibonacci_Recursion(4);
    
    	// 단, 피보나치 수열을 재귀로 구현할 경우, 높은 항을 구하려면 엄청난 함수 호출횟수가 발생한다 (메모리 그림 참조)
    	int jReturn = Fibonacci_Recursion(32);
    
    	return 0;
    }
    ```
    
    → 그림처럼 함수 내에서 계속해서 함수 호출이 일어나므로 스택 프레임이 해제되지 않은 채로 누적되고, 함수를 호출하는데 소요되는 메모리와 시간이 기하급수적으로 늘어나게 된다
    
    ![Untitled](2023%2012%2005%20-%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE,%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8,%20%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20187c5295ba8d4d4ab944b8e0947ab976/Untitled%202.png)
    

위의 예제를 통해서 알 수 있듯이, 재귀함수는 장/단점이 아주 명확하다

**재귀함수의 장점**

1. 코드가 간결해진다
2. 구현의 직관성이 생긴다

**재귀함수의 단점**

1. 느리고, 무겁다 (최적화에 적용하기 어렵다)