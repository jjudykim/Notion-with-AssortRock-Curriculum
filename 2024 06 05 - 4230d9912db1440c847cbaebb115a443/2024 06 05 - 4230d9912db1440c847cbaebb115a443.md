# 24/06/05 -

ìƒìœ„ í•­ëª©: Week28 (Week28%206f1fa435aab64ebfb3faf46800876086.md)
ì£¼ì°¨: 0011_Week20~29

### ì¶©ëŒì²´ì˜ ì¶©ëŒ ê¸°ëŠ¥ êµ¬í˜„

API ë•Œ êµ¬í˜„í–ˆë˜ ì¶©ëŒ ë§¤ë‹ˆì €ë¥¼ í†µí•œ ì¶©ëŒ ê²€ì‚¬ì™€ ê±°ì˜ ìœ ì‚¬í•˜ê²Œ êµ¬í˜„!

<aside>
ğŸ“ 04. Manager > 06. CollisiongMgr > `CCollisionMgr.h`, `CCollisiongMgr.cpp` ìƒì„±

</aside>

```cpp
class CCollisionMgr :
	public CSingleton<CCollisiongMgr>
{
	SINGLE(CCollision);
	
private: 
	// í•œ ì¤„ì— 32ë¹„íŠ¸ê°€ ë‹´ê¸°ëŠ” Matrixë¥¼ ì œì‘í•´ì•¼ í•˜ë¯€ë¡œ (max layerê°€ 32ë¼ì„œ)
	UINT m_Matrix[MAX_LAYER];
	map<ULONGLONG, bool> m_mapCollisionInfo;
	
public:
	void CollisionCheck(UINT _Layer1, UINT _Layer2);
	
	void IsCollision
			
}
```

```cpp
#include "pch.h"

#include 
CCollisionMgr::CCollisionMgr()
	: m_Matrix[]
{
}

CCollisionMgr::~CCollisionMgr()
{
}
```

```cpp
void CCollisionMgr::CollisionCheck(UINT Layer1, UINT Layer2)
{
	UINT Row = Layer1;
	UINT Col = Layer2;

	// ë” ì‘ì€ ìˆ«ìë¥¼ í–‰ìœ¼ë¡œ ì ‘ê·¼	
	if (Row > Col)
	{
		Row = (UINT)Layer2;
		Col = (UINT)Layer1;
	}
	
	if (m_Matrix[])
	{
	}
}
```

í˜„ì¬ ì¶©ëŒ ì¤‘ì¸ì§€ ê²€ì‚¬í•˜ëŠ” í•¨ìˆ˜ â†’ IsCollision

```cpp

```

Tick

```cpp
void CCollisionMgr::Tick()
{
	CLevel* pCurLevel = CLevelMgr::GetInst()->GetCurrentLevel();
	
	for(int Row = 0; Row < MAX_LAYER; ++Row)
	{
		for (int Col = Row; Col < MAX_LAYER; ++Col)
		{
			
			}
		}
	}
}
```

Tickì˜ ê³¼ì •ì—ì„œ ë‘ ë ˆì´ì–´ì˜ ì¶©ëŒ ê²€ì‚¬ì— í˜¸ì¶œëœ  `CollisionBtwLayer`

```cpp
void difjslf
{
	// í•´ë‹¹ ë ˆì´ì–´ê°€ ì†Œìœ í•˜ê³  ìˆëŠ” ëª¨ë“  ì˜¤ë¸Œì íŠ¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤
	if (m_Matrix[Row] & (1 << Col))
	{
		const vector<CGameObject*>& vecLeft = pCurLevel->GetLayer(Row)->GetObjects();
		const vector<CGameObject*>& vecRight = pCurLevel->GetLayer(Col)->GetObjects();
			
		for(size_t i = 0; i < vecLeft.size(); ++i)
		{
			CCollider2D* pLeftCol = vecLeft[i]->Collider2D();
			
			// ì¶©ëŒì²´ ì»´í¬ë„ŒíŠ¸ë¥¼ ë³´ìœ í•˜ê³  ìˆì§€ ì•Šì€ ì˜¤ë¸Œì íŠ¸ ì¼ ê²½ìš°
			if (pLeftCol == nullptr)
				continue;

			for (size_t j = 0; j < vecRight.size()
			{
				CCollider2D* pRightCol = vecRight[i]->Collider2D();
				
				// ì¶©ëŒì²´ ì»´í¬ë„ŒíŠ¸ë¥¼ ë³´ìœ í•˜ê³  ìˆì§€ ì•Šì€ ì˜¤ë¸Œì íŠ¸ ì¼ ê²½ìš°
				if (pRightCol == nullptr)
					continue;
			}
		}
}

```

ì—”ì§„ì˜ Progressì—ì„œ CollisionMgrì˜ Tick ì§„í–‰

```cpp

```

ì¶©ëŒ ì„¤ì •ì„ ìœ„í•œ Levelì˜ ì—­í•  ë¶€ì—¬

```cpp
void CLevelMgr::Init()
{
	// ...
	// Level ìƒì„±
	m_CurLevel = new cLevel;
	
	m_CurLevel->GetLayer(0)->SetName(L"Default")
	m_CurLevel->GetLayer(1)->SetName(L"
	m_CurLevel->GetLayer(1)->SetName(L"
	m_CurLevel->GetLayer(1)->SetName(L"
	m_CurLevel->GetLayer(1)->SetName(L"
	m_CurLevel->GetLayer(1)->SetName(L"
}
```

Level Begin ì „ì—, Collision Check ì‹œí–‰

```cpp
void CLevelMgr::
```

### ì¶©ëŒ ê²€ì‚¬ì˜ ì›ë¦¬ì™€ IsCollisionì˜ êµ¬í˜„

```cpp
bool CCollisionMgr::IsCollision(CCollider2D* _Left, CCollider2D* _Right)
{
	// ë¡œì»¬ ìŠ¤í˜ì´ìŠ¤ ìƒì—ì„œ Meshì˜ 4ì ì˜ ìœ„ì¹˜ë¥¼ ì•Œê¸° ìœ„í•œ ì‘ì—…
	Ptr<CMesh> pRectMesh = CAssetMgr:::GetInst()->FindAsset<CMesh>(L"RectMesh");
	Vtx* pVtx = (Vtx*)pRectMesh->GetVtxSysMem();

	// ê° ì¶©ëŒì²´ì˜ ì›”ë“œ í–‰ë ¬ì„ ê°€ì ¸ì˜¨ ë’¤
	const Matrix& matLeft = _Left->GetWorldMat();
	const Matrix& matRight = _Right->GetWorldMat();
	
	// íˆ¬ì˜ë  ìˆœìˆ˜í•œ ë°©í–¥ë²¡í„°ë¥¼ êµ¬í•˜ëŠ” ê³¼ì •
	// ê¸°ë³¸ ë„í˜•(Rect)ë¥¼ ê° ì¶©ëŒì²´ì˜ ì›”ë“œ í–‰ë ¬ì„ ê³±í•´ì„œ, ì¶©ëŒì²´ì˜ ê° ëª¨ì„œë¦¬ ìœ„ì¹˜ë¡œ ì˜®ê¸´ í›„,
	// ì¢Œí‘œë¼ë¦¬ ìœ„ì¹˜ê°’ì„ ë¹¼ì„œ ì¶©ëŒì²´ì˜ ì›”ë“œìƒì—ì„œì˜ ìœ„ì¹˜ì—ì„œ ë„í˜•ì˜ í‘œë©´ ë°©í–¥ë²¡í„°ë¥¼ êµ¬í•œë‹¤.
	// ì´ ë²¡í„°ëŠ” ì¶©ëŒì²´ë“¤ì„ íˆ¬ì˜ì‹œí‚¬ ì¶•ì´ ëœë‹¤
	Vec3 vProjAxis[4] = {};
	
	// TransformCoord -> ë™ì°¨ì¢Œí‘œ 1 ì„¤ì • (Local -> World ë°°ì¹˜ë‹ˆê¹Œ)
	// íˆ¬ì˜ì˜ ì¶•ì´ ë˜ê¸°ë„ í•˜ë©´ì„œ, íˆ¬ì˜ë˜ì–´ì•¼ í•  ì£¼ì²´ê°€ ë˜ê¸°ë„ í•˜ëŠ”... 
	vProjAxis[0] = XMVector3TransformCoord(pVtx[3].vPos.matLeft) - XMVector3TransformCoord(pVtx[0].vPos.matLeft);
	vProjAxis[1] = XMVector3TransformCoord(pVtx[1].vPos.matLeft) - XMVector3TransformCoord(pVtx[0].vPos.matLeft);
	
	vProjAxis[2] = XMVector3TransformCoord(pVtx[3].vPos.matRight) - XMVector3TransformCoord(pVtx[0].vPos.matRight);
	vProjAxis[3] = XMVector3TransformCoord(pVtx[1].vPos.matRight) - XMVector3TransformCoord(pVtx[0].vPos.matRight);
	
	// ì¶©ëŒì²´ì˜ ì¤‘ì‹¬ì„ ì‡ëŠ” ë²¡í„°
	Vec3 vCenter = XMVector3TransformCoord(Vec3(0.f, 0.f, 0.f), matLeft) - XMVector3TransformCoord(Vec3(0.f, 0.f, 0.f), matRight));
	
	
	// íˆ¬ì˜ ì¶• ìƒì„± (4ë²ˆ ìˆ˜í–‰)
	for (int i = 0; i < 4; ++i)
	{
		Vec3 vProj = vProjAxis[i];
		vProj.Normalize();
		
		// vProjì™€ íˆ¬ì˜ í›„ë³´ê°€ ë˜ëŠ” ë²¡í„° ë‚´ì í–ˆì„ ë•Œ íˆ¬ì˜í–ˆì„ ë•Œì˜ ê¸¸ì´ê°€ ì‚°ì¶œ..?
		// ë¬´ì¡°ê±´ ì–‘ì˜ ê°’ìœ¼ë¡œ ë„ì¶œë˜ë„ë¡ ì ˆëŒ€ê°’ìœ¼ë¡œ ë³€í™˜
		float dot = fabs(vProjAxis[0].Dot(vProj));
		dot += fabs(vProjAxis[1].Dot(vPorj));
		dot += fabs(vProjAxis[2].Dot(vPorj));
		dot += fabs(vProjAxis[3].Dot(vPorj));
		dot /= 2.f;
		
		float fCenter = fabs(vCenter.Dot(vProj));
		
		if (dot < fCenter)
			return false;
	}
	
	return true;
}
```

íšŒì „ìƒíƒœì¼ ë•Œì—ë„ ì¶©ëŒê²€ì‚¬ê°€ ì •ë°€í•˜ê²Œ ë˜ë ¤ë©´?

ë©´ì  ê·¸ëŒ€ë¡œ x,  y ì¶•ìœ¼ë¡œ íˆ¬ì˜í–ˆì„ ë•Œ í•´ë‹¹ ë©´ì ì˜ ì ˆë°˜ì„ ê³„ì‚°í•´ì„œ ì„œë¡œì˜ ê¸¸ì´ì™€ ë¹„êµ..

ë”°ì§€ëŠ” ì¶•ì´ ì´ 4ë²ˆ?

- ì¶©ëŒì²´ë¥¼ ì‹œë„í•˜ë ¤ëŠ” ì‚¬ê°í˜•ì˜ í‘œë©´ê³¼ í‰í–‰í•œ ë°©í–¥ìœ¼ë¡œ x, yì¶• íˆ¬ì˜ â†’ 2ë²ˆ
- ì„œë¡œì˜ ì¤‘ì‹¬ì ì„ ì´ì€ ê²ƒì„ ì›ì ì˜ x, yì¶•ì— ìˆ˜ì§ìœ¼ë¡œ íˆ¬ì˜ â†’ 2ë²ˆ

â†’ ì´ 4ë²ˆì˜ ê³¼ì •ì„ ëª¨ë‘ í†µê³¼í•´ì•¼ ì§„ì§œ ì¶©ëŒ!

ì´ê±° ê·¸ë¦¼ìœ¼ë¡œ ê¼¬ì˜¥ ê·¸ë ¤ë³´ê¸°â€¦.

ì´ ì¶©ëŒ ì—°ì‚° ë°©ë²•ì€ OBB ì¶©ëŒ

### AABB ì¶©ëŒ / OBB ì¶©ëŒ ë¹„êµ

<aside>
ğŸ“ [https://sanghoon23.tistory.com/82](https://sanghoon23.tistory.com/82) ì°¸ì¡°

</aside>