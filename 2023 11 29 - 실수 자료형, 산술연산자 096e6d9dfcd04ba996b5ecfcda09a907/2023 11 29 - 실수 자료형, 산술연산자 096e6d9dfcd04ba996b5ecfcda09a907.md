# 2023/11/29 - 실수 자료형, 산술연산자

태그: C++, CS, 입문
날짜: 2023/11/29
상위 항목: Week1 (../../Week1%20b504431a81c04149b2f5d2508cc1502f.md)
주차: 0001_Week1~9

### 디버그 팁 및 단축키

`F9` : 해당 라인에 중단점 생성

`Ctrl` + `Shift` + `F9` : 중단점 모두 삭제

`F5` : 디버그 모드로 실행, 실행 중 중단점이 있으면 다음 중단점까지 한번에 실행

`Ctrl` + `F5` : 디버그 없이 실행

`Shift` + `F5` : 디버그 모드 중지, 프로세스를 중단

`F10` : 중단점에서 멈추었을 때 한 단계 실행 (현재 실행되는 함수 기준에서의 한 단계)

`F11` : 중단점에서 멈추었을 때 한 단계 실행 (최소 단위, 말 그대로 한 줄의 단계별 진행)

### 실수 타입의 자료형

실수 타입의 자료형은 말 그대로 소수점까지 표현하는 자료형

- float(4)
- double(8)

→ 소수점을 어느 자리까지 정의할 것이냐에 따라서 메모리 공간과 표현할 수 있는 정밀도가 달라짐

특정 비트값을 하나의 실수 숫자에 대응하기에는, 실수는 표현할 수 있는 가짓수가 무한대이기 때문에 표현 방법 자체가 정수형과 다르며 *가장 가까운 비트값을 찾는 것*으로 생각해야 함. 즉, 실수는 정확한 값이 아님! (아래 소숫점 자리로 갈 수록 오차율 증가)

→ ***부동소수점 표현 방식***을 사용

**실수 타입의 변수를 조건으로 활용할 때**

→ 같게(==) 설정하기보다는, 오차를 고려해 범위에 포함되도록 설정하는 것이 좋다

<aside>
📒 실수 타입의 변수를 조건으로 활용해 오차의 한계 지정하는 법 참조
→ [3.5 관계 연산자 Relational Operators](https://www.notion.so/3-5-Relational-Operators-7eb963901512483b873784d264d7dbd1?pvs=21)

</aside>

### 부동소수점 표현 방식 이해하기

![Untitled](2023%2011%2029%20-%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%AE%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%92%E1%85%A7%E1%86%BC,%20%E1%84%89%E1%85%A1%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1%20096e6d9dfcd04ba996b5ecfcda09a907/Untitled.png)

-118.625를 부동소수점을 사용해 표현해보자

1. 음수이므로, 부호부는 1
2. 절대값(118.625)을 이진법으로 나타내면 1110110.101
    
    +) 소수부를 이진수로 쉽게 변환하는 계산방법
    
    ```cpp
    소수부에 2를 곱하고, 그 결과가 1로 떨어질 때까지, 혹은 똑같은 소수점이 나올 때까지 반복
    0.625 X 2 = 1.250 // 정수부는 버린다
    0.250 X 2 = 0.500
    0.500 X 2 = 1.000
    
    위에서 부터 결과의 정수부를 가져오면
    결과 : 101
    ```
    
3. 소수점을 왼쪽으로 이동시켜, 정수부에 1만 남도록 만들기
    
    → 1.110110101 X $2^6$
    
    이게 정규화된 부동소수점 수!
    
4. 가수부는 소수점의 오른쪽 부분으로, 부족한 비트 수 부분만큼 0으로 채워 23비트로 만든다
    
    → 결과는 11011010100000000000000
    
5. 지수부는 지수가 6이므로, 32비트 IEEE 754 형식의 Bias인 127을 더해 133을 이진법으로 변환한다
    
    → 결과는 10000101
    

최종적으로 -118.625를 부동소수점을 사용해 표현할 경우

1100 0010 1110 1101 0100 0000 0000 0000 0000

![Untitled](2023%2011%2029%20-%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%AE%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%92%E1%85%A7%E1%86%BC,%20%E1%84%89%E1%85%A1%E1%86%AB%E1%84%89%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1%20096e6d9dfcd04ba996b5ecfcda09a907/Untitled%201.png)

### 형변환

- 암시적 형변환
    
    ```cpp
    float f = 7.f;
    int i = f;
    ```
    
    → float 타입 데이터를 int 타입으로 암시적 형변환이 이루어짐 (경고 발생)
    
- 명시적 형변환
    
    ```cpp
    float f = 7.f;
    int i = (int)f;
    ```
    
    → float 타입 데이터를 int 타입으로 명시적 형변환이 이루어짐 (프로그래머가 명확하게 직접적으로 타입을 적어서 형변환한다)
    

### 정수형과 실수형의 연산

정수와 정수끼리 연산 → 정수형의 연산 결과

실수와 실수끼리 연산 → 실수형의 연산 결과

실수와 정수끼리 연산 → 실수형의 연산 결과

즉, 정수를 연산해 실수의 결과값을 얻고 싶다면 명시적 형변환을 통해서 둘 중 한 변수라도 실수로 변환해 계산해야 한다

<aside>
📒 +) **기본 데이터 타입의 형변환**

- 큰 수와 작은 수를 연산했을 때 큰 수로 형변환된다.
- 덜 정밀한 수와 정밀한 수를 연산했을 때 정밀한 수로 형변환된다.
- 정수와 실수를 연산했을 때 실수형으로 형변환된다.
- 작은 수가 큰 수로 형변환되는 것은 자동이다.
    
    → 반대의 경우는 강제 형변환이 필요 - 오버플로우 발생
    
- 덜 정밀한 수가 정밀한 수로 형변환되는 것은 자동이다.
    
    → 반대의 경우는 강제 형변환이 필요 - 오버플로우 발생
    
</aside>

### 연산자 (1) - 산술연산자

**사칙연산자**

- 증감 연산자 (`++`,  `--`)
    
    → 값을 증가시키거나 감소시키는 연산자
    
    ```cpp
    num = 7
    ++num // -> (전위, 전치) 8
    num++ // -> (후위, 후치) 8이 출력된 후에 안에 있는 값이 9로 바뀜
    --num // -> (전위, 전치) 8
    num-- // -> (후위, 후치) 8이 출력된 후에 안에 있는 값이 8로 바뀜
    ```
    
    → 전위와 후위에 따라 연산자 우선순위가 변경된다
    
    - 전위는 우선순위가 가장 빠르고 (해당 라인이 실행되면서 바로 증감이 이루어지고)
    - 후위는 우선순위가 가장 느리다 (해당 라인이 끝나기 직전에 증감이 이루어진다)
    
- 대입 연산자 (`=`) → 우선순위 가장 낮음!
- 더하기 (`+`)
- 빼기 (`-`)
- 곱하기 (`*`)
- 나누기(`/`)
- 나머지(`&`), **모듈러스**라고도 부른다
    
    → 실수의 나눗셈에서는 나머지 개념 자체가 없으므로 정수끼리의 연산에서만 사용이 가능하다
    

```cpp
int a = 100;
int b = 200;
int c = 0;

c = a + b;
c = a - b;
c = a * b;
c = a / b; // -> 정수끼리의 나눗셈이 되어버려서 소숫점은 버리고 몫만 계산하게 된다
c = a & b; // -> 100을 200으로 나눈 나머지 
```

### 지역 만들기 { }

코드 내에서도 분리된 지역을 만들 수 있다

```cpp
int i = 0;

{
	int i = 0;

	i++;

	cout << i;   // 1 출력
}

cout << i;   // 0 출력
```

→ i 를 두번 출력했지만 출력되는 값이 다르다

지역에 선언한 i와 지역 밖의 i는 서로 다른 메모리를 사용하고, 다른 변수로 취급한다

따라서 증가된 i는 지역 내의 i이기 때문에 서로 다른 값이 출력된다

### bool 타입

참과 거짓을 다루는 자료형은

`bool`

- 1byte, 표현 체계는 정수타입이지만 정수처럼 사용하지 않는다
- 참 또는 거짓을 다루기 때문에 `0`만을 false, 나머지 값을 true(`1`)라고 인식한다