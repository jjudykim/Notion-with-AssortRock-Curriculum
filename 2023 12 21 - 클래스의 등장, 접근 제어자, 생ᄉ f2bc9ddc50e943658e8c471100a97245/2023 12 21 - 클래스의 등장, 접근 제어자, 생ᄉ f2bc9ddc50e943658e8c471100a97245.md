# 2023/12/21 - 클래스의 등장, 접근 제어자, 생성자, 소멸자

태그: C++, 자료구조, 중급, 초급
날짜: 2023/12/21
상위 항목: Week4 (Week4%20d4bcf132c05941958a5653faa4dd0faf.md)
주차: 0001_Week1~9

### C와 C++의 차이

기존에 C에서 부족했던 점을 많이 보완해 등장하게 된 언어가 C++이었는데..

가장 핵심적인 개선사항이 바로 클래스의 추가! → 객체지향의 등장이라고 할 수 있다

### 클래스의 등장

클래스도 기존에 배웠던 구조체(struct)처럼 사용자 정의 자료형이라는 점에서는 동일하다!

그러나

- 생성자, 소멸자의 추가
- 멤버 함수라는 개념
- 연산자 오버로딩
- 상속, 다형성, 추상화 …

등등의 기능들이 더 부가적으로 사용이 가능하며, 무엇보다 객체지향을 추구하는 점에서 차별화된다고 볼 수 있다

공통적인 데이터와 기능들을 모아 추상화한 것을 **클래스**라고 하고,

클래스는 **이 틀 자체**를 의미하는 것이며, 아직 구체화되어 메모리 상에 실존하는 것은 아니다!

이걸 **틀로 찍어내서 만든 실체**, 그리고 메모리 상에 실존하는 것이 바로 **객체(Object)**이다

### 접근 제어자

접근 제어자는 클래스의 은닉성에 필수적인 존재로, 클래스의 멤버에 대한 접근 영역을 설정해주는 키워드! → private, protected, public

- ⭐ `private`
    
    : 클래스 외부에서 접근이 불가능하도록 숨기는 제어자, 클래스 내의 멤버 함수에서만 접근 가능!
    
- `protected`
    
    : private과 비슷하게 클래스 내의 멤버 함수에서만 접근 가능하지만, 상속과 관련!
    
    이 클래스를 상속받는 자식 클래스의 멤버 함수에서는 접근 허용
    
- ⭐ `public`
    
    : 클래스 내/외부의 모든 곳에서 접근을 허용함
    

클래스는 접근 제어자를 따로 명시해주지 않으면, 기본적으로 private한 상태!

### 나를 가리키는 객체 포인터, this

this는 자기 자신(객체)의 주소를 담는 포인터이다!

포인터이므로, `this->멤버` 로 접근한다 ( `(*this).멤버` 와 같은 의미)

클래스는 내부적으로 this라는 지역 변수를 가지고, 해당 멤버 함수를 호출시킨 객체의 주소 (즉, 객체 나 자신)이 들어온다 → 즉, 나 자신을 가리키는 해당 클래스 타입의 포인터이다

따라서 멤버 함수 안에서 지칭하는 멤버 변수는 앞에 `this->` 가 생략되어 있는 것이나 마찬가지!

```cpp
// 우리가 보는 모습
void setInt(int _a)
{
	m_i = _a;
}

// 내부적으로 구현된 모습
void setInt(int _a)
{
	this->m_i = _a;     // (*this).m_i = a;와도 같은 표현!
}
```

```cpp
void main()
{
	Test a;
	Test b = {};

	b.setInt(10);      // 내부적으로는, b의 객체를 가리키는 포인터 this를 통해 
										 // 멤버함수에서 멤버변수 m_i에 접근해 10이라는 값을 할당한다
}
```

### 생성자, 소멸자

생성자와 소멸자는 둘 다 멤버 함수의 일종으로, 객체가 생성되거나 / 소멸될 때 호출되기로 약속된 함수들이다! 따라서 다양한 규칙이 있으니까 잘 숙지하도록 하기 😽

```cpp
class Test
{
	// ...
	Test()
	{
		// Constructor
		// ...
	}

	~Test()
	{
		// Destructor
		// ...
	}
}
```

**생성자 Constuctor**

: 객체가 생성되자마자 실행되는 함수로, 주로 멤버들을 초기화하는 내용이 들어가거나 객체가 생성되자마자 실행되어야 할 내용들이 들어가게 된다!

- 이름이 클래스의 이름과 같다
- 반환타입이 존재하지 않는다
- 객체가 생성되자마자 실행되어야 하므로 public해야 한다
- 함수 오버로딩이 가능하다
- 생성자의 매개변수가 없을 경우, 호출 시 괄호를 생략한다 ex) `Test test1()` → ❌
- 객체가 생성될 때, 명시적으로 호출하지 않아도 **자동 호출**된다
    
    → 물론, 명시적으로도 호출이 가능하다!
    
- ⭐ 만약 생성자를 직접 구현해놓지 않았다면, 자동 호출에 대한 규칙을 지키기 위해서 컴파일러가 매개변수가 존재하지 않고, 아무 기능도 수행하지 않는 **기본 생성자**를 구현한다!
    
    → 단, 직접 구현한 생성자가 1개 이상 존재할 경우에는 기본 생성자를 만들어주지 않으므로 주의하기!!
    

**소멸자 Destructor**

: 객체가 영역을 벗어나서 메모리에서 해제될 때 자동으로 호출되는 함수로, 주로 메모리를 동적으로 할당받는 멤버가 있을 경우 소멸자 안에서 delete(free)를 유용하게 해줄 수 있다

- 이름이 클래스의 이름 앞에 `~` 가 붙은 형태이다
- 반환타입이 존재하지 않으며, 매개변수도 존재하지 않는다
- 자동으로 호출되는 함수이기에 직접 호출되는 것은 권장되지 않는다
- 동적 할당받는 멤버가 있을 때, 소멸자 내에서 delete할 경우 메모리 누수 관리가 편리해진다

생성자와 소멸자에 대한 내용은 열혈 C++에서 디테일하게 정리했었다!

다음 자료 참조해서 복습하기

<aside>
📒 [04-3 생성자(Constructor)와 소멸자(Destructor)](https://www.notion.so/04-3-Constructor-Destructor-7e71b1970fb24820bcbb3d6d0f3d3345?pvs=21)

</aside>

### 생성자의 멤버 이니셜라이저(initializer)

생성자 내부의 중괄호 `{ }` 처리가 시작되기 전에, 초기화가 먼저 완료되는 멤버 목록을 나열하기 위해 작성하는 것으로, 생성자 이름 바로 아래 `:` 에서 각 멤버들을 초기화할 수 있다!

```cpp
class Something
{
private:
    int     _i;
    double  _d;
    char    _c;
    int     _arr[5];

public:
    Something()
        : _i{ 10 }
				, _d{ 3.14 }
				, _c{ 'a' }
				, _arr{ 1, 2, 3, 4, 5 }
    {
        // ...
    }
}
```

멤버 이니셜라이저를 활용한 초기화 우선순위에 대한 내용은 요기 참조!

<aside>
📒 [8.4 생성자 멤버 초기화 목록 (멤버 이니셜라이저)](https://www.notion.so/8-4-c399af3434a54b299c91a94fd09ce724?pvs=21)

</aside>

### 함수 오버로딩과 생성자 오버로딩

함수의 오버로딩은 간단히 말해서 **함수의 이름 재사용**이라고 할 수 있다!

함수의 이름이 같지만, 함수의 인자 개수 또는 인자 타입이 달라 구별할 수 있는 여지가 있는 경우에, 동일한 함수 이름으로 여러 개의 함수를 만드는 것이다!

동일한 이름을 가진 함수 중 호출 형태에 따라 어떤 함수를 호출할지 컴파일러가 판단한다

<aside>
📒 다른 함수라고 판단되는 기준에 부합하지 않는 경우에 대한 내용 참조
→ [7.7 함수 오버로딩](https://www.notion.so/7-7-e4c6a4d11e124901931cf7257f5dd40d?pvs=21) 
요약하자면…
1. 리턴 타입만 다른 함수
2. 매개변수의 이름만 다른 함수
3. 인자 타입을 typedef를 사용해 다르게 한 함수

</aside>

이러한 오버로딩의 개념을 생성자에도 그대로 적용시킨다면,

생성자도 함수의 일종이기 때문에 생성자의 오버로딩이 가능하다!

```cpp
Test()
	: m_i(0), m_f(0.f)
{
	// ...
}

Test(int _i)
	: m_i(_i), m_f(0.f)
{
	// ...
}

Test(int _i, float _f)
	: m_i(_i), m_f(_f)
{
	// ...
}
```