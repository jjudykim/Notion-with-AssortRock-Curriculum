# 2023/12/19 - 동적 배열의 구현(2), 그리고 연결형 리스트의 구현(1)

태그: C++, 자료구조, 중급, 초급
날짜: 2023/12/19
상위 항목: Week4 (Week4%20d4bcf132c05941958a5653faa4dd0faf.md)
주차: 0001_Week1~9

동적 배열의 구현 부분은 18일자 강의 메모에 함께 정리했다!

<aside>
📒 [2023/12/18 - 동적할당(malloc, free)과 동적 배열의 구현(1)](2023%2012%2018%20-%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%A1%E1%86%AF%E1%84%83%E1%85%A1%E1%86%BC(malloc,%20free)%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%87%2088f14e9008ef4b37a16a8fb49eae648a.md)

</aside>

오늘 구현해 볼 것은, 연결형 리스트 <list>

```cpp
동적 배열(가변 배열)            <vector>
연결형 리스트(linked list)      <list>    -> 오늘 해볼 것!
이진 탐색 트리                  <map>
```

### 연결형 리스트란?

연결형 리스트는, 해당 데이터 크기만큼의 메모리만 할당받아 데이터를 저장한 후, 해당 메모리에 다음 데이터를 저장한 메모리주소를 같이 저장해 링크로 연결해놓은 것이다!

더 정확히 정리하자면,

각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.

각 노드는 다음 노드를 가리키는 포인터를 포함하며, 다음 노드를 가리키는 포인터는 다음 노드의 주소값을 갖고 있다!

→ 즉, 각 노드의 포인터 변수는 다음 노드의 데이터의 주소를 값으로 가지며 각 포인터 변수의 주소도 따로 존재한다.

그렇다면 **어떤 이점으로 연결형 리스트를 사용할까?**

전에 배웠던 동적 배열과 연결형 리스트를 비교해보자면,

**동적 배열**의 경우,

- 장점

: 접근을 index를 이용해 손쉽게 할 수 있으며, 속도가 빠르다 (Big-O 표기법 중 최고 → O(1))

- 단점

: 불필요한 데이터를 삭제하거나 지정된 위치에 데이터를 삽입하려고 할 경우 복잡한 작업을 진행해야 한다 (최악 → O(N))

연결형 리스트의 경우,

- 장점

: 불필요한 데이터를 삭제하거나 지정된 위치에 데이터를 삽입하려고 할 때, 데이터의 개수에 상관없이 다음 노트를 가리키는 포인터의 값만 변경해주면 되기 때문에 속도가 빠르고 용이하다 (최고 → O(1))

- 단점

: 주소 접근 연산을 특정 index 위치만큼 반복해서 수행해 접근해야 한다 (최악 → O(N))

따라서, **자료 구조는 상황에 따라서 데이터를 관리하는 자료구조가 어떤 것이 더 효율적이고 유리할지 고민하고 선택**하면 된다!

### 동적할당을 활용한 자료구조의 구현 (2) - 연결형 리스트

```cpp
#pragma once

// 연결형 리스트의 각 노드
struct Node
{
	int Data;     // 노드에 저장된 데이터
	Node* pNext;  // 다음 노드를 가리키는 포인터
}

// 연결형 리스트
struct LinkedList
{
	Node* pHeadNode;  // 첫번째 노드의 주소값
	int CurCount;
	// 연결형 리스트는 MaxCount를 확인할 필요가 없다!
	// -> 연결형 리스트는 그때그때 삽입하는 데이터만큼의 메모리만 할당하기 때문에,
	//    메모리 초과의 현상이 발생할 이유가 없다
}
```

![Untitled](2023%2012%2019%20-%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB(2),%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%80%E1%85%A9%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%A7%202bded1fba91c4d6591e4d28a43ac7554/Untitled.png)

→ 그림으로 그려보면 이런 구조!! 

LinkedList의 pHeadNode는 첫번째 노드를 가리키며 리스트의 시작을 갖고 있고,

각 노드가 생성되며 데이터를 담고 있으면서 다음 노드의 주소를 포함하고 있다!

즉, 해당 노드에 다음 노드의 주소가 없다면, 해당 노드가 마지막으로 생성된 노드.

### 연결형 리스트의 멤버(노드) 추가 기능 구현 - PushBack

```cpp
#include <iostream>
#include "LinkedList.h"

void PushBack(LinkedList* _List, int _Data)
{
	// 입력된 데이터를 저장할 새로운 노드를 할당받고,
	// 입력된 데이터를 노드 안에 복사하는 기능을 수행!

	// 힙 영역에 노드 객체를 하나 생성해준다!
		Node* pNewNode = (Node*) malloc(sizeof(Node));
		pNewNode->Data = _Data;
		pNewNode->pNext = nullptr;

	// 만약 지금 생성한 노드가 첫 노드라면,
	if (_List->pHeadNode == nullptr)
	{
		// 현재 생성한 첫 노드를, 연결형 리스트의 첫번째 노드로 저장!
		_List->pHeadNode = pNewNode;
	}
	// 리스트에 존재하는 노드가 1개 이상이라면,
	else
	{
		// 전 노드와 연결하는 작업이 필요하다
		// 즉, 전 노드의 다음 노드를 저장하는 pNext에 현재 노드의 주소값 저장 필요!
		
		// 1. 리스트가 보유한 노드 중, 가장 마지막 노드를 찾는다
		// 임시 노드 객체 pNode는 첫번째 노드를 가리키다가,
		Node* pNode = _List->pHeadNode;
		while (true)
		{
			// pNode가 가리키는 것이 해당 노드의 다음 노드의 주소값이 되도록 변경해준다.
			pNode = pNode->pNext;
			// 이때 pNode가 가지고 있는 다음 노드의 주소값이 null일 경우에는, 이 노드가 마지막 노드라는 것을 알 수 있다!
			if(pNode->pNext == nullptr) break;
		}

		// 2. 찾은 노드의 pNext를 현재 생성한 노드를 가리키도록 한다 (연결)
		pNode->pNext = pNewNode;
	}

	// currentCount 1 증가!
	_List->CurCount++;
}
```

```cpp
#include <iostream>
#include "LinkedList.h"

int main()
{
	int data;
	LinkedList list = {};

	PushBack(&list, 10);
	PushBack(&list, 20);
	PushBack(&list, 30);
	PushBack(&list, 40);
}
```