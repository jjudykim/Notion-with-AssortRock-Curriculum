# 2023/12/01 - 비트연산자, 함수

태그: C++, 입문
날짜: 2023/12/01
상위 항목: Week1 (../../Week1%20b504431a81c04149b2f5d2508cc1502f.md)
주차: 0001_Week1~9

## 비트 연산자 🟥 📒

: **비트 단위**로 연산을 진행하는 연산자 

→ 비트식을 수학 연산처럼 세로식으로 연산한다고 생각하자!

![Untitled](2023%2012%2001%20-%20%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1,%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20f943a797c2ae4fb5a5f5ef01a0b93d7c/Untitled.png)

- `&` (곱) : 비트 단위로 AND 연산 진행, 두 비트가 1일 경우에만 1
- `|` (합) : 비트 단위로 OR 연산 진행, 두 비트 중 하나만 1이어도 1
- `~` (반전) : 모든 비트를 0은 1로, 1은 0으로 반전시킴
- `^` (XOR) : 비트 단위로 비교했을 때 같으면 0, 다르면 1

### 비트 단위 연산자는 어디에 사용될까?

→ 메모리 최적화를 위해서 0, 1의 상태를 저장하는 단위를 bit단위로 설정할 수 있을 것이다

bit는 0과 1을 담을 수 있는 최소 단위니까!

그럼 비트 단위 연산자를 어떻게 적절하게 사용할 수 있을까?

예를 들어, 한 캐릭터의 상태를 저장하려 한다고 생각해보자

→ BLEED, SLOW, STURN, SHORK, BURN, ICE … 등의 디버프 상태를 저장

그런데, 각각의 상태를 걸려있음/걸려있지 않음으로 bool 타입으로 저장하기엔
상태의 종류가 많아지면 많아질수록 메모리 누적이 너무 커진다

어차피 우리가 저장해야 하는건 0과 1, 켜짐과 꺼짐이니까 1bit에 저장할 수 있지 않을까?

따라서 우리는 상태를 나타내는 4byte(32bit)짜리의 int 변수를 통해, 32가지의 상태를 저장할 것이다

```cpp
// 상태값을 저장할 변수, status
unsigned int status = 0;        // 0000
```

### **비트 연산자를 활용한 상태 추가 (`|`, 합 활용)**

```cpp
// 비트 연산자를 통해 비트의 첫번째 자리에 1을 넣어보자
status |= 1;                    // 0001

// 비트 연산자를 통해 비트의 두번째 자리에 1을 넣어보자
status |= 2;                    // 0011

// 비트 연산자를 통해 비트의 세번째 자리에 1을 넣어보자
status |= 4;                    // 0111

// 비트 연산자를 통해 비트의 n번째 자리에 1을 넣고싶다면 2의 승수를 합연산 하면 된다
status |= 2^(n-1);
```

- 비트 연산과정 그림으로 한눈에 보기
    
    ![Untitled](2023%2012%2001%20-%20%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1,%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20f943a797c2ae4fb5a5f5ef01a0b93d7c/Untitled%201.png)
    

그런데 이렇게 계속해서 literal 값을 더하면 나중에 변경이나 재사용하기가 어렵다

→ 따라서 `#define` 전처리기를 통해서 간략화해보자

<aside>
📒 전처리기와 `#define`에 대한 내용 참조 → [1.14 전처리기와의 첫 만남](https://www.notion.so/1-14-e64c16ef148743238d8b2c04efdf9651?pvs=21)

</aside>

```cpp
#include <iostream>

#define BLEED   1
#define SLOW    2
#define STURN   4
#define SHORK   8
#define BURN    16
#define ICE     32
// ...
```

→ #define을 통해서 각각의 상태에 대한 비트 값을 대치해놨다

그런데 수가 점점 커질수록 계산이 어려워질테니, 이를 16진수로 작성해보자

```cpp
#include <iostream>

#define BLEED   0x1
#define SLOW    0x2
#define STURN   0x4
#define SHORK   0x8
#define BURN    0x10
#define ICE     0x20
// #define ...  0x40
// #define ...  0x80
// #define ...  0x100
// ...
```

이렇게 전처리기를 통한 작업을 거친 후에는, 

위에서 작성했던 코드를 이렇게 재구성할 수 있다

```cpp
status = 0;

status |= BLEED;         // 0001
status |= SLOW;          // 0011
status |= STURN;         // 0111
// ...
```

또한, 이렇게 기존의 상태들의 조합을 만들 수도 있을 것이다

```cpp
#define CLASS_DEBUF (BLEED | \         
										 SLOW  | \
										 SHORK | \
										 BURN)

// 여기서 역슬래쉬 \은 다음 줄도 이어지는 내용임을 의미한다
```

- 비트 연산과정 그림으로 한눈에 보기
    
    ![Untitled](2023%2012%2001%20-%20%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1,%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20f943a797c2ae4fb5a5f5ef01a0b93d7c/Untitled%202.png)
    

### 비트 연산자를 활용한 상태 확인 (`&`, 곱 활용)

그렇다면 상태 데이터를 넣는 것 뿐만 아니라 저장한 상태 데이터를 확인할 수도 있어야 할 것이다!

```cpp
if (status & BLEED)   // status에서 BLEED의 비트값 1이 유효한지 확인 (0111 & 0001) 
{
	cout << "BLEED 상태를 가지고 있다" << endl;
	hp -= 10;
}

if (status & BURN)  // status에서 BURN의 비트값 16이 유효한지 확인 (00111 & 10000)
{
	cout << "BURN 상태를 가지고 있다" << endl;
	hp -= 1;
}
```

- 비트 연산과정 그림으로 한눈에 보기
    
    ![Untitled](2023%2012%2001%20-%20%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1,%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20f943a797c2ae4fb5a5f5ef01a0b93d7c/Untitled%203.png)
    

### 비트 연산자를 활용한 상태 제거 (`~`, 반전 연산 활용)

이제는 상태를 해제하는 방법도 비트 연산자를 활용해서 적용해보자

```cpp
status &= ~BLEED;  // BLEED 상태 해제
status &= ~SLOW;   // SLOW 상태 해제
```

여기서 `~BLEED`나 `~SLOW`는 기존의 BLEED와 SLOW가 나타내는 상태의 비트는 0으로, 나머지 비트들은 1로 채워졌을 것이다 → 즉, 반전된 상태

이를 status와 *곱 연산*을 시행하면, 기존의 status가 가지고 있던 상태의 비트는 1로, BLEED나 SLOW에 해당되는 비트는 0으로 바뀌며 해당 상태가 해제될 것이다

- 비트 연산과정 그림으로 한눈에 보기
    
    ![Untitled](2023%2012%2001%20-%20%E1%84%87%E1%85%B5%E1%84%90%E1%85%B3%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A1,%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20f943a797c2ae4fb5a5f5ef01a0b93d7c/Untitled%204.png)
    

## 함수 (Function)

: 함수는 특정 기능을 하나의 이름으로 정의한 작업을 의미하며, 모듈화의 일종이라고 할 수 있다! 기능들은 항상 모듈화하는 것이 좋다 (재사용성을 위해)

### 함수의 문법

```cpp
**반환타입** **함수명**(**인자타입** **인자명1**, **인자타입** **인자명2**, ...)
{

}
```

### 함수 작성 예제

**ex1) 더하기 함수 add**

```cpp
// 함수의 선언
int add(int, int);         // 전방 선언 (Linking과 연관)

// 함수의 정의
int add(int a, int b)
{
		return a + b;
}

// 함수의 호출
int a = add(100, 200);    // a에는 300이 할당
```

**예제를 통해 짚고 넘어갈 수 있는 부분**

- 함수의 선언과 정의는 다르다
    
    <aside>
    📒 1. 함수의 선언과 정의에 대한 내용 참조 → [1.10 선언과 정의의 분리](https://www.notion.so/1-10-08a2208af5954c9fb81bfc40d1b1dba3?pvs=21) 
    2. Linking에 대한 내용 간단히 참조 
    → [1.1 프로그램의 구조](https://www.notion.so/1-1-3934a8fac2994bc982a31546e93c8185?pvs=21), [1.12 헤더 가드가 필요한 이유](https://www.notion.so/1-12-984d2d3cc152474a88d38d17cd30babd?pvs=21)
    
    </aside>
    
- 함수의 정의만 독립적으로 해도 됨, 선언은 정의부분이 꼭 있어야 함

**ex2) 제곱 함수 pow**

```cpp
int pow(int, int)

int pow(int num, int exponent)
{
	int result = 1;

	for(int i = 0; i < exponent; i++)
	{
		result *= i;
	}

	return result;
}

int main()
{
		int i = pow(2, 2);
		int j = pow(3, 10);
		int k = pow(i, j);

		return 0;
}
```

## 변수에 대한 심화적인 내용

### 변수의 종류

- 지역 변수 : local scope 안에 존재하는 변수들은 지역 변수라고 한다
- 전역 변수 : 일반적인 전역 변수 / 정적 static 변수 / 외부 extern 변수로 나뉜다

→ 크게는 2가지로 분류, 작게는 4가지라고 할 수 있다

### 메모리 영역

자세히 알아보기 전에, 메모리 공간에 대한 명칭과 어떤 데이터가 저장되는 공간인지 자세히 기억하자

- 스택(Stack) : 함수, 지역변수가 저장되는 공간
- 데이터(Data) : 전역 변수
- 힙(Heap) : 동적 할당
- ROM(Read Only Memory) : 코드 및 초기화 데이터