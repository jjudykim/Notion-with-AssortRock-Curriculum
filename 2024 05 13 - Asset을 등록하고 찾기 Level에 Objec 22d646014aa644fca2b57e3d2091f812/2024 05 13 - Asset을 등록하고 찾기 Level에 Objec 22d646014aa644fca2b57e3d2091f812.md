# 24/05/13 - Assetì„ ë“±ë¡í•˜ê³  ì°¾ê¸° / Levelì— Object ì¶”ê°€í•˜ê¸° / í…œí”Œë¦¿ ë¶€ë¶„ íŠ¹ìˆ˜í™”

íƒœê·¸: C++, DirectX11, ì¤‘ê¸‰
ìƒìœ„ í•­ëª©: Week25 (Week25%2023ffb96540554582bf4402bd1100f405.md)
ì£¼ì°¨: 0011_Week20~29

## Asset Managerë¡œ Asset ê´€ë¦¬í•˜ê¸°

### ì´ì œë¶€í„° Assetì€ Asset Managerì— ì˜í•´ ê´€ë¦¬ë  ê²ƒì´ë‹¤!

Assetë“¤ì„ ìƒì„±í•˜ë©´, ì´ë¥¼ Asset Managerì— ë“±ë¡í•œ í›„ ì°¾ì•„ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ê²ƒì´ë‹¤

**Asset Manager ìƒì„±**

```cpp
#pragma one

class CAsset;

class CAssetMgr
	: public CSingleton<CAssetMgr>
{
	SINGLE(CAssetMgr);
	
private:
	map<wstring, CAsset*> m_mapAsset[(UINT)ASSET_TYPE::END];
	
public:
	void Init();
	
	CAsset* FindAsset(ASSET_TYPE _Type, const wstring& _Key);
	void AddAsset(const wstring& _Key, CAsset* _Asset);
}
```

```cpp
#include "pch.h"
#include "CAssetMgr.h"

#include "assets.h"

CAssetMgr::CAssetMgr()
{

}

CAssetMgr::~CAssetMgr()
{
	// Asset Managerì— ë“±ë¡ëœ, ë³¸ì¸ì´ ê´€ë¦¬í•˜ê³  ìˆëŠ” ì—ì…‹ë“¤ì„ ëª¨ë‘ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•œë‹¤
	for (UINT i = 0; i < (UINT)ASSET_TYPE::END; ++i)
	{
		Delete_Map(m_mapAsset[i]);
	}
}

void CAssetMgr::Init()
{
	// êµ¬í˜„ ì˜ˆì • ...
}

CAsset* FindAsset(ASSET_TYPE _Type, const wstring& _Key)
{
	// êµ¬í˜„ ì˜ˆì • ...
}

void AddAsset(const wstring& _Key, CAsset* _Asset)
{
	// êµ¬í˜„ ì˜ˆì • ...
}
```

- ì—¬ê¸°ì„œ ì†Œë©¸ìì¸ `~CAssetMgr()` ì—ì„œ ë³¸ì¸ì´ ë©¤ë²„ë¡œ ê°–ê³  ìˆëŠ” Assetë“¤ì„, Typeë³„ë¡œ ëª¨ë‘ ì ‘ê·¼í•´ Delete_Map í•¨ìˆ˜ë¡œ í•´ì œí•´ì¤¬ë‹¤
    
    ì´ ê³¼ì •ì„ ìœ„í•´ *func.h* íŒŒì¼ì„ ìƒì„±í•´ ë¯¸ë¦¬ Container ë“¤ì˜ ë©”ëª¨ë¦¬ í•´ì œë¥¼ êµ¬í˜„í•´ì£¼ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤!
    
    ```cpp
    template<typename T, int _Size>
    void Delete_Array(T(&_arr)[_Size])
    {
    	for (int i = 0; i < _Size; ++i)
    	{
    		if (nullptr != _arr[i])
    			delete _arr[i];
    	}
    }
    
    template<typename T>
    void Delete_Vec(vector<T*>& _vec)
    {
    	for(size_t i = 0; i < _vec.size(); ++i)
    	{
    		if _vec[i] != nullptr)
    			delete _vec[i];
    	}
    	_vec.clear();
    }
    
    template<typename T>
    void Delete_Map(vector<T*>& _map)
    {
    	for (const auto& pair : _map)
    	{
    		if ( pair.second != nullptr)
    			delete pair.second;
    	}
    }
    ```
    

ê·¸ë¦¬ê³  AssetMgrì˜ Init í•¨ìˆ˜ì—, Tempì˜ Initì—ì„œ ìƒì„±í–ˆë˜ Rect Meshì˜ ìƒì„± ê³¼ì •ì„ ì˜®ê²¨ì¤€ í›„ í•´ë‹¹ Meshë¥¼ Assetìœ¼ë¡œ ë“±ë¡í•˜ì (AddAsset)

```cpp
void CAssetMgr::Init()
{
	CMesh* pMesh = nullptr;
		
	// Rect Mesh ìƒì„±
	Vtx arrVtx[4] = {};

	arrVtx[0].vPos = Vec3(-0.5f, 0.5f, 0.f);
	arrVtx[0].vColor = Vec4(1.f, 0.f, 0.f, 1.f);

	arrVtx[1].vPos = Vec3(0.5f, 0.5f, 0.f);
	arrVtx[1].vColor = Vec4(0.f, 1.f, 0.f, 1.f);

	arrVtx[2].vPos = Vec3(0.5f, -0.5f, 0.5f);
	arrVtx[2].vColor = Vec4(0.f, 0.f, 1.f, 1.f);

	arrVtx[3].vPos = Vec3(-0.5f, -0.5f, 0.f);
	arrVtx[3].vColor = Vec4(1.f, 0.f, 0.f, 1.f);
	
	// Index ë²„í¼ ìƒì„±
	UINT arrIdx[6] = {};
	arrIdx[0] = 0;	arrIdx[1] = 1;	arrIdx[2] = 2;
	arrIdx[3] = 0; 	arrIdx[4] = 2;	arrIdx[5] = 3;

	// Mesh ìƒì„±
	pMesh = new CMesh;
	pMesh->Create(arrVtx, 4, arrIdx, 6);
	AddAsset(L"RectMesh", pMesh);
	
	// Shader ìƒì„±
	CGraphicShader* pShader = nullptr;
	pShader = new CGraphicShader;
	pShader->CreateVertexShader(L"shader\\test.fx", "VS_Test");
	pShader->CreatePixelShader(L"shader\\test.fx", "PS_Test");
	
	AddAsset(L"TestShader", pShader);
}
```

Assetì— í•´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤ë“¤ì´ ë§ìœ¼ë¯€ë¡œ, í—¤ë” ì°¸ì¡°ë¥¼ ê°„í¸í•˜ê²Œ í•˜ê¸° ìœ„í•´ì„œ

`assets.h` í—¤ë”ë¥¼ í•˜ë‚˜ ë§Œë“¤ê³ , Asset í´ë˜ìŠ¤ë“¤ì— ëŒ€í•œ includeë¥¼ ëª¨ì•„ë†“ì•˜ë‹¤

```cpp
#include "CMesh.h"
#include "CMeshData.h"
#include "CMaterial.h"
#include "CTexture.h"
#include "CSound.h"
#include "CPrefab.h"
#include "CGraphicShader.h"
#include "CComputeShader.h"
```

Engineì—ì„œ ë§¤ë‹ˆì € ì´ˆê¸°í™” ì‹œì ì—ì„œ, AssetMgrë„ Init ê³¼ì •ì„ ìˆ˜í–‰í•´ì£¼ê¸°

```cpp
// ...
#include "CAssetMgr.h"
// ...

CEngine::CEngine()
{
	// ...
}

CEngine::~CEngine()
{
	// ...
}

int CEngine::Init(HWND _wnd, POINT _ptResolution)
{
	// ...
	
	// Manager ì´ˆê¸°í™”
	// ...
	CAssetMgr::GetInst()->Init();
}

```

### AddAsset / FindAssetì„ í†µí•´ ì—ì…‹ì„ ë“±ë¡í•˜ê³  ì°¾ì•„ë³´ì

**ìƒì„±í•œ Assetë¥¼ Asset Managerì— ë“±ë¡í•˜ê¸° â†’ AddAsset()**

```cpp
void AddAsset(const wstring& _strName, CAsset* _Asset);
```

```cpp
void CAssetMgr::AddAsset(const wstring& _strName, CAsset* _Asset)
{
	ASSET_TYPE Type = _Asset->GetAssetType();
	
	// ë™ì¼í•œ Typeê³¼ ì—ì…‹ì´ ì´ë¯¸ ë“±ë¡ë˜ëŠ” ê²½ìš°ì—ëŠ” assert ì²˜ë¦¬ë˜ë„ë¡ (Find í•¨ìˆ˜ê°€ í•„ìš”í•˜ë‹¤!)
	//assert(!FindAsset(Type, _strName));
	
	m_mapAsset[(UINT)Type].insert(make_pair(_strName, _Asset));
}
```

**Asset Managerì—ì„œ ë“±ë¡ëœ Assetì„ ê²€ìƒ‰í•˜ê¸° â†’ FIndAsset()**

```cpp
CAsset* CAssetMgr::FindAsset(ASSET_TYPE _Type, const wstring& _Key)
```

```cpp
CAsset* CAssetMgr::FindAsset(ASSET_TYPE _Type, const wstring& _Key)
{
	map<wstring, CAsset*>::iterator iter = m_mapAsset[(UINT)_Type].find(_Key);
	
	if (iter == m_mapAsset[(UINT)_Type].end())
	{
		return nullptr;
	}
	
	return iter->second;
}
```

AssetMgrì˜ Initì„ í†µí•´ ìƒì„±í•˜ê³  ë“±ë¡í–ˆë˜ Meshì¸ â€œRectMeshâ€ì™€ Graphic Shader â€œTestShaderâ€ë¥¼

**Temp Renderì—ì„œ ì°¾ì•„ ë°”ì¸ë”©**í•´ë³´ì!

```cpp
void TempRender()
{
	CConstBuffer* pTransformCB = CDevice::GetInst()->GetConstBuffer(CB_TYPE::TRANSFORM);
	pTransformCB->Binding();
	
	CMesh* pRectMesh = (CMesh*)CAssetMgr::GetInst()->FindAsset(ASSET_TYPE::MESH, L"RectMesh");
	CGraphicShader* pShader = (CGraphicShader*)CAssetMgr::GetInst()->FindAsset(ASSET_TYPE::GRAPHIC_SHADER, L"TestShader");
	
	pShader->Binding();
	pRectMesh->render();
}
```

### AddAsset, FindAsset í•¨ìˆ˜ë¥¼ í…œí”Œë¦¿ í•¨ìˆ˜ë¡œ ë³€í™˜í•´ë³´ì!

Assetì´ ì• ì´ˆì— ìƒì„±ë  ë•Œë¶€í„°, Typeë³„ë¡œ êµ¬ë¶„ë˜ì–´ ìƒì„±ë˜ê¸° ë•Œë¬¸ì—

Find Asset í•¨ìˆ˜ë¥¼ ì‘ì„±í•  ë•Œì—ëŠ” í•­ìƒ

- Typeë³„ë¡œ í•´ë‹¹ Assetì„ ê²€ìƒ‰í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— â†’ ì¸ìë¡œ Typeì„ ë„£ì–´ì£¼ê³ ,
- ë°˜í™˜íƒ€ì…ì´ ë¶€ëª¨íƒ€ì…ì¸ `CAsset*` ì´ê¸° ë•Œë¬¸ì— â†’ ê²°ê³¼ë¥¼ ë°›ì•„ì˜¬ë•Œë§ˆë‹¤ ìºìŠ¤íŒ… í•´ì¤˜ì•¼ í•œë‹¤

ì´ ê³¼ì •ë“¤ì´ ì¡°ê¸ˆ ë²ˆê±°ë¡­ê¸° ë•Œë¬¸ì—, 

ìì£¼ ì‚¬ìš©í• ë§Œí•œ `FindAsset()` í•¨ìˆ˜ì˜ í¸ë¦¬í•œ ì‚¬ìš©ì„ ìœ„í•´ í…œí”Œë¦¿ìœ¼ë¡œ êµ¬í˜„í•´, ì¡°ê¸ˆ ë” ê°„ëµí•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ë³´ì! + ë¤ìœ¼ë¡œ `AddAsset()` í•¨ìˆ˜ë„.. :3

ë‘ í•¨ìˆ˜ë¥¼ í…œí”Œë¦¿í™”í•˜ëŠ” ë°©ë²•ì€ ë‘ ê°€ì§€ê°€ ìˆë‹¤

1) ì „í˜•ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

2) C++17 ë¶€í„° ì‚¬ìš© ê°€ëŠ¥í•œ `constexpr` í™œìš©í•˜ëŠ” ë°©ë²•

ë¨¼ì € ì „í˜•ì ì¸, ì¼ë°˜ì ì¸ í…œí”Œë¦¿ í•¨ìˆ˜ ì‘ì„± ë°©ë²•ì„ í†µí•´ì„œ ë‘ í•¨ìˆ˜ë¥¼ ì¬êµ¬ì„±í•´ë³´ì!

**ë°©ë²• 1ï¸âƒ£ ì¼ë°˜ì ì¸ ë°©ë²•ìœ¼ë¡œ í…œí”Œë¦¿ í•¨ìˆ˜ ì‘ì„±í•˜ê¸°**

```cpp
class CAsset;

class CAssetMgr
	: public CSingleton(CAssetMgr>
{
	SINGLE(CAssetMgr);
	
private:
	map<wstring, CAsset*> m_mapAsset[(UINT)ASSET_TYPE::END];
	
public:
	template<typename T>
	void AddAsset(const wstring& _Key, T* _Asset);

	template<typename T>
	T* FindAsset(const wstring& _Key);	
};

// í…œí”Œë¦¿ í•¨ìˆ˜ AddAsset êµ¬í˜„
// ...

// í…œí”Œë¦¿ í•¨ìˆ˜ FindAsset êµ¬í˜„
// ...
```

í…œí”Œë¦¿ í•¨ìˆ˜ì˜ êµ¬í˜„ë¶€ë¥¼ ì‘ì„±í•˜ê¸° ì „, 

ìš°ë¦¬ê°€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ë•Œ `T`ë¡œ ë“¤ì–´ì˜¤ëŠ” Assetì˜ Typeì„ ê°€ë ¤ë‚¼ ìˆ˜ ìˆëŠ” í•¨ìˆ˜ê°€ ìˆë‹¤ë©´ í¸ë¦¬í•  ê²ƒì´ë‹¤! ë”°ë¼ì„œ `GetAssetType`ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë³„ë„ë¡œ ì œì‘í•´, í•´ë‹¹ Tì™€ ì¼ì¹˜í•˜ëŠ” Typeì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ë³´ì

ê·¸ë¦¬ê³  ê·¸ ì „ì— ë” ì¤‘ìš”í•œ ì‚¬ì‹¤ í•œ ê°€ì§€!

`type_info`ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ í™œìš©í•´ ê°ì²´ì˜ íƒ€ì…ì— ëŒ€í•œ ì •ë³´ë¥¼ ì œê³µë°›ì„ ìˆ˜ ìˆë‹¤!

<aside>
âœï¸ **type_info í´ë˜ìŠ¤ì— ëŒ€í•´**

`type_info`ëŠ” RTTI(ëŸ°íƒ€ì„ íƒ€ì… ì •ë³´)ë¥¼ í†µí•´ êµ¬í˜„ë˜ëŠ” í´ë˜ìŠ¤ë¡œ, <typeinfo> í—¤ë” íŒŒì¼ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°, ì£¼ë¡œ typeid ì—°ì‚°ìì™€ í•¨ê»˜ ì‚¬ìš©ëœë‹¤.

typeid ì—°ì‚°ìëŠ” ê°ì²´ì˜ íƒ€ì…ì— ëŒ€í•œ type_info ê°ì²´ë¥¼ ë°˜í™˜í•œë‹¤.
í•´ë‹¹ íƒ€ì…ì´ ì¡´ì¬í•˜ëŠ” í´ë˜ìŠ¤ì— ê°€ìƒí•¨ìˆ˜ê°€ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•  ê²½ìš°ì— type_infoê°€ ìƒì„±ëœë‹¤.

</aside>

ë”°ë¼ì„œ ìš°ë¦° ì´ type_infoë¥¼ í™œìš©í•´, `typeid`ì— ì¡´ì¬í•˜ëŠ” hashcodeë¥¼ í†µí•´ `T`ë¡œ ì „ë‹¬ë°›ì€ íƒ€ì…ì˜ hashcodeì™€ ìš°ë¦¬ê°€ ì°¾ìœ¼ë ¤ëŠ” íƒ€ì…ì˜ hashcodeë¥¼ ë¹„êµí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì¼ì¹˜í•˜ëŠ” ASSET_TYPEì„ ë°˜í™˜ë°›ì„ ê²ƒì´ë‹¤!

```cpp
#include <typeinfo>
```

```cpp
#include "assets.h"

template<typename T>
ASSET_TYPE GetAssetType()
{
	// Tì˜ typeid hashcodeì™€ CMeshì˜ hashcodeê°€ ì¼ì¹˜í•˜ë©´ MESH type ë°˜í™˜
	if (typeid(T).hash_code() == typeid(CMesh).hash_code())	
		return ASSET_TYPE::MESH;
	
	// ì£¼ì„ ì²˜ë¦¬í•œ ì´ìœ ëŠ” ì•„ì§ í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—!
	//if (typeid(T).hash_code() == typeid(CMeshData).hash_code())
	//	return ASSET_TYPE::MESH_DATA;
	
	//if (typeid(T).hash_code() == typeid(CMaterial).hash_code())
	//	return ASSET_TYPE::MATERIAL;
	
	//if (typeid(T).hash_code() == typeid(CPrefab).hash_code())
	//	return ASSET_TYPE::PREFAB;
	
	//if (typeid(T).hash_code() == typeid(CTexture).hash_code())
	//	return ASSET_TYPE::TEXTURE;
	
	//if (typeid(T).hash_code() == typeid(CSound).hash_code())
	//	return ASSET_TYPE::SOUND;
	
	if (typeid(T).hash_code() == typeid(CGraphicShader).hash_code())
		return ASSET_TYPE::GRAPHIC_SHADER;
		
	if (typeid(T).hash_code() == typeid(CComputeShader).hash_code())
		return ASSET_TYPE::COMPUTE_SHADER;
}
```

ì´ì œ GetAssetType í•¨ìˆ˜ë¥¼ í™œìš©í•´, 

**Find Assetê³¼ Add Assetì˜ êµ¬í˜„ë¶€ë¥¼ ì‘ì„±**í•´ë³´ì

```cpp
template<typename T>
T* CAssetMgr::FindAsset(const wstring& _Key)
{
	ASSET_TYPE Type = GetAssetType<T>();
	
	map<wstring, CAsset*>::iterator iter = m_mapAsset[(UINT)Type].find(_Key);
	
	if (m_mapAsset[(UINT)Type].end() == iter)
		return nullptr;
	
	return (T*)iter->second;
}
```

```cpp
template<typename T>
T* CAssetMgr::AddAsset(const wstring& _Key, T* _Asset)
{
	ASSET_TYPE Type = GetAssetType<T>();
	
	assert(!FindAsset(Type, _Key));
	
	m_mapAsset[(UINT)Type].insert(make_pair(_Key, _Asset));
}
```

ì´ë ‡ê²Œ ë‘ í•¨ìˆ˜ê°€ í…œí”Œë¦¿ í•¨ìˆ˜ë¡œ ë³€ê²½ë˜ë©´, Temp Renderì—ì„œ ì‚¬ìš©í•˜ëŠ” ë°©ë²• ì—­ì‹œ ë‹¬ë¼ì§„ë‹¤

```cpp
void TempRender()
{
	CMesh* pRectMesh = CAssetMgr::GetInst()->FindAsset<CMesh>(L"RectMesh");
	CGraphicShader* pShader = CAssetMgr::GetInst()->FindAsset<CGraphicShader>(L"TestShader");
}
```

**ë°©ë²• 2ï¸âƒ£  C++17 ë¶€í„° ì‚¬ìš© ê°€ëŠ¥í•œ `constexpr` í™œìš©**

<aside>
âœï¸ **constexprì´ ë­ê¸¸ë˜?**

ìƒìˆ˜ í‘œí˜„ì‹ì„ ì§€ì •í•˜ëŠ” ë° ì‚¬ìš©í•˜ëŠ” í‚¤ì›Œë“œë¡œ, ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°ë  ìˆ˜ ìˆëŠ” ìƒìˆ˜ ê°’ì„ ì§€ì •í•˜ëŠ” ë°ì— ì‚¬ìš©ëœë‹¤! ì¦‰, ì»´íŒŒì¼ íƒ€ì„ì— ìƒìˆ˜ì„ì´ í™•ì‹¤í•´ì•¼ í•  ë•Œ í™œìš©í•˜ëŠ” í‚¤ì›Œë“œ

ë‹¤ìŒê³¼ ê°™ì€ ìš©ë„ì— ì‚¬ìš©ëœë‹¤
- ìƒìˆ˜ í‘œí˜„ì‹ í•¨ìˆ˜ : ì»´íŒŒì¼ íƒ€ì„ì— í‰ê°€ë  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ ì •ì˜
- ìƒìˆ˜ í‘œí˜„ì‹ ë³€ìˆ˜ : ì»´íŒŒì¼ íƒ€ì„ì— ì´ˆê¸°í™”ë˜ëŠ” ë³€ìˆ˜ ì •ì˜
- ìƒìˆ˜ í‘œí˜„ì‹ ìƒì„±ì : ì»´íŒŒì¼ íƒ€ì„ì— ê°ì²´ë¥¼ ì´ˆê¸°í™”í•˜ëŠ” ìƒì„±ì ì •ì˜

C++17 ë¶€í„°ëŠ” `if constexpr`ì´ë¼ëŠ” ì¡°ê±´ë¶€ ì»´íŒŒì¼ì„ í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆëŠ”ë°
â†’ ì´ëŠ” í…œí”Œë¦¿ ë©”íƒ€í”„ë¡œê·¸ë˜ë°ì—ì„œ ë§¤ìš° ìœ ìš©í•´ì¡Œë‹¤!!
- ì»´íŒŒì¼ íƒ€ì„ì— ì¡°ê±´ì„ í‰ê°€í•˜ê³ ,
- í•´ë‹¹ ì¡°ê±´ì˜ ê²°ê³¼ê°€ falseì¸ ê²½ìš° í•´ë‹¹ ë¸”ë¡ì€ ì»´íŒŒì¼ ë˜ì§€ ì•Šê³  ë¶ˆí•„ìš”í•œ ì½”ë“œë¡œ ë°”ì´ë„ˆë¦¬ì—ì„œ ì œê±°í•˜ë©°,
- í…œí”Œë¦¿ì„ ì‚¬ìš©í•  ë•Œ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥¸ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì‹¶ì„ ë–„ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤

</aside>

ë¨¼ì €, ë³€ìˆ˜ í…œí”Œë¦¿ì— ëŒ€í•´ ì•Œì•„ë³´ê³  ì§„í–‰í•˜ì

ìš°ë¦¬ê°€ ì—¬íƒœê¹Œì§€ í•¨ìˆ˜ì˜ í˜•íƒœë¡œ ì‘ì„±í–ˆë˜ í…œí”Œë¦¿ì€, ë³€ìˆ˜ì™€ í´ë˜ìŠ¤ í˜•íƒœë¡œë„ í™œìš©ì´ ê°€ëŠ¥í•˜ë‹¤!

**ë³€ìˆ˜ í…œí”Œë¦¿**

```cpp
template<typename T>
int g_int;                       // g_intëŠ” int íƒ€ì…ì˜ ë³€ìˆ˜ë‹¤

g_int<float>                    // floatì´ ë³¸ì²´ì— ì˜í–¥ì„ ì£¼ì§„ ëª»í•œë‹¤!
																// ë‹¨ìˆœíˆ Tê°€ ì •í•´ì ¸ì•¼ g_intê°€ ì •ì˜ë˜ê¸°ì— ì‘ì„±í•œ ê²ƒì¼ ë¿
```

ê·¸ëŸ¼ ì´ëŸ° ë³€ìˆ˜ í…œí”Œë¦¿ì„ ì™œ ì‚¬ìš©í• ê¹Œ?

í…œí”Œë¦¿ì˜ ë¶€ë¶„ íŠ¹ìˆ˜í™” ê¸°ëŠ¥ì„ í™œìš©í•˜ê¸° ìœ„í•´ì„œ!

<aside>
âœï¸ **í…œí”Œë¦¿ì˜ ë¶€ë¶„ íŠ¹ìˆ˜í™”**

í…œí”Œë¦¿ì˜ ë¶€ë¶„ íŠ¹ìˆ˜í™”ëŠ”, í…œí”Œë¦¿ ì¸ìˆ˜ë¥¼ íŠ¹ì •í•œ íŒ¨í„´ì— ë§ê²Œ ë¶€ë¶„ì ìœ¼ë¡œ íŠ¹ìˆ˜í™”í•˜ëŠ” ë°©ë²•ì„ ë§í•œë‹¤. ì¦‰, í…œí”Œë¦¿ì˜ ì¼ë°˜ë²„ì „ê³¼ íŠ¹ì • ì¸ìˆ˜ì— ëŒ€í•´ì„œ ë³´ë‹¤ êµ¬ì²´ì ì¸ ë™ì‘ì„ ì •ì˜í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤. 

í´ë˜ìŠ¤ í…œí”Œë¦¿ì— ëŒ€í•´ì„œë§Œ ì ìš©ë˜ê³ , íŠ¹ì • íƒ€ì…ì´ë‚˜ ì¡°ê±´ì—ì„œ íŠ¹ë³„í•œ ì²˜ë¦¬ë¥¼ í•´ì•¼í•  ë•Œ ì‚¬ìš©í•œë‹¤

</aside>

**constexprê³¼ ë³€ìˆ˜ í…œí”Œë¦¿ì˜ ì¡°í•©**

```cpp
// T1, T2ì— ì–´ë–¤ ê°’ì´ ë“¤ì–´ê°€ë“  myBoolì€ ì •ì˜ê°€ ë  ìˆ˜ ìˆë‹¤! 
template<typename T1, typename T2>   
constexpr bool myBool = false;              // ë‹¨ T1, T2ê°€ ë‹¤ë¥¸ íƒ€ì…ì´ë¼ë©´ myBoolì€ false
template<typename T1>
constexpr bool myBool<T1, T1> = true;       // T1, T2ê°€ ê°™ì€ íƒ€ì…ì´ë¼ë©´ myBoolì€ true
```

â†’ T1, T2ì— ì–´ë–¤ ê°’ì´ ë“¤ì–´ê°€ë“  myBoolì€ ì •ì˜ê°€ ë  ìˆ˜ ìˆìŒ!

ê·¸ëŸ°ë°, T1ê³¼ T2ë¡œ ê°™ì€ ê°’ì´ ë“¤ì–´ì˜¤ê²Œ ë˜ë©´ myBoolì€ trueë¡œ ì •ì˜, ì•„ë‹ˆë¼ë©´ falseë¡œ ì •ì˜

ê·¸ëŸ¼ ì´ë ‡ê²Œ ì˜ˆì œì™€ ê°™ì´ ì ìš©í•˜ê²Œ ë˜ì—ˆì„ ë•Œì—,

```cpp
bool b = myBool<int, double>;
b = myBool<int, int>;
```

ì´ë•Œ `constexpr`ì€ ì»´íŒŒì¼ íƒ€ì„ì— ìƒìˆ˜ë¡œ ì •ì˜í•´ë²„ë¦¬ê¸° ë•Œë¬¸ì—,

ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì½ê²Œ ëœë‹¤

```cpp
bool b = 0;
b = 1;
```

**ifì™€ constexprì˜ ì¡°í•©**

```cpp
constexpr bool cexprbool = 0;
if constexpr (cexprbool)           // ì¼ë°˜ ë³€ìˆ˜ëŠ” ë“¤ì–´ê°ˆ ìˆ˜ ì—†ë‹¤! constexpr ë³€ìˆ˜ë§Œ ê°€ëŠ¥
{

}
else
{

}
```

â†’ ì»´íŒŒì¼ íƒ€ì„ì— í™•ì •ëœ ê²°ê³¼ë§Œ ì½”ë“œë¥¼ ë‚¨ê²¨ë†“ê³  ì „ë‹¬í•œë‹¤!

ì¡°ê±´ì´ falseì¸ ê²½ìš°ì—ëŠ” í•´ë‹¹ ë¸”ë¡ ìì²´ë¥¼ ì»´íŒŒì¼ í•˜ì§€ ì•Šê³ , ë¶ˆí•„ìš”í•œ ì½”ë“œëŠ” ë°”ì´ë„ˆë¦¬ì—ì„œ ì™„ì „íˆ ì œê±°ëœë‹¤. ë”°ë¼ì„œ ëŸ°íƒ€ì„ ë•Œì—ëŠ” ifë¬¸ì„ í†µí•´ ì¡°ê±´ì„ íŒë³„í•˜ê³  í•´ë‹¹ë˜ëŠ” ê²½ìš°ê°€ ìˆ˜í–‰ì´ ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì»´íŒŒì¼ íƒ€ì„ì— ë‚¨ê²¨ì§„ ê²½ìš°ì˜ ì½”ë“œë§Œ ì‹¤í–‰ì´ ëœë‹¤.

ì¦‰! ì»´íŒŒì¼ íƒ€ì„ ì•ˆì— if/elseë¥¼ ê²°ì •ì§€ì„ ìˆ˜ ìˆì–´ì•¼ í•˜ëŠ” ifë¬¸ì„ ì‘ì„±í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤!

ìš°ë¦¬ì˜ í…œí”Œë¦¿ í•¨ìˆ˜ì˜€ë˜ `GetAssetType()`ì— ì ìš©í•´ë³´ë©´â€¦

```cpp
// ë³€ìˆ˜ í…œí”Œë¦¿
template<typename T1, typename T2>
constexpr bool IsSame = false;
template<typename T1>
constexpr bool IsSame<T1, T1> = true;

// Assetì˜ Typeì„ ê²°ì •ë°›ëŠ” GetAssetType
template<typename T>
ASSET_TYPE GetAssetType()
{
	if constexpr (IsSame<T, CMesh>)
		return ASSET_TYPE::MESH;
		
	if constexpr (IsSame<T, CMeshData>)
		return ASSET_TYPE::MESH_DATA;
	
	if constexpr (IsSame<T, CMaterial>)
		return ASSET_TYPE::MATERIAL;
	
	if constexpr (IsSame<T, CPrefab>)
		return ASSET_TYPE::PREFAB;
	
	if constexpr (IsSame<T, CTexture>)
		return ASSET_TYPE::TEXTURE;
	
	if constexpr (IsSame<T, CSound>)
		return ASSET_TYPE::SOUND;
	
	if constexpr (IsSame<T, CGraphicShader>)
		return ASSET_TYPE::GRAPHIC_SHADER;
	
	if constexpr(IsSame<T, CComputeShader>)
		return ASSET_TYPE::COMPUTE_SHADER;
}
```

íš¨ê³¼ì ì¸ ìµœì í™” ê°€ëŠ¥!

- ì¶”ê°€ë¡œ, ìš°ë¦¬ëŠ” ì§€ê¸ˆ IsSameì´ë¼ëŠ” ë³€ìˆ˜ í…œí”Œë¦¿ì„ í™œìš©í–ˆì§€ë§Œ, C++ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì¡´ì¬í•˜ëŠ” `std::is_same_v` ì„ í™œìš©í•´ì„œ ì“¸ ìˆ˜ ìˆë‹¤
    
    â†’ C++ 17 í‘œì¤€ìœ¼ë¡œ ì ìš©í•´ì•¼ ê²½ê³  ì—†ì´ ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ë‹¤
    
    <aside>
    ğŸ’¡ í”„ë¡œì íŠ¸ > ì†ì„± > C++ 17ë²„ì „ìœ¼ë¡œ ë³€ê²½í•´ì£¼ê¸°
    
    </aside>
    

## Level / Layer / Object ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê¸°

ì´ì œë¶€í„° ê²Œì„ì˜ êµ¬ì¡°ë¥¼ ì„¤ê³„í•˜ê³ , ì˜¤ë¸Œì íŠ¸ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ìœ„í•´

WinAPIì—ì„œ ì§„í–‰í–ˆë˜ ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ Level / Layer / Object / Component â€¦ ë“±ìœ¼ë¡œ ê²Œì„ì„ êµ¬ì„±í•˜ëŠ” ìš”ì†Œë“¤ì„ êµ¬ì¡°í™”í•´ë³´ì

### Level ë° LevelMgr ìƒì„±

í˜„ì¬ Levelì„ ê´€ë¦¬í•  **Level Manager ìƒì„±**

```cpp
#pragma once

class CLevel;

class CLevelMgr :
	pulbic CSingleton<CLevelMgr>
{
	SINGLE(CLevelMgr);
private:
	CLevel*    m_CurLevel;

public:
	void Init();
	void Progress();
	void Render();
};
```

```cpp
#include "pch.h"
#include "CLevelMgr.h"

#include "CLevel.h"

CLevelMgr::CLevelMgr()
	: m_CurLevel(nullptr)
{
}

CLevelMgr::~CLevelMgr()
{
	if (m_CurLevel != nullptr)
		delete m_CurLevel;
}

void CLevelMgr::Init()
{
	m_CurLevel = new CLevel;
}

void CLevelMgr::Progress()
{
	m_CurLevel->Tick();
	m_CurLevel->FinalTick();
}

void CLevelMgr::Render()
{
	m_CurLevel->Render();
}
```

í•„í„°ì— Level ì¶”ê°€!

<aside>
ğŸ“ 05.Level > `CLevel.h`, `CLevel.cpp`

</aside>

```cpp
#define MAX_LAYER 32
```

```cpp
#pragma once
#include "CEntity.h"
class CLayer;

class CLevel :
	public CEntity
{
private:
	CLayer* m_Layer[MAX_LAYER];
	
public:
	void Tick();
	void FinalTick();
	void Render();

public:
	virtual CLevel* Clone() { return new CLevel(*this); }
	CLevel();
	~CLevel();
};
```

- í•œ Level ì•ˆì— ì¡´ì¬í•˜ëŠ” ì˜¤ë¸Œì íŠ¸ë“¤ì„ íƒ€ì…ë³„ë¡œ êµ¬ë¶„í•˜ë˜ Layer ê°œë…ì„, Classë¡œ ë³„ë„ ê´€ë¦¬!

```cpp
#include "pch.h"
#include "CLevel.h"

#include "CLayer.h"

CLevel::CLevel()
	: m_Layer{}
{
	// Layerë“¤ ì„¸íŒ…
	for (int i = 0; i < MAX_LAYER; ++i)
	{
		m_Layer[i] = new CLayer;
	}
}

CLevel::~CLevel()
{
	// Layerë“¤ í•´ì œ
	Delete_Array(m_Layer);
}

void CLevel::Tick()
{
	for (int i = 0; i < MAX_LAYER; ++i)
	{
		m_Layer[i]->Tick();
	}
}

void CLevel::FinalTick()
{
	for (int i = 0; i < MAX_LAYER; ++i)
	{
		m_Layer[i]->FinalTick();
	}
}

void CLevel::Render()
{
	for (int i = 0; i < MAX_LAYER; ++i)
	{
		m_Layer[i]->Render();
	}
}

```

**Objectë“¤ì„ ë‹´ëŠ” Layer í´ë˜ìŠ¤ ì‘ì„±**

```cpp
#pragma once
#include "CEntity.h"

class CGameObject;

class CLayer :
	public CEntity
{
private:
	vector<CGameObject*>     m_Parents;

public:
	void Tick();
	void FinalTick();
	void Render();

public:
	virtual CLayer* Clone(); { return new CLayer(*this); }
};
```

```cpp
#include "pch.h"
#include "CLayer.h"

#include "CGameObject.h"

CLayer::CLayer(int _LayerIdx)
	: m_LayerIdx(_LayerIdx)
{
}

CLayer::~CLayer()
{
	Delete_Vec(m_Parents);
}

void CLayer::Tick()
{
	for (size_t i = 0; i < m_Parents.size(); ++i)
	{
		m_Parents[i]->Tick();
	}
}

void CLayer::FinalTick()
{
	for (size_t i = 0; i < m_Parents.size(); ++i)
	{
		m_Parents[i]->FinalTick();
	}
}

void CLayer::Render()
{
	for (size_t i = 0; i < m_Parents.size(); ++i)
	{
		m_Parents[i]->Render();
	}
}

```

**Layerì— ë‹´ê²¨ìˆëŠ” ì‹¤ì§ˆì ì¸ Object í´ë˜ìŠ¤ ì‘ì„±**

```cpp
#pragma once
#include "CEntity.h"

class CGameObject :
    public CEntity
{
private:

public:
    void Tick();
    void FinalTick();
    void Render();

public:
    virtual CGameObject* Clone() { return new CGameObject(*this); }
    CGameObject();
    ~CGameObject();
};
```

```cpp
#include "pch.h"
#include "CGameObject.h"

CGameObject::CGameObject()
{
}

CGameObject::~CGameObject()
{
}

void CGameObject::Tick()
{
}

void CGameObject::FinalTick()
{
}

void CGameObject::Render()
{
}
```

ê·¸ë¦¬ê³  ìµœì¢…ì ìœ¼ë¡œ Engineì˜ Processì—ì„œ í˜¸ì¶œë˜ëŠ” ê²ƒì€, Level Managerì˜ Progress!

ì´ì— ë”°ë¼ ì—°ì‡„ì ìœ¼ë¡œ Level > Layer > GameObjectì˜ Tick ë° Final Tickì´ í˜¸ì¶œëœë‹¤

```cpp
// ...
#include "CLevelMgr.h"

int CEngine::Init(HWND _wnd, POINT _ptResolution)
{
	// ...
	// Manager ì´ˆê¸°í™”
	// ...
	CLevelMGr::GetInst()->Init();

	// ...
}

void CEngine::Progress()
{
	// ...
	// Manager
	// ...
	CLevelMgr::GetInst()->Progress();

	// Render
	// ...
	CLevelMgr::GetInst()->Render();
}

```