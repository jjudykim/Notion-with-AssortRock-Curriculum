# 2024/07/03 - Asset UIë¥¼ í†µí•´ Assetì˜ ì •ë³´ë¥¼ Inspectorì— ë„ìš°ê¸°, Outliner ì œì‘(1)

íƒœê·¸: C++, DirectX11, ì¤‘ê¸‰
ìƒìœ„ í•­ëª©: Week32 (https://www.notion.so/Week32-ba138587ed0c43049aaeb6a6d6683658?pvs=21)
ìƒíƒœ: ì‘ì„±ì¤‘
ì£¼ì°¨: 0100_Week30~39

> 0êµì‹œ (ë³´ê°•) ë…¹ìŒë³¸ & 1êµì‹œ ë…¹ìŒë³¸
- [https://clovanote.naver.com/s/UxEppA7Kq792vWfMWfLDVbS](https://clovanote.naver.com/s/UxEppA7Kq792vWfMWfLDVbS)

2êµì‹œ ë…¹ìŒë³¸
- [https://clovanote.naver.com/s/YE96yGwPDokY7YHmGNo3PWS](https://clovanote.naver.com/s/YE96yGwPDokY7YHmGNo3PWS)
> 

## ì„ íƒí•œ Assetì˜ ì •ë³´ë¥¼ UIë¥¼ í†µí•´ í™•ì¸í•´ë³´ì

### Assetì˜ ì •ë³´ë¥¼ ë‹´ì•„ ë³´ì—¬ì¤„, Asset UIë¥¼ ì œì‘í•˜ê¸°

ì´ì œë¶€í„° InspectorëŠ” TreeUIì˜ Nodeì— ë‹´ê²¨ìˆëŠ” Assetì˜ ë°ì´í„°(Assetì˜ ì£¼ì†Œê°’)ë¥¼ í™œìš©í•´ì„œ Assetì˜ ì •ë³´ ì—­ì‹œ ë„ìš¸ ìˆ˜ ìˆì–´ì•¼ í•˜ê¸° ë•Œë¬¸ì—, 

ë©¤ë²„ë¡œ Target Obejct ë¿ë§Œ ì•„ë‹ˆë¼, *Target Asset* ì—­ì‹œ ê°–ê³  ìˆì„ ê²ƒì´ë‹¤!

```cpp
class Inspector :
	public EditorUI
{
	// ...
	Ptr<CAsset>        m_TargetAsset;
	class AssetUI*     m_arrAssetUI[(UINT)ASSET_TYPE::END];  
	
	// ...
	void SetTargetAsset(Ptr<CAsset> _Asset);
}
```

```cpp
// ...

void Inspector::SetTargetAsset(Ptr<CAsset> _Asset)
{
	if (_Asset == nullptr)
	 return;
	 
	// Target Objectë¥¼ ìœ„í•œ UIëŠ” ë¹„í™œì„±í™” ìƒíƒœë¡œ ë³€ê²½ë˜ê²Œë”
	SetTargetObject(nullptr);
	
	m_TargetAsset = _Asset;
}
```

- Assetì˜ Typeì— ë”°ë¼ì„œ í•´ë‹¹í•˜ëŠ” Asset UIê°€ í™œìš©ë˜ì–´ì•¼ í•˜ë¯€ë¡œ, Inspectorê°€ í•´ë‹¹ ìì‹ì„ í™œìš©í•  ìˆ˜ ìˆë„ë¡ Typeë³„ë¡œ ë°°ì—´ë¡œ ë‹´ì•„ë†“ì â†’ `m_arrAssetUI`
- InspectorëŠ”, `SetTargetAsset`ì„ í†µí•´ Target Assetì„ ì„¤ì •í•˜ë ¤ í•œë‹¤ë©´, ê°€ì¥ ë¨¼ì € í•´ë‹¹ Assetì´ ìœ íš¨í•œì§€ ë¨¼ì € í™•ì¸í•œ í›„ì— ë³¸ì¸ì˜ ë©¤ë²„ë¡œ í•´ë‹¹ ì—ì…‹ì„ ë“±ë¡ì‹œì¼œë†“ì•„ì•¼ í•œë‹¤

<aside>
ğŸ—’ï¸ [ìˆ˜ì • ì‚¬í•­]

`SetTargetAsset`ì„ í†µí•´ Inspectorê°€ Asset UIë¥¼ ë‹´ë„ë¡ í™œì„±í™”í•˜ëŠ” ë™ì‹œì— Object UIë¥¼ ë¹„í™œì„±í™”í•˜ëŠ” ê¸°ëŠ¥ì„ ê°–ê²Œ ë˜ì—ˆìœ¼ë‹ˆ,

ë°˜ëŒ€ë¡œ `SetTargetObject`ì„ í†µí•´ Inspectorê°€ Object UIë¥¼ ë‹´ë„ë¡ í™œì„±í™”í•˜ë©´ì„œ, Asset UIëŠ” ë¹„í™œì„±í™”í•˜ëŠ” ê¸°ëŠ¥ ì—­ì‹œ ì¶”ê°€í•´ì£¼ì

```cpp
void Inspector::SetTargetObject(CGameObject* _Object)
{
	// ...
	m_TargetAsset = nullptr;
}
```

</aside>

ê·¸ë ‡ë‹¤ë©´ ì´ì œ ê° íƒ€ì…ë³„ Assetì˜ ë‚´ìš©ì„ ë„ìš¸ **Asset UI**ê°€ ì œì‘ë˜ì–´ì•¼ í•  ì‹œì ì´ë‹¤!

ê³µí†µëœ ë¶€ëª¨ ê°œë…ì¸ *Asset UI*ì™€ ë”ë¶ˆì–´, ê·¸ ìì‹ í´ë˜ìŠ¤ë¡œ *ê°ê° Asset Typeë³„ UI í´ë˜ìŠ¤*ë“¤ì„ ì œì‘í•˜ì

<aside>
ğŸ“ [New Class + New Filter]
Editor UI
    - **Asset UI**
        - MeshUI
        - MeshDataUI
        - MaterialUI
        - PrefabUI
        - TextureUI
        - SpriteUI
        - FlipBookUI
        - SoundUI
        - GraphicShaderUI
        - ComputeShaderUI

</aside>

ê°€ì¥ ë¨¼ì €, ë¶€ëª¨ í´ë˜ìŠ¤ì¸ Asset UIì— ëŒ€í•œ ê¸°ë³¸ì ì¸ í‹€ì„ ì‘ì„±í•´ë³´ì

**Asset UI êµ¬í˜„**

```cpp
class AssetUI :
	public EditorUI
{
private:
	Ptr<CAsset>          m_Asset;
	const ASSET_TYPE     m_Type;
	
public:
	void SetAsset(Ptr<CAsset> _Asset);
	Ptr<CAsset> GetAsset() { return m_Asset; }
	
	void Title();               // ì œëª© ì¶œë ¥
	void AssetName();           // ì—ì…‹ ì´ë¦„ ì¶œë ¥
	
public:
	AssetUI(ASSET_TYPE _Type);
	~AssetUI();
};
```

```cpp
AssetUI::AssetUI(ASSET_TYPE _Type)
	: m_Type(_Type)
{
}

AssetUI::~AssetUI()
{
}

void AssetUI::Title()
{
	ImGui::PushID((int)m_Type);
	
	// ìƒ‰ìƒ ì„¤ì •
	UINT BtnColor = IM_COL32(110, 203, 224, 255);
	ImColor TextColor = IM_COL32(0, 0, 0, 255);
	
	ImGui::PushStyleColor(ImGuiCol_Button, BtnColor);
	ImGui::PushStyleColor(ImGuiCol_ButtonHovered, BtnColor);
	ImGui::PushStyleColor(ImGuiCol_ButtonActive, BtnColor);
	ImGui::PushStyleColor(ImGuiCol_Text, TextColor);
	
	// í…ìŠ¤íŠ¸ ì„¤ì •
	ImGui::Button(ToString(m_Type));
	
	ImGui::PopStyleColor(4);
	ImGui::PopID();
}

void AssetUI::AssetName()
{
	Ptr<CAsset> pAsset = GetAsset();

	string Name = string(pAsset->GetKey().begin(), pAsset->GetKey().end());
	
	// ì—ì…‹ ì´ë¦„
	ImGui::Text("Name");
	ImGui::SameLine(100);
	ImGui::InputText("##AssetName", (char*)Name.c_str(), Name.length(), ImGuiInputTextFlags_ReadOnly);
}

void AssetUI::SetAsset(Ptr<CAsset> _Asset)
{
	// ê¸°ì¡´ì— ì§€ì •í•´ë’€ë˜ Assetì€ ë¹„ì›Œì£¼ê¸°
	m_Asset = nullptr;
	
	// [ë¹„í™œì„±í™” ì¡°ê±´]
	// ì¸ìë¡œ ë“¤ì–´ì˜¨ _Assetì´ nullptrì¼ ê²½ìš°
	// ë˜ëŠ”, êµ¬ì²´í™”ëœ í˜„ì¬ Asset UIì˜ íƒ€ì…ê³¼ ì¸ìë¡œ ë“¤ì–´ì˜¨ _Assetì˜ íƒ€ì…ì´ ë‹¤ë¥¸ ê²½ìš°
	if (_Asset == nullptr || m_Type != _ASSET->GetAssetType())
	{
		SetActive(false);
	}
	else
	{
		m_Asset = _Asset;
		SetActive(true);
	}
}
```

ê·¸ë¦¬ê³  ë°©ê¸ˆ ì‘ì„±í•œ ë¶€ëª¨í´ë˜ìŠ¤ Asset UIë¥¼ ìƒì†ë°›ëŠ”, 

ë¬´ìˆ˜íˆ ë§ì€ íƒ€ì…ì˜â€¦ *ê°œë³„ì ì¸ ìì‹ Asset UI í´ë˜ìŠ¤*ë“¤ì„ ì‘ì„±í•´ë³´ì

- **Asset Type ë³„ UI í´ë˜ìŠ¤ì˜ ê¸°ë³¸ì ì¸ í‹€ ì‘ì„±**
    
    1ï¸âƒ£ Mesh UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class MeshUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        MeshUI();
        ~MeshUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "MeshUI.h"
    
    MeshUI::MeshUI()
    	: AssetUI(ASSET_TYPE::MESH)
    {
    }
    
    MeshUI::~MeshUI()
    {
    }
    
    void MeshUI::Update()
    {
    	Title();
    }
    ```
    
    2ï¸âƒ£ MeshData UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class MeshDataUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        MeshDataUI();
        ~MeshDataUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "MeshDataUI.h"
    
    MeshDataUI::MeshDataUI()
    	: AssetUI(ASSET_TYPE::MESH_DATA)
    {
    }
    
    MeshDataUI::~MeshDataUI()
    {
    }
    
    void MeshDataUI::Update()
    {
    	Title();
    }
    ```
    
    3ï¸âƒ£ Material UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class MaterialUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        MaterialUI();
        ~MaterialUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "MaterialUI.h"
    
    MaterialUI::MaterialUI()
    	: AssetUI(ASSET_TYPE::MATERIAL)
    {
    }
    
    MaterialUI::~MaterialUI()
    {
    }
    
    void MaterialUI::Update()
    {
    	Title();
    }
    ```
    
    4ï¸âƒ£ Prefab UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class PrefabUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        PrefabUI();
        ~PrefabUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "PrefabUI.h"
    
    MaterialUI::MaterialUI()
    	: AssetUI(ASSET_TYPE::PREFAB)
    {
    }
    
    MaterialUI::~MaterialUI()
    {
    }
    
    void MaterialUI::Update()
    {
    	Title();
    }
    ```
    
    5ï¸âƒ£ Texture UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class TextureUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        TextureUI();
        ~TextureUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "TextureUI.h"
    
    TextureUI::TextureUI()
    	: AssetUI(ASSET_TYPE::TEXTURE)
    {
    }
    
    TextureUI::~TextureUI()
    {
    }
    
    void TextureUI::Update()
    {
    	Title();
    }
    ```
    
    6ï¸âƒ£ Sprite UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class SpriteUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        SpriteUI();
        ~SpriteUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "SpriteUI.h"
    
    SpriteUI::SpriteUI()
    	: AssetUI(ASSET_TYPE::SPRITE)
    {
    }
    
    SpriteUI::~SpriteUI()
    {
    }
    
    void SpriteUI::Update()
    {
    	Title();
    }
    ```
    
    7ï¸âƒ£ FlipBook UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class FlipBookUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        FlipBookUI();
        ~FlipBookUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "FlipBookUI.h"
    
    FlipBookUI::FlipBookUI()
    	: AssetUI(ASSET_TYPE::FLIPBOOK)
    {
    }
    
    FlipBookUI::~FlipBookUI()
    {
    }
    
    void FlipBookUI::Update()
    {
    	Title();
    }
    ```
    
    8ï¸âƒ£ Sound UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class SoundUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        SoundUI();
        ~SoundUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "SoundUI.h"
    
    SoundUI::SoundUI()
    	: AssetUI(ASSET_TYPE::SOUND)
    {
    }
    
    SoundUI::~SoundUI()
    {
    }
    
    void SoundUI::Update()
    {
    	Title();
    }
    ```
    
    9ï¸âƒ£ GraphicShader UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class GraphicShaderUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        GraphicShaderUI();
        ~GraphicShaderUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "SoundUI.h"
    
    GraphicShaderUI::GraphicShaderU()
    	: AssetUI(ASSET_TYPE::GRAPHIC_SHADER)
    {
    }
    
    GraphicShaderUI::~GraphicShaderUI()
    {
    }
    
    void GraphicShaderUI::Update()
    {
    	Title();
    }
    ```
    
    ğŸ”Ÿ ComputeShader UI
    
    ```cpp
    #pragma once
    #include "AssetUI.h"
    
    class ComputeShaderUI :
        public AssetUI
    {
    public:
        virtual void Update() override;
    
    public:
        ComputeShaderUI();
        ~ComputeShaderUI();
    };
    ```
    
    ```cpp
    #include "pch.h"
    #include "SoundUI.h"
    
    ComputeShaderUI::ComputeShaderUI()
    	: AssetUI(ASSET_TYPE::COMPUTE_SHADER)
    {
    }
    
    ComputeShaderUI::~ComputeShaderUI()
    {
    }
    
    void ComputeShaderUI::Update()
    {
    	Title();
    }
    ```
    

<aside>
ğŸ—’ï¸ [ìˆ˜ì • ì‚¬í•­]

Inspectorì˜ ìƒì„±ìì—ì„œ Inspectorì˜ ìì‹ìœ¼ë¡œ ë“¤ì–´ê°ˆ ì—¬ëŸ¬ UIë“¤ì„ ìƒì„±í•˜ê³  ì´ˆê¸° ì„¸íŒ…ì„ í•´ì£¼ë˜ ì‘ì—…ë“¤ì— ëŒ€í•œ ë‚´ìš©ì´ ë„ˆë¬´ ê¸¸ì–´ì§€ë‹ˆâ€¦

â†’ ì´ë¥¼ ìƒì„±ìê°€ ì•„ë‹Œ, `Init()` í•¨ìˆ˜ë¥¼ ìƒˆë¡­ê²Œ ì‘ì„±í•´ ê°ê°ì˜ UIë¥¼ Createí•˜ëŠ” í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œí•˜ê²Œë” í•˜ê³ , Init ê³¼ì • ìì²´ë¥¼ í•¨ê»˜ ë³„ë„ì˜ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ì

```cpp
class Inspector
 : public EditorUI
{
	// ...
private:
	void CreateComponentUI();
	void CreateAssetUI();
	
public:
	virtual void Init() override;
	// ...
}
```

```cpp
Inspector::Inspector()
	: m_TargetObject(nullptr)
	, m_arrComUI{}
	, m_arrAssetUI{}
{
}
```

â†’ ë” ì´ìƒ ìƒì„±ìì—ì„œ UIë¥¼ ìƒì„±í•˜ì§€ ì•Šê³ , `Inspector_Init.cpp` íŒŒì¼ì„ í†µí•´ Init ë° ê°ê° UIë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì¤€ë‹¤

```cpp
void Inspector::Init()
{
	CreateComponentUI();
	CreateAssetUI();
	
	if (m_TargetObject == nullptr)
	{
		SetTargetObject(CLevelMgr::GetInst()->FindObjectByName(L"Player"));
		//SetTargetObject(CLevelMgr::GetInst()->FindObjectByName(L"MainCamera"));
		//SetTargetObject(CLevelMgr::GetInst()->FindObjectByName(L"PointLight 1"));
		return;
	}
}
```

```cpp
// Include Component UI 
#include "TransformUI.h"
#include "Collider2DUI.h"
#include "Light2DUI.h"
#include "CameraUI.h"
#include "MeshRenderUI.h"
#include "FlipBookComUI.h"
#include "TileMapUI.h"
#include "ParticleSystemUI.h"
// ...

void Inspector::CreateComponentUI()
{
}
```

```cpp
// Include Asset UI
#include "MeshUI.h"
#include "MeshDataUI.h"
#include "MaterialUI.h"
#include "Prefab.h"
#include "TextureUI.h"
#include "SpriteUI.h"
#include "FlipBookUI.h"
#include "SoundUI.h"
#include "GraphicShaderUI.h"
#include "ComputeShaderUI.h"

// ...

void Inspector::CreateAssetUI()
{
	AssetUI* UI = nullptr;
	
	UI = new MeshUI;
	UI->SetName("MeshUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::MESH] = UI;
	
	UI = new MeshDataUI;
	UI->SetName("MeshDataUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::MESH_DATA] = UI;
	
	UI = new MaterialUI;
	UI->SetName("MaterialUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::MATERIAL] = UI;
	
	UI = new PrefabUI;
	UI->SetName("PrefabUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::PREFAB] = UI;
	
	UI = new TextureUI;
	UI->SetName("TextureUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::TEXTURE] = UI;
	
	UI = new SpriteUI;
	UI->SetName("SpriteUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::SPRITE] = UI;
	
	UI = new FlipBookUI;
	UI->SetName("FlipBookUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::FLIPBOOK] = UI;
	
	UI = new SoundUI;
	UI->SetName("SoundUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::SOUND] = UI;
	
	UI = new GraphicShaderUI;
	UI->SetName("GraphicShaderUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::GRAPHIC_SHADER] = UI;
	
	UI = new ComputeShaderUI;
	UI->SetName("ComputeShaderUI");
	AddChild(UI);
	m_arrAssetUI[(UINT)ASSET_TYPE::COMPUTE_SHADER] = UI;
}
```

Init í•¨ìˆ˜ëŠ” Editor Managerì—ì„œ EditorUIë“¤ì„ ìƒì„±í•˜ëŠ” ì‹œì ì—ì„œ í˜¸ì¶œë˜ê²Œë” í•´ì£¼ì

```cpp
void CEditorMgr::CreateEditorUI()
{
	// ...
	// Inspector
	pUI = new Inspector;
	pUI->Init();
	pUI->SetName("Inspector");
	m_mapUI.insert(make_pair(pUI->GetName(), pUI));
}
```

</aside>

ì´ì œ Asset UIì˜ `SetAsset` í•¨ìˆ˜ëŠ” Inspectorì˜ `SetTargetAsset`ì‹œì— í˜¸ì¶œë˜ì–´,

- 1ï¸âƒ£ í˜„ì¬ Target Assetì— í•´ë‹¹í•˜ëŠ” Asset UIì˜ í™œì„±í™”
- 2ï¸âƒ£ Target Object ëª¨ë“œì¼ ê²½ìš° ëª¨ë“  Asset UIì˜ ë¹„í™œì„±í™”

ì— í™œìš©ëœë‹¤

1ï¸âƒ£ Target Asset ì„¤ì • ì‹œ í•´ë‹¹í•˜ëŠ” Asset UIì˜ í™œì„±í™”

```cpp
void Insepctor::SetTargetAsset(Ptr<CAsset> _Asset)
{
	if (_Asset == nullptr)
		return;
		
	SetTargetObject(nullptr);
	
	m_TargetAsset = _Asset;
	
	for(UINT i = 0; i < (UINT)ASSET_TYPE::END; ++i)
	{
		// Target Assetì˜ Typeê³¼ ë™ì¼í•œ Asset UIê°€ í™œì„±í™”ë˜ê²Œë” ë°˜ë³µë¬¸ìœ¼ë¡œ Set Asset
		m_arrAssetUI[i]->SetAsset(m_TargetAsset);
	}
}
```

2ï¸âƒ£ Target Object ì„¤ì • ì‹œ ëª¨ë“  Asset UIì˜ ë¹„í™œì„±í™”

```cpp
void Inspector::SetTargetObject(CGameObject* _Object)
{
	// ...
	m_TargetAsset = nullptr;
	
	for (UINT i = 0; i < (UINT)ASSET_TYPE::END; ++i)
	{
		m_arrAssetUI[i]->SetAsset(nullptr);
	}
}
```

### Asset Typeë³„ë¡œ, ì‹¤ì§ˆì ì¸ Asset UIë¥¼ ì œì‘í•´ ì •ë³´ë¥¼ ë„ì›Œë³´ì

ëŒ€í‘œì ì¸ Asset UIë“¤ì„ êµ¬í˜„í•´ì„œ, Insepctorë¥¼ í†µí•´ í•´ë‹¹ Assetì˜ ì •ë³´ë¥¼ í™•ì¸í•´ë³´ì

**Texture UI**

Texture UIë¥¼ í†µí•´ ë„ìš¸ ì •ë³´ë“¤

- Textureì˜ ì´ë¦„
- í•´ë‹¹ Textureì˜ ì´ë¯¸ì§€
- í•´ìƒë„ ì •ë³´
- Pixel Format (ê½¤ ë§ì€ ë°˜ë³µì‘ì—…ì„ ìš”êµ¬í•´ì„œ ì¼ë‹¨ì€ êµ¬í˜„ Xâ€¦)

```cpp
TextureUI::TextureUI()
	: AssetUI(ASSET_TYPE::TEXTURE)
{
}

TextureUI::~TextureUI()
{
}

void TextureUI::Update()
{
	Title();
	
	Ptr<CAsset> pTexture = (CTexture*)GetAsset().Get();
	
	// ì´ë¯¸ì§€
	ImVec2 uv_min = ImVec2(0.0f, 0.0f);
	ImVec2 uv_max = ImVec2(1.0f, 1.0f);
	
	ImVec4 tint_col = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);           // ì´ë¯¸ì§€ ìƒ‰ìƒ
	ImVec4 border_col = ImVec4(0.7f, 0.7f, 0.7f, 1.0f);         // êµ¬ë¶„ì„  ìƒ‰ìƒ
	ImGui::Image(pTexture->GetSRV().Get(), ImVec2(150, 150), uv_min, uv_max, tint_col, border_col);
	
	// ì´ë¦„
	AssetName();
	
	// í•´ìƒë„
	UINT width = pTexture->Width();
	UINT height = pTexture->Height();
	
	char buff[50] = {};
	
	sprintf_s(buff, "%d", width);
	ImGui::Text("Width");
	ImGui::SameLine(100);
	ImGui::InputText("##TextureWidth", buff, 50, ImGuiInputTextFlags_ReadOnly);
	
	sprintf_s(buff, "%d", height);
	ImGui::Text("Height");
	ImGui::SameLine(100);
	ImGui::InputText("##TextureHeight", buff, 50, ImGuiInputTextFlags_ReadOnly);
}
```

- Textureì— ë‹´ê²¨ìˆëŠ” Shader Resource Viewë¥¼ í†µí•´ ì´ë¯¸ì§€ë¥¼ ë„ìš°ê¸° ë•Œë¬¸ì—, í˜„ì¬ ì§€ì •ëœ Assetì˜ Texture ë‚´ì˜ SRVë¥¼ ë°›ì•„ì™€ í™œìš©í•´ì¤˜ì•¼ í•œë‹¤

**Material UI**

- Materialì˜ ì´ë¦„
- ë³¸ì¸ì´ ì°¸ì¡°í•˜ëŠ” ì‰ì´ë”
- (ì¶”í›„ì— ì¶”ê°€) ì¬ì§ˆì„ í†µí•´ ì „ë‹¬í•˜ëŠ” íŒŒë¼ë¯¸í„°ë“¤

```cpp
MaterialUI::MaterialUI()
	: AssetUI(ASSET_TYPE::MATERIAL)
{
}

MaterialUI::~MaterialUI()
{
}

void MaterialUI::Update()
{
	Title();

	// ì´ë¦„
	AssetName();
	
	Ptr<CMaterial> pMtrl = (CMaterial*)GetAsset().Get();
	
	// ë³¸ì¸ì´ ì°¸ì¡°í•˜ëŠ” ì‰ì´ë”ì˜ ì´ë¦„
	Ptr<CGraphicShader> pShader = pMtrl->GetShader();
	string Name;
	
	// ì‰ì´ë”ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš° *"None"*ìœ¼ë¡œ ì²˜ë¦¬
	if (pShader == nullptr)
		Name = "None";
	else
		Name = string(pShader->GetKey().begin(), pShader->GetKey().end());
	
	ImGui::Text("Shader Name");
	ImGui::SameLine(100);
	ImGui::InputText("##ShaderName", (char*)Name.c_str(), Name.length(), ImGuiInputTextFlags_ReadOnly);
}
```

## Outlinder UIë¥¼ Tree UIë¥¼ ì ìš©í•´ ì œì‘í•´ë³´ì

ìš°ë¦¬ëŠ” Outliner UIë¥¼ í†µí•´ì„œ Levelì— ì¡´ì¬í•˜ëŠ” Object ëª©ë¡ì„ ë„ì›Œì£¼ê¸¸ ì›í•œë‹¤!

Outliner UIì—ë„ Tree UIë¥¼ ë°˜ì˜í•´, Object ëª©ë¡ì„ ë‚˜ì—´í•´ ë„ì›Œë³´ì

â†’ ì´ë•Œ Objectë“¤ì€ ì„œë¡œ ê³„ì¸µ êµ¬ì¡°ë¥¼ ì´ë£¨ê³  ìˆìœ¼ë‹ˆ, Parent / Child Nodeë¥¼ ì„¤ì •í•˜ëŠ” ê³¼ì •ì— ìœ ì˜í•˜ê¸°!

**Tree UIë¥¼ í™œìš©í•˜ëŠ” Outliner UIì˜ ì‘ì„±**

```cpp
class Outliner :
	public EditorUI
{
private:
	class TreeUI* m_Tree;
	
public:
	virtual void Update() override;
	
private:
	void RenewLevel();                           // ë‚˜ì—´í•  Level ë‚´ì˜ ì •ë³´ë“¤ì„ ê°±ì‹ 
	void GameObjectClicked(DWORD_PTR _Param);    // í´ë¦­ëœ ë…¸ë“œì— ëŒ€í•œ Delegate í•¨ìˆ˜
	void AddGameObject(class TreeNode* pNode, class CGameObject* _Object);
	// Objectì— ëŒ€í•œ ë…¸ë“œë¥¼ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜ (ì¸ìëŠ” ë¶€ëª¨ê°€ ë  Node, ìì‹ìœ¼ë¡œ ì¶”ê°€í•  Object)

public:
	Outliner();
	~Outliner();
};
```

```cpp
Outliner::Outliner()
{
	m_Tree = new TreeUI;
	m_Tree->SetName("OutlinerTree");
	AddChild(m_Tree);
	
	// ...
	// íŠ¸ë¦¬ ì˜µì…˜ ì„¸íŒ…
	m_Tree->ShowRoot(false);     // Root ë³´ì´ì§€ ì•Šê²Œ ì„¤ì •
	m_Tree->AddClickedDelegate(this, (DELEGATE_1)&Outliner::GameObjectClicked);
	
	// Levelì˜ ìƒíƒœë¥¼ Outlinerì˜ TreeUIì— ë°˜ì˜
	RenewLevel();
}

Outliner::~Outliner()
{
}

void Outliener::Update()
{
}
```

â†’ ê¸°ë³¸ì ì¸ í‹€ì€ ì´ ì •ë„ê°€ ë˜ê² ê³ , í•„ìš”í•œ í•¨ìˆ˜ë“¤ì„ êµ¬í˜„í•´ë³´ë©´ì„œ í•˜ë‚˜ì”© ìì„¸íˆ ëœ¯ì–´ë³´ì!

**Levelì— ë‹´ê¸´ Objectë“¤ì— ëŒ€í•œ ì •ë³´ë¥¼ ê°±ì‹ í•˜ê¸° ìœ„í•œ RenewLevel()**

```cpp
void Outliner::RenewLevel()
{
	// ëª¨ë“  ë‚´ìš© ì‚­ì œ
	m_Tree->Clear();              // ğŸ—’ï¸[ìˆ˜ì • ì‚¬í•­] ì°¸ê³ 

	// Root Node ìƒì„±
	TreeNode* pRoot = m_Tree->AddNode(nullptr, "Root", 0);	

	CLevel* pLevel = CLevelMgr::GetInst()->GetCurrentLevel();
	if (pLevel == nullptr) 
		return;
	
	for (UINT i = 0; i < MAX_LAYER; ++i)
	{
		CLayer* pLayer = pLevel->GetLayer(i);
		const vector<CGameObject>& vecObjects = pLayer->GetParentObjects();   // ë¶€ëª¨ë§Œ!
		
		for(size_t i = 0; i < vecObjects.size(); ++i)
		{		
			// ë§Œì•½, í•´ë‹¹ ë…¸ë“œê°€ ìì‹ì„ ê°–ê³  ìˆë‹¤ë©´? ê·¸ ìì‹ ë…¸ë“œë„ ìì‹ì„ ê°–ê³  ìˆë‹¤ë©´?
			// -> ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•  í•„ìš”ì„±ì´ ìˆìœ¼ë¯€ë¡œ, AddGameObject ë‚´ì—ì„œ êµ¬í˜„!
			AddGameOjbect(pRootNode, vecObejcts[i] );
		}
	}
}
```

<aside>
ğŸ—’ï¸ [ìˆ˜ì • ì‚¬í•­ 1]

Content UIì˜ RenewContent, Outliner UIì˜ RenewLevelì—ì„œ ê¸°ì¡´ì— ì¡´ì¬í•˜ëŠ” Treeì˜ ë‚´ìš©ì„ ì •ë¦¬í•´ì£¼ëŠ” Clear ê¸°ëŠ¥ì„ ì¶”ê°€í•´, *ë°ì´í„° ê°±ì‹ ì˜ ì—­í• *ì´ ì›í™œíˆ ì´ë£¨ì–´ì§€ë„ë¡ í•˜ì!

â†’ ì´ˆê¸°í™”í•˜ì§€ ì•Šê³  ê³„ì†í•´ì„œ Renewí•œë‹¤ë©´ ê°±ì‹ ì´ ì•„ë‹ˆë¼ ëˆ„ì ì´ ë˜ë‹ˆê¹Œ

**TreeUIì˜ Clear í•¨ìˆ˜**

```cpp
class TreeUI :
	public EditorUI
{
public:
	// ...
	void Clear();
}
```

```cpp
// ...

TreeUI::~TreeUI()
{
	Clear();
}

void TreeUI::Clear()
{
	if (m_Root != nullptr)
	{
		delete m_Root;
		m_Root = nullptr;
	}
}
```

ì´ë¥¼ Content UI, Outliner UIì˜ Renew í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ê°€ì¥ ë¨¼ì € ì‹¤í–‰í•´ì£¼ë©´ì„œ, ê¸°ì¡´ì— ì¡´ì¬í–ˆë˜ ì •ë³´ë“¤ì„ ì •ë¦¬í•´ì¤€ í›„ì— ìƒˆë¡­ê²Œ ê°±ì‹ ë˜ë„ë¡ í•´ì•¼ í•œë‹¤

```cpp
void Content::RenewContent()
{
	// íŠ¸ë¦¬ì˜ ë‚´ìš©ì„ ì „ë¶€ ì œê±°
	m_Tree->Clear();
	
	// ...
}
```

```cpp
void Outliner::RenewLevel()
{
	// ëª¨ë“  ë‚´ìš© ì‚­ì œ
	m_Tree->Clear();
	
	// ...
}
```

</aside>

**Objectì— ëŒ€í•œ ë‚´ìš©ì„ ê°–ê³  ìˆëŠ” Nodeë¥¼ ìƒì„±í•˜ê³  ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜, AddGameObject**

```cpp
void Outliner::AddGameObject(TreeNode* pNode, CGameObject* _Object)
{
	string ObjectName = string(_Object->GetName().begin(), _Object->GetName().end());
	TreeNode* pObjectNode = m_Tree->AddNode(pNode, ObjectName.c_str(), (DWORD_PTR)_Object);
	
	const vector<CGameObject*>& vecChild = _Object->GetChildren();
	
	// ì¬ê·€ì  í˜¸ì¶œ! 
	// í•´ë‹¹ ì˜¤ë¸Œì íŠ¸ê°€ ìì‹ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°–ê³  ìˆë‹¤ë©´, ê·¸ë§Œí¼ ìì‹ Object Nodeê°€ ì¶”ê°€ë˜ê¸°ë” êµ¬í˜„
	for(size_t i = 0; i < vecChild.size(); ++i)
	{
		AddGameObject(pObjectNode, vecObjects[i]);
	}
}
```

**í´ë¦­ëœ Object, ì¦‰ Nodeë¥¼ í†µí•´ ì´ë£¨ì–´ì ¸ì•¼ í•˜ëŠ” ì‘ì—…ì˜ Delegate í•¨ìˆ˜ GameObjectClicked**

```cpp
void Outliner::GameObjectClicked(DWORD_PTR _Param)
{
	TreeNode* pNode = (TreeNode*)_Param;
	CGameObject* pObject = (CGameObject*)pNode->GetData();
	
	Inspector* pInspector = (Inspector*)CEditorMgr::GetInst()->FindEditorUI("Inspector");
	pInsepctor->SetTargetObject(pObject);
	
	// Focus í•´ì œ
	ImGui::SetWindowsFocus(nullptr);
}
```

â†’ ì„ íƒí•œ ë…¸ë“œì— ë°ì´í„°ë¡œ ì €ì¥ë˜ì–´ìˆë˜ Object ì£¼ì†Œê°’ì„ í†µí•´, Inspectorì˜ Target Objectë¥¼ í•´ë‹¹ Objectë¡œ ì„¤ì •

<aside>
ğŸ—’ï¸ [ìˆ˜ì • ì‚¬í•­]

ê¸°ì¡´ì— Frameì˜ Toggle ì—¬ë¶€ì— ìƒê´€ì—†ì´, ì¤„ì„ ë§ì¶”ê¸° ìœ„í•´ì„œ ë“¤ì—¬ì“°ê¸°ë¥¼ ì ìš©í–ˆë˜ ë¶€ë¶„ì„ Frameì„ ì„¤ì •í–ˆì„ ë•Œì—ë§Œ ì ìš©ë˜ê²Œë” ë³€ê²½í•´ì£¼ì!
â†’ Frame ì„¤ì •ì´ ì•„ë‹Œ ê²½ìš°ì—” ìë™ìœ¼ë¡œ Toggle ë§Œí¼ ë“¤ì—¬ì“°ê¸°ê°€ ì„¤ì •ë˜ê¸° ë•Œë¬¸ì´ë‹¤

```cpp
void TreeNode::Update()
{
	// ...
	if (m_vecChildNode.empty()
	{
		Flag |= ImGuiTreeNodeFlags_Leaf;
		
		if(m_Frame)
			sprintf_s(Name, 255, "   %s##%d", m_Name.c_str(), m_ID);
		else
			sprintf_s(Name, 255, "%s##%d", m_Name.c_str(), m_ID);
	}
	else
		sprintf_s(Name, 255, "%s##%d", m_Name.c_str(), m_ID);
		
	// ...
}
```

</aside>