# 2024/01/15 - 다형성과 가상함수

태그: C++, 중급
날짜: 2024/01/15
상위 항목: Week8 (Week8%2097066e5626ef4fb4ac1b17db8d09a64b.md)
주차: 0001_Week1~9

**객체지향 언어의 5가지 특징**

1. 은닉성
2. 캡슐화
3. 상속
4. 다형성
5. 추상화

### 다형성이란?

다형성은 무엇일까?

: 하나의 타입으로 여러 형태를 나타날 수 있는 성질이자,

함수의 기능적인 다형성과 상속에 의해 만들어진 계층 관계를 활용하는 기술

→  상위 클래스의 포인터나 참조자로 하위 클래스의 기능과 자료를 사용할 수 있다 

C++스타일의 다형성은 *상속 + 포인터*를 활용

```cpp
#pragma once
#include <iostream>

class Parent
{
public:
	int m_parent;

	Parent()
		: m_parent(100)
	{}

	~Parent()
	{}

public:
	void OutputMyData()
	{
		cout << "Parent" << endl;
		cout << "m_Parent : " << m_parent << endl;
	}
};
```

```cpp
#pragma once
#include <iostream>

class Child
	: public Parent
{
public:
	int m_child; 

	Child()
		: m_child(50)
	{}

	~Child()
	{}

public:
	void OutputMyData()
	{
		cout << "Child" << endl;
		cout << "m_Parent : " << m_parent << endl;
		cout << "m_child : " << m_child << endl;
	}
};
```

```cpp
#include "Parent.h"
#include "Child.h"

using namespace std;

int main()
{
	Parent p;
	Child c;

	Parent* pP = &p;
	p.OutputMyData();             // 둘은 동일한 표현, Parent 클래스의 해당 함수 실행
	pP->OutputMyData();
	cout << endl;

	Child* pC; = &c;              // 둘은 동일한 표현, Child 클래스의 해당 함수 실행
	c.OutputMyData();
	pC->OutputMyData();
	cout << endl;

	pP = &c;                      // Parent 포인터 pP가 Child 객체인 c를 가리키게 함
																// 업 캐스팅(up-casting)
	pP->OutputMyData();           // ❓ 어떤 결과가 도출될까 ❓
}
```

---

```
Parent
m_Parent : 100
Parent
m_Parent : 100

Child
m_Parent : 100
m_child : 50
Child
m_Parent : 100
m_child : 50

Parent
m_Parent : 100
```

- Child의 객체인 `c`의 주소를 담은, Parent 포인터 `pP`를 통해 `OutputMyData()`를 실행하자 Parent 클래스, 즉 부모클래스의 함수가 실행되었다!
    
    → 자식 클래스에서 `OutputMyData()`를 오버라이딩했지만, 포인터의 타입 자체가 부모 클래스의 타입이기 때문에 부모 클래스에서 구현된 부분밖에 접근하지 못한다
    

이를 통해 알 수 있는 점을 정리하자면…

<aside>
⭐ 부모 클래스 타입 포인터로 자식 클래스 객체의 주소를 담을 수 있다

</aside>

→ *업 캐스팅(up-casting)*

```cpp
Parent* pP = &c1;
```

![Untitled](2024%2001%2015%20-%20%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20acf7775af2ea40f28dfaeb5b7e315c9d/Untitled.png)

단, *포인터를 이용해서 원본에 접근할 경우, 부모클래스 영역까지 밖에 접근할 수 없다*

pP는 Parent를 가리키는 포인터이므로, Child 객체의 Parent에 해당하는 부분에 대한 정보밖에 없기 때문에.

→ 이것이 다형성에서 발생하게 되는 문제점!

## 다형성의 문제와 가상함수

부모 클래스 포인터 변수(`Parent* pP`) 로, 자식 클래스 객체의 주소를 받았을 때 (`= &c1`) 포인터가 부모 클래스타입이기 때문에, 부모 클래스의 기능까지밖에 접근할 수 없다

→ 해결방안은?

> ***가상함수***를 통해서 자식 클래스에서 오버라이딩한 함수를 호출할 수 있게 한다
> 

### 가상함수

`virtual` 키워드 활용

→ 가상함수로 선언하게 되는 키워드

: 일반적인 멤버함수와 동작방식이 달라지게 된다

**가상함수를 왜 쓰는지?**

해당 클래스에 가상함수가 1개라도 있으면, 각 클래스는 **타입 정보**(RTTI : Runtime Type Information, type_info 객체)가 만들어진다

<aside>
⭐ 타입 정보에 대한 추가적인 내용 참조 → [링크](https://dataonair.or.kr/db-tech-reference/d-lounge/technical-data/?mod=document&uid=235810)

각 클래스에 대해서 타입 정보 객체 단 하나만 정의된다. 즉, 타입 정보 객체는 싱글톤(Singleton)이라고 할 수 있다. 따라서 같은 클래스의 수많은 객체들은 클래스 타입 정보를 가진 싱글톤을 가리키는 포인터(타입정보를 가리키는 포인터)를 가지고 있고, 해당 포인터를 통해서 타입 정보를 공유할 수 있다. 그럼 타입 정보 객체를 가리키는 포인터는 어디 있는 것일까 바로 가상 함수 테이블에 포함되어 있다.

</aside>

클래스에 가상함수가 선언될 경우 클래스 메모리 시작 위치에는 `_vfptr*`이라는 **가상 함수 테이블 포인터**가 생성된다

→ 말 그대로 *가상 함수 테이블을 가리키는 역할*을 하며, 테이블에는 클래스에서 선언된 가상함수의 주소들이 적혀 있고 그 주소를 따라가면 실제 함수 본체 코드 영역에 도달할 수 있다

```cpp
// Parent의 메모리 구조
+-----------------------+          +-----------------------+
| Pointer to VTable ----|--------> | Parent VTable         |
+-----------------------+          +-----------------------+
| Pointer to RTTI   ----|--------> | type_info (Parent)    |
+-----------------------+          +-----------------------+
| m_parent              |          | &Parent::OutputMyData |
+-----------------------+          +-----------------------+

// Child의 메모리 구조
+-----------------------+          +-----------------------+
| Pointer to VTable ----|--------> | Child VTable          |
+-----------------------+          +-----------------------+
| Pointer to RTTI   ----|--------> | type_info (Child)     |
+-----------------------+          +-----------------------+
| m_parent              |          | m_child               |
| m_child               |          +-----------------------+
+-----------------------+
```

- 가상함수 테이블에서 호출하려는 함수를 마치 배열처럼 인덱싱으로 접근한다
- 가상함수를 호출할 경우, 부모 클래스의 멤버인 가상함수 테이블 포인터를 이용해서 가상함수 테이블로 접근한다 
→ 기본적으로 가상함수 테이블은 클래스 당 하나가 생성되고, 해당 클래스의 모든 하위 클래스들이 이를 공유한다!
- 가상함수가 재정의되면, 자식 클래스에 새로운 가상함수 테이블이 생성된다
    
    → 재정의된 함수의 주소가 자식 클래스의 가상함수 테이블에 저장되며, 나머지는 부모 클래스의 가상함수 테이블을 공유한다!
    
- 이를 통해 다형성을 유지하면서도 메모리를 효율적으로 사용할 수 있다

<aside>
⭐ **가상함수의 호출 로직**

가상함수 호출 → 가상함수 테이블 포인터에 접근 → 해당 포인터가 가리키는 테이블 안에 적혀있는 해당 함수 호출

</aside>

> → 이 말은 즉슨.. 
현재 선언한 포인터 타입이 부모클래스이더라도, 실질적인 객체가 자식이므로 자식의 가상함수 테이블을 통해 함수에 접근하기 때문에 오버라이딩의 문제가 발생하지 않고 원하는대로 자식 클래스에서 오버라이딩한 함수를 실행할 수 있다. 즉, 문제없이 ***다형성의 의의를 실현***할 수 있기 때문에!
> 

*복습용으로 참조하기*

<aside>
📒 [12.1 다형성의 기본 개념](https://www.notion.so/12-1-25a74671c4e14eb6a4f7efaea99e048e?pvs=21) 
[12.2 가상 함수와 다형성](https://www.notion.so/12-2-8b8e82a376374821ba4ad6f391ce1751?pvs=21) 
[12.6 가상(함수)표](https://www.notion.so/12-6-98c118f82160443b877f0b415346c919?pvs=21)

</aside>