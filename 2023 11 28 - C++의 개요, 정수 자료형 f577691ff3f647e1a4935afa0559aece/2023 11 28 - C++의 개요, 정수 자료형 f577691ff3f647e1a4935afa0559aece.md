# 2023/11/28 - C++의 개요, 정수 자료형

태그: C++, CS, 입문
날짜: 2023/11/28
상위 항목: Week1 (../../Week1%20b504431a81c04149b2f5d2508cc1502f.md)
주차: 0001_Week1~9

### 플랫폼이란?

플랫폼은 Computer Science에서 ***프로그램이 실행되는 환경***을 의미

넓게는 Windows, MacOs와 같은 운영체제(OS)부터 시작해서,

조금 더 미시적으로 보면 게임을 실행하게끔 유통하는 프로그램인 steam, origin, UBsoft … 같은 프로그램들도 플랫폼이라고 할 수 있음!

VS에서, 솔루션 플랫폼은 x64, x86(32bit버전) 운영체제에 맞게 반영되는데,

이때 바이너리코드가 달라질 수 있으며, 포인터 변수의 크기 등도 타겟 플랫폼에 따라 달라질 수 있음

즉, 만들려는 프로그램의 최종 실행 환경이 어딘지 설정한 후에 솔루션 플랫폼을 지정!

### C++의 개요

C++은 c언어에서 조금 더 객체지향적으로 보완된 언어로,

고수준 언어임에도 불구하고 ***낮은 레벨의 메모리 액세스가 가능***하다는 장점이 있음

→ 참조, 포인터로 접근 가능

<aside>
📒 **고수준언어 vs 저수준언어와 C++**

고수준언어로 인간이 사용하는 언어에, 저수준언어로 갈 수록 기계어에 가까운 언어

고수준언어가 당연히 더 사용하기에는 편하겠지만..

사용하기 쉬운 언어는 생산성이 좋지만, 모든 것들을 깊게 제어하기는 어려워짐

다만 게임성은 생산성보다는 퀄리티와 최적화에 집중되는 분야이므로..

더 디테일하게 제어할 수 있는 C++ 언어를 사용하는 것!

</aside>

C++의 가장 핵심적인 기능은 ***객체지향(OOP)***이라고 할 수 있음!

→ 상속, 다형성, 추상화, 은닉성(캡슐화)…

### 자료형과 bit, byte

**C++에서 사용하는 자료형(Data Type)**

> 괄호 안의 크기의 단위는 byte이며,
1byte == 8bit
> 

**정수 타입**

- char(1)
- short(2)
- wchar_t(2)
- int(4)
- long(4)
- long long(8)
- __int64(8)

…

**실수 타입**

- float(4)
- double(8)

…

**바이트(byte)와 비트(bit)에 대해 더 얘기해보자**

1byte는 8bit와 같고, 표현할 수 있는 종류는 2의 8승으로, 256가지

1bit는 전기신호가 들어올 만큼의 전압이 높음/낮음의 두 상태를 담을 수 있는 하나의 저장 공간

→ 즉, 0/1 밖에 저장을 못한다는 뜻이며, 

1bit가 늘어날 수록 표현할 수 있는 2진수의 가짓 수는 2의 n승 형태로 증가

### 2의 보수 연산법

서로 대응하는 음수/양수를 2진수로 표현하기 위해서 2의 보수 연산을 사용해보자

방법 1) 주어진 이진수보다 한 자리 높고, 가장 높은 자리가 1이며 나머지가 0인 수에서 주어진 수를 빼서 얻은 수가 2의 보수.

방법 2) 주어진 이진수의 모든 자리의 숫자를 반전(0을 1로, 1을 0으로)시킨 뒤 여기에 1을 더하면 2의 보수를 얻을 수 있다.

예제로 확인해보자면.. (1byte, 8bit 기준)

2 / -2

```cpp
// 2
0000 0010

// 방법 1)
1 0000 0000
- 0000 0010
-----------
  1111 1110

// 방법 2)
1111 1101
+       1
---------
1111 1110

// 즉, 2(0000 0010)에 대응하는 -2는 (1111 1110)
```

13/-13

```cpp
// 13
0000 1101

// 방법 1)
1 0000 0000
- 0000 1101
-----------
  1111 0011

// 방법 2)
1111 0010
+       1
---------
1111 0011

// 즉, 13(0000 1101)에 대응하는 -13은 (1111 0011)
```

![Untitled](2023%2011%2028%20-%20C++%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD,%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%89%E1%85%AE%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%92%E1%85%A7%E1%86%BC%20f577691ff3f647e1a4935afa0559aece/Untitled.png)

→ 그림과 같이 최상위 비트는 부호 비트로, 해당 이진수의 양/음을 결정

### signed와 unsigned

```cpp
#include <iostream>
using namespace std;

int main() {
	// 기본적으로 signed인 형태
	char num = 0;

	// unsigned 자료형, 양의 정수만 표현한다 (0 포함)
	unsigned char plusNum = 0;
}
```

일반적인 char는 signed 형태로, 총 256가지를 표현할 수 있어 (1byte > 8bit 이므로 256가지 표현)

표현 범위는 -128 ~ 0 ~ 127

다만 ***unsigned 키워드***가 붙을 경우 해당 자료형으로 선언된 변수는 오로지 양수만 표현하기 때문에 (부호 판별 비트가 없다고 생각하면 됨)

표현 범위는 0 ~ 255

그렇다면 **overflow**가 일어나는 경우에는 어떻게 될까?

<aside>
📒 overflow란,
두 숫자에 대한 연산이 데이터 유형이 가질 수 있는 최대값을 초과하거나 최소값 이하로 떨어지는 현상

</aside>

1) 일반 char 변수인 num이 최대 표현값인 127인 상태에서 +1을 해버린다면

```cpp
num = 127;
num += 1;

cout << num;
```

→ -128로 출력, 표현 범위를 넘어섰기 때문에 오버플로우 발생

2) unsigned char 변수인 plusNum 127인 상태에서 +1을 해버린다면

```cpp
plusNum = 127;
plusNum += 1;

cout << plusNum;
```

→ 128로 출력, 표현 범위 내이기 때문에 정상적으로 연산

3) unsigned char 변수인 plusNum에 -1을 대입한다면?

```cpp
plusNum = -1;

cout << plusNum;
```

→ 255 출력

즉, (signed) char의 -1과 unsigned char의 255가 비트 표현값이 같음

```cpp
num의 -1을 이진수로 표현하면
1111 1111

plusNum의 255을 이진수로 표현하면
1111 1111 (부호 비트가 없으므로 최대값인 255 표현)
```

char이 아닌 다른 자료형으로 확인해보자

**short**

- 2byte(16bit)의 정수타입
- -32768 ~ 0 ~ 32767까지 표현 가능

**unsigned short**

- 0 ~ 65536까지 표현 가능

**int**

- 4byte(32bit)의 정수타입
- -2,147,483,648 ~ 0 ~ 2,147,483,647까지 표현 가능

**unsigned int**

- 0 ~ 4,294,967,295까지 표현 가능

이를 통해 ***자료형의 중요성***을 알 수 있는데..

→ 자료형에 따라서 같은 데이터도 값을 어떻게 분석, 해석하느냐에 따라 결과가 달라질 수 있음!

메모리 공간의 크기와 데이터의 해석을 어떻게 해야할지 결정하는 주요 단서라고 생각하자