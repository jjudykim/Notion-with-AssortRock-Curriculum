# 2023/12/14 - 주소 연산, 문자, const 포인터

태그: C++, CS, 초급
날짜: 2023/12/14
상위 항목: Week3 (Week3%20711ffc18ad144e32964f512fd8516a2d.md)
주차: 0001_Week1~9

### 주소값과 주소의 연산

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미한다

주소값이 존재하는 최소 단위는 byte! 즉, 주소값이 증가하고, 감소하는 최소 단위도 byte

→ 따라서 주소값의 표현 체계는 정수타입이다

포인터 변수의 크기는 운영체제 플랫폼에 따라 표현 가능한 최대 크기로 지정되는데

그래서 64bit 운영체제는 8byte로, 32bit 운영체제는 4byte로 저장된다고 했었다!

→ 이런 연유로 32bit 운영체제는 4GB 이상의 메모리 주소를 가질 수 없는 문제점도 있었다

(32bit로 표현 가능한 가짓수가 주소값 표현이 4GB를 넘지 못해서)

포인터의 주소 연산은 **포인터의 자료형의 크기**를 따른다

즉, 주소값에 4를 더한다고 해서 절대적으로 주소값 + 4가 아니라,

`int*` 타입이라면 4*4byte → 16만큼 증가되는 것이고,

`char*` 타입이라면 4*1byte → 4만큼 증가되는 것!

void 포인터로 간접 참조를 할 수 없었던 이유와 일맥상통하다

→ 가리키고 있는 주소값의 원형을 해석할 수 없기 때문에 접근 및 주소 이동이 불가능하다

주소 연산은 단순히 주소의 이동뿐만 아니라 접근에도 사용이 되는데,

대표적인 예로 배열의 원소에 index로 접근했던 방식을 생각해보자

```cpp
int iArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int* pInt = iArr;        
cout << *(pInt + 3) << endl;         
// 배열의 이름 = 배열[0] 이므로 +3을 했다면 배열[3]에 접근하는 것과 같다!
```

우리가 사용하는 `[index]`자체가 포인터 연산의 축약문과 같았다

```cpp
*(pInt + 4) = 10;
pInt[4] = 10;

// 이 둘은 동일한 표현!
```

### C++의 문자와 문자 배열

C++에서 문자 전용 자료형은 두 가지가 있다

모든 문자는 정수와 대응한다 → (아스키코드, 유니코드 참조)

```cpp
char ch;             // 1바이트
wchar_t wch;         // 2바이트
```

문자 배열로 나타낼 때,

```cpp
char cName[10] = "Hello";
wchar_t wcName[10] = L"Hello";        // wchar_t는 초기화 할 때 L 붙이기
```

곁따옴표를 이용한 문자열 리터럴로 문자 배열을 초기화 하는 것은 문자 전용 자료형 배열만 가능

### const 키워드와 const 포인터에 대하여

`const` 키워드

: constant의 약자로, 해당 키워드가 붙은 변수는 데이터가 변경되지 못하게끔 만드는 상수화 키워드

→ 단, 진짜 상수 literal(메모리 공간이 할당되지 않는 R-value)과 상수화된 변수는 엄연히 다르다!

**상수화된 포인터, const 포인터에 대해**

1) `const *` 타입

: 포인터의 기능이 const 된 포인터 변수, 즉 포인터의 간접 참조가 상수화된다

주소를 저장하고, 접근(읽기)까지만 가능, 쓰기는 불가능 

→ 해당 포인터를 간접참조 해 원본 변수 수정 불가능

```cpp
int data = 0;
const int* pData = &data;

int* i = pData;      // ❌ 불가능, const * 타입은 const * 타입끼리만 할당 가능
*pData = 100;        // ❌ 불가능, 간접참조해 원본 변수 수정 불가능
int i = *pData       // ⭕ 가능, 간접참조해 데이터를 읽어 복사는 가능
```

2) `* const` 타입

: 변수 자체가 const 된 포인터 변수, 즉 포인터 변수 자체가 상수화된다

포인터 변수에 저장되어 있는 주소값을 변경하는 것은 불가능

해당 포인터 변수가 가리키는 주소값의 데이터 값 변경 가능

→ 간접참조 해 값 변경 가능

```cpp
int data = 0;
int* const pData = &data;

*pData = 500;        // ⭕ 가능, 간접참조해 원본 변수의 데이터 값 변경 가능

int a = 0;
pData = &a;          // ❌ 불가능, 포인터 변수가 가리키는 주소값 변경 불가
```

<aside>
📒 const 포인터에 대한 깔끔한 정리는 자료 참고 → [6.13 포인터와 const](https://www.notion.so/6-13-const-cdd0b22ff160448fb8afe4f233e40b61?pvs=21)

</aside>

**const를 무시하는 방법**

```cpp
int value = 100;
const int cValue = 100;      // 상수화된 변수 cValue

// 원래 cValue는 상수화된 변수이기 때문에,
// 포인터로 데이터 변경 위험이 있어 const 포인터로 선언되어야 하지만
const int* pForce1 = &cValue;

// 일반 포인터에 상수화된 변수 할당
// : cValue의 주소값을 일반 포인터 타입으로 형변환
int* pForce2 = (int*) &cValue;

// const 포인터를 강제로 간접 참조
// : const로 되어있는 포인터 변수를 형변환해 간접참조
*((int*)pFroce1) = 200;

```