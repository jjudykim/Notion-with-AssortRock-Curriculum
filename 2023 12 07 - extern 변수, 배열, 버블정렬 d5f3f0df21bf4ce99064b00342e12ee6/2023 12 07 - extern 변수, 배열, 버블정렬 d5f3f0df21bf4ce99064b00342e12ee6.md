# 2023/12/07 - extern 변수, 배열, 버블정렬

태그: C++, 입문, 자료구조
날짜: 2023/12/07
상위 항목: Week2 (Week2%204d4cda48e32a448b92e6b91b7bd876af.md)
주차: 0001_Week1~9

### 전역변수의 중복선언으로 발생하는 오류에 대해

전역변수의 영역 → 해당 프로그램에서 링킹되는 모든 파일의 범위!

따라서 `a.cpp` 소스파일에 `a` 라는 이름을 가진 변수를 선언했다면, b.cpp, c.cpp … 어느 파일에서라도 a라는 전역 변수는 선언할 수 없는 것이다 

(따로 scope를 설정해주는 것이 아니라면! scope 내에선 동일한 이름의 지역변수를 지정한다)

- 단순히 한 파일에서 동일한 이름의 변수를 선언하는 것 → 컴파일 단계에서 오류 (컴파일 오류)
- 여러 파일이 연결되는 과정에서 동일한 이름의 전역변수가 발견되는 것 → 링킹 단계에서 오류 (링크 오류)

### 정적 변수 static과 외부 전역 변수 extern

먼저, 정적 변수 static에 대해 정확하게 짚고 넘어가자!

**static 키워드가 붙은 변수의 특징**

- 선언된 곳에서만 사용이 가능하다! 그 범위가 해당 파일이든, 한 함수든…
- 단, 선언된 곳에 상관없이 데이터는 데이터 영역에 저장된다
    
    → 프로그램의 시작과 끝까지 메모리 공간이 유지된다
    

ex) a.cpp 에서 a라는 static 변수를 선언하고, b.cpp에서 a라는 static 변수를 선언하면

→ 두 변수는 다른 메모리 공간을 가진 개별 변수이다! 파일 별로 전용 전역변수가 생긴 셈. 하지만 메모리는 데이터 영역에 있기 때문에 프로그램 실행 도중엔 계속해서 유지된다. 

그렇다면 이제 **extern**에 대해서 알아보자!

우리가 여태까지 사용하던 전역 변수의 형태는

```cpp
int a = 30;
```

뭐 이런 형태였다!

다만 이렇게 선언된 변수는, 전역변수이지만 다른 파일에서 접근할 수 없었고, 그렇다고 다른 파일에서 사용하고자 재선언을 할 수도 없었다! (링킹에러) 

→ 그렇다면 프로그램 실행동안은 메모리가 유지되면서, 여러 파일에서 접근 가능한 변수를 선언하려면? `extern` 키워드를 활용하면 된다!

**extern 키워드가 붙은 변수**

```cpp
extern int a;
```

→ extern 키워드를 붙여 전방선언을 통해 이 변수가 어딘가에 존재하고 있다고 컴파일러에게 알려주는 문장!

extern 변수는 초기화되어야 하는 시점이 따로 정해진 것이 아니라,

어느 파일에서든 접근도 가능하고 초기화도 가능하다! (exe파일이 실행될 때 초기화)

즉, 링킹 과정에서 실체를 가진다고 할 수 있다

그런데 컴파일러가 해당 변수에 대해서 인지하지도 못한다면, 링킹 과정까지 도달하지 못하고 컴파일러 단에서 태클이 걸릴 것이다 (즉, 함수의 전방선언과 비슷한 이유)

따라서 이렇게 컴파일러에게 미리 외부에서 선언된 변수(extern 변수)가 있다고 말해주는 것!

추가로, 어떤 파일이든 상관은 없지만 초기화가 꼭 한번은 일어나야 한다! 단, 초기화는 단 한번만!→ 단일 정의의 원칙

static 변수와 마찬가지로 다른 파일에서 사용도 가능하고, 메모리도 공유되는 것이다

### 변수 총 정리! (지역 변수, 전역 변수)

변수는 크게는 2가지, 작게는 4가지로 분류할 수 있다고 했었다

- 지역 변수 : local scope 안에 존재하는 변수들은 지역 변수
- 전역 변수 : 일반적인 전역 변수 / 정적 static 변수 / 외부 extern 변수

**지역 변수**

- 함수 내에서 또는 if문, for문에서 등등.. 어느 Scope(블록) 안에서 선언
    
    → if문, for문 안에서 선언하는 변수들도 지역 변수인 이유는 if와 for도 내부적으로 정의된 함수의 일종이기 때문
    
- 해당 함수가 호출되는 함수 스택 내에 포함
- 해당 함수가 종료되면 해당 스택과 같이 해제됨!

**전역 변수(연결이 없는)**

- 함수 외부에서 선언된 변수를 의미
- 해당 파일의 어떤 함수던 접근이 가능하다
- 전역 변수는 정적 주기(static duration)를 가짐! → 즉, 데이터 영역을 사용한다
- 다른 파일에서 기본적으로 접근이 불가능하다 (연결이 없는 상태라고 생각하자)
    
    → `extern` 키워드를 사용해 접근이 가능한데, 그건 외부 변수로 빼서 보자
    
- global이라는 의미의 `g_` 를 접두사로 붙여 사용에 혼선을 막는다

**정적 변수**

- `static` 키워드가 붙은 변수
- 데이터 영역을 사용함 → 정적 주기를 가지기 때문에 프로그램 실행 내내 접근 가능!
- 단, 선언된 곳 내에서만 접근이 가능하다 (함수 내 / 파일 내)
    
    함수 내에서 선언한 경우) 지역 변수처럼 해당 함수 내에서만 접근이 가능
    
    파일 내에서 선언한 경우) 전역 변수처럼 접근이 가능하지만, 다른 파일의 전역변수와 이름 중복이 가능해짐 (서로 다른 메모리 공간을 가짐)
    

**외부 변수(외부 연결이 있는 전역 변수)**

- `extern` 키워드가 붙은 변수
- 데이터 영역을 사용함 → 정적 주기를 가지기 때문에 프로그램 실행 내내 접근 가능!
- 해당 파일 뿐만 아니라 외부 파일에서도 사용이 가능함
- 단, 컴파일러에게 외부 파일에 해당 변수가 존재함을 알려야 함 → 전방선언 또는 헤더파일 활용해 extern 키워드로 재선언
- 여러 파일에서 외부 변수가 사용될 경우, **오직 한 개의 파일에서만 초기화, 즉 정의가 가능**함 → 단일 정의의 원칙
- 여러 파일에서 동일한 데이터 영역의 한 메모리 공간을 공유한다고 생각하면 된다!

### 배열

배열에 대한 기본적인 정리는 다음 자료를 참조하자

<aside>
📒 [6.1~2 배열 기초 array](https://www.notion.so/6-1-2-array-78a1ba5bdf8b411cbfd0fa3db95354e9?pvs=21)

</aside>

배열을 활용할 수 있는 예제로 정렬(sort)를 작성해보기로 했는데..

여기서 자료구조 및 알고리즘에 대한 지식이 부족한게 느껴졌으므로 한번 정리하고 넘어가보겠다!

### 시간복잡도와 Big-O표기법

먼저, 시간복잡도와 Big-O 표기법에 대해 알아보자

**시간 복잡도란,**

어떠한 알고리즘의 로직을 코드로 구현 할 때, *입력 값의 변화에 따라 연산 실행시, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?*에 대한 말이다

→ 즉 효율적인 알고리즘이라는 것은, 입력값이 커짐에 따라 ***증가하는 시간의 비율을 최소화***한 알고리즘이 될 것이다

**Big-O (빅오) 표기법**

빅오 표기법은 ***불필요한 연산을 제거해 알고리즘 분석을 쉽게 할 목적***으로 사용된다

아래 보는 그래프처럼 최악, 평균, 최선의 경우에 대해 나타낼 수 있다

빅오 표기법의 종류는 다음과 같다

<aside>
📒   효율↓  ————————————————————————————→ 효율 ↑
          O(2^N) →  O(N^2) → O(N) → O(N*logN) → O(N) → O(logN) → O(1)

</aside>

![[https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)](2023%2012%2007%20-%20extern%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF,%20%E1%84%87%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20d5f3f0df21bf4ce99064b00342e12ee6/Untitled.png)

[https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)

### 정렬 알고리즘과 버블 정렬

다시 정렬 얘기로 조금 돌아오자면, 

정렬을 하는 알고리즘에는 여러 종류가 있다

삽입 정렬, 선택 정렬, 버블 정렬, 병합 정렬, 퀵 정렬, 트리 정렬 …

그래서 대표적인 몇 개의 정렬들의 시간 복잡도를 확인해보면..

선택정렬 → O(N^2)

삽입정렬 → O(N^2), best는 O(N)

버블정렬 → O(N^2)

병합정렬 → O(N * logN)

퀵 정렬 → worst는 O(N^2), best는 O(N*logN)

정도가 된다!

그러나 단순히 시간복잡도가 효율이 낮다고 해서 무조건 나쁘고, 높다고해서 무조건 좋은 것은 아니고, *시간 복잡도, 메모리 사용량, 안정성(stability), 직렬vs병렬 …* 등을 고려해야 하기 때문에 다양한 정렬 알고리즘을 사용하는 것이다

모두 다 정렬을 표현하는 알고리즘이지만, 상황과 요구사항에 따라서 사용해야 하는 알고리즘이 달라질 수 있다

<aside>
📒 정렬 알고리즘에 대해서 추가적으로 참고할 수 있는 자료
→ [정렬 알고리즘의 선택과 종류 7가지](https://hyo-ue4study.tistory.com/68)

</aside>

오늘은 버블 정렬 알고리즘에 대해서 주목했었는데,

이론적인 난이도는 쉽지만 효율은 좋지 않아 잘 사용하지 않는다는 특징이 있다!

인접한 두 수를 비교해 오름차순 / 내림차순으로 정렬하며, 안정성이 보장된다

![bubblesort.gif](2023%2012%2007%20-%20extern%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF,%20%E1%84%87%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20d5f3f0df21bf4ce99064b00342e12ee6/bubblesort.gif)

버블 정렬의 구현

```cpp
void BubbleSort(int* _arr, int _length)
{
	for (int i = 0; i < _length - 1; i++)
	{
		for(int j = 0; j < _legnth - i - 1; j++)
		{
			if(_arr[j] > _arr[j + 1])
			{
				int temp = _arr[j];
				_arr[j] = _arr[j + 1];
				_arr[j + 1] = temp; 
			}
		}
	}
}
```

단, 버블 정렬의 큰 단점이 하나가 있는데

→ 정렬이 되어있는 수열이더라도 모두 반복작업을 수행한다는 것이다!

이를 최적화할 수 있는 장치를 한번 만들어보자

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

void setRandomNumberForArr(int* _arr, int _size)
{
	for (int i = 0; i < _size; i++) _arr[i] = rand();
}

void printElementsOfArr(int* _arr, int _size)
{
	cout << "arr : ";
	for (int i = 0; i < _size; i++)
	{
		if (i == size - 1) cout << _arr[i];
		else cout << _arr[i] << ", ";
	}
	cout << endl;
}

int main()
{
	// 배열 원소로 난수를 할당하기 위한 seed 설정
	// seed 값으로 현재 시간 부여
	srand((unsigned int)time(NULL)); 

	int arr[10];
	int sizeOfArr = sizeof(arr) / sizeof(int);

	// 배열 원소값 난수로 세팅
	setRandomNumberForArr(arr, sizeOfArr);

	int countOfCheck = 0;

	for (int j = 0; j < sizeOfArr - 1; j++)
	{
		bool isSwappedAnyElements = false;

		for (int i = 0; i < sizeOfArr - (j + 1); i++)
		{
			if (arr[i] > arr[i + 1])
			{
				int smallerNum = arr[i + 1];
				arr[i + 1] = arr[i];
				arr[i] = smallerNum;
				isSwappedAnyElements = true;
			}
			countOfCheck++;
		}
		printElementsOfArr(arr, sizeOfArr);
		if (isSwappedAnyElements == false) break;
	}

	cout << "count of outer all repeat : " << countOfCheck << endl;
	cout << a;

	return 0;
}
```