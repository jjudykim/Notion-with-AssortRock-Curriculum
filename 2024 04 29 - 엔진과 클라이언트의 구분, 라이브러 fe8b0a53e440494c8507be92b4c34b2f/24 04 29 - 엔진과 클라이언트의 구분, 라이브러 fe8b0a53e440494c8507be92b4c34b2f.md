# 24/04/29 - 엔진과 클라이언트의 구분, 라이브러리에 대하여

태그: C++, CS, DirectX11, 중급
상위 항목: Week23 (Week23%20394e612b264041cd8461f961c700ba03.md)
주차: 0011_Week20~29

### 게임 엔진과 클라이언트의 구분

WinAPI 과정을 진행하면서는, 엔진과 클라이언트의 구분 없이 통합적으로 작성해서 진행했었다. 즉, 하나의 솔루션 안에, 하나의 프로젝트를 갖고 진행하며 한 게임을 위한 한 전용 엔진을 만들어 나가며 게임을 개발했었다.

그러나 이제는 게임 제작에 있어 필수적인 부분들(게임 구조 설계, 레벨, 클래스, 오브젝트 등등…)은 게임 엔진으로 별도로 제작해 기반 틀을 만들고, 이를 활용해 게임을 제작하는 식의 설계 방식으로 진행할 것이다!

즉, 엔진 - 클라이언트를 구분하는 것인데, 관리 부분과 컨텐츠 부분을 분리해 편리한 개발 환경을 조성하는 것이다! 이로써 엔진 파트는 특정 게임에 종속적이지 않게 되고, 엔진을 활용해 다양한 컨텐츠의 게임을 제작할 수 있게 된다. 

조금 더 직관적으로 말하자면, 엔진 파트를 라이브러리화 해 게임 제작 시에 적용하는 것이다.

그렇다면 라이브버리란 무엇일까? 🤔

### 라이브러리에 대하여

**라이브러리의 개념**

간단하게 말하자면, 코드 모음집!

여러 프로그램에서 공통으로 사용되는 기능을 모듈화해 제공하는 코드 모음을 의미한다

재사용이 필요한 기능이 반복적인 코드 작성을 하지 않고, 언제든지 필요한 곳에서 호출하여 사용한다는 목적을 가지고 만들어진다.

**라이브러리의 방식의 두 종류**

> 정적 라이브러리(Static Library)
> 

→ 컴파일 시에 프로그램에 포함되는 라이브러리, 즉  컴파일 타임에 링킹되는 라이브러리로, 실행 파일에 라이브러리의 코드가 복사되어서 들어가게 된다

- 작동 방식
    
    1) **컴파일** : **** 정적 라이브러리 소스 코드와 클라이언트(응용 프로그램) 소스코드를 각각 컴파일, 개별적인 객체 파일들의 집합체인 라이브러리 파(lib 파일)이 생성
    
    2) **링크** : 컴파일된 객체 파일들이 링커를 통해 하나의 실행 파일로 결합
    
    3) **실행파일(.exe) 생성** : 링크가 완료되면 최종적으로 실행파일 생성(라이브러리 코드 포함)
    
- 

> Dynamic Library 동적 라이브러리
> 

→ 실행파일과 별도로 존재하면서, 프로그램이 실행될 때 런타임에 필요한 코드가 메모리에 로드되는 방식의 라이브러리

- 작동 방식
    
    1) **컴파일** : 해당 라이브러리 소스코드를 컴파일해 객체 파일을 생성해야 한다. 컴파일 후 생성되는 파일은 .lib 파일, .dll 파일
    
    - `.lib` → 구현된 코드정보에 대한 맵핑 정보, 라이브러리의 정적 링크를 위한 링크 정보, 암시적 링크 제공(실행 파일이 실행될 때 필요한 라이브러리 함수들을 동적으로 로드하는 링크 방식) *즉, 없어도 된다!*
    - `.dll` → 정적 라이브러리에 빗대자면 lib와 같은 코드의 집합체 같은 부분. 라이브러리의 실제 실행 코드를 담고 있으며, 실행 시에 필요한 함수와 데이터를 제공하고 다른 응용 프로그램과 공유될 수 있음
    
    2) **링크** : 객체파일(obj)을 링크해 동적 라이브러리 파일(dll)을 생성
    
    3) **프로그램 실행** : 프로그램이 실행될 때, OS는 필요한 동적 라이브러리 파일을 메모리에 로드
    
    4) **런타임 중 라이브러리 호출** : 프로그램이 실행되면서 필요한 시점에 라이브러리의 함수를 호출할 수 있으며, 이때 프로그램이 라이브러리 파일에 있는 함수의 주소를 찾아 호출(동적 링킹)
    
    5) **메모리 해제** : 사용된 메모리와 함께 로드된 동적 라이브러리 해제
    

**정적 라이브러리와 동적 라이브러리의 차이점**

정적 라이브러리를 Client 프로젝트에 추가하게 되면, 라이브러리 프로젝트를 빌드하는 과정에서 lib 파일은 obj 파일들의 집합체라고 할 수 있어, 최종적으로 실행파일로 합쳐지는 obj 파일이 늘어나게 되는 것이라고 볼 수 있다. 즉, 정적 라이브러리를 추가하게 되면 하나의 exe 실행 파일로 합쳐지는 것이다

그러나 동적 라이브러리는, Client 프로젝트에서 실행시킨 프로그램인 exe 파일과는 별도로 윈도우를 통해 프로세스를 실행시키면, 프로세스의 동적 라이브러리에 별도로 적용되는 개념? 실행 파일을 실행하면 연결된 동적 라이브러리도 프로세스에 올라오게 되면서 실행하는 도중에 서로 링크가 되는 개념이다. 서로 연결되는 구조. 따라서 런타임 도중에 연결을 끊어버릴 수도 있다. 따라서 동적 라이브러리 사용의 장점으로는.. ex)`Window.h` 메모리 상에 DLL 코드는 단 한번만 올라가고, 필요한 기능이 있을 경우에.. 프로그램이 종료되지 않고도 실행하는 도중에 설정을 변경하거나 연결을 해제하거나.. 할 수 있다. 

## 라이브러리를 우리의 클라이언트에서 사용하는 방법

**우리가 제작한 라이브러리는 헤더파일 include만으로는 사용할 수 없다!**

수동으로 라이브러리를 제작하게 되면, 헤더파일만 include 한다고 해서 기능을 사용할 순 없다. 

→ 헤더파일은 단순히 함수나 클래스의 선언만 포함하고 있기 때문에, 실질적으로 정의된, 구현된 코드가 필요하다

따라서 해당 라이브러리의 lib 파일, dll 파일이 함께 링크되어야 해당 기능을  사용할 수 있게 된다!

<aside>
❓ **그럼 STL 같은 표준 라이브러리는 어떻게 헤더파일만 include해도 가능한 것일까?**

- 템플릿 기반 : 컴파일러가 템플릿을 사용하여 필요한 코드를 생성할 수 있는 경우
- Header Only Library : 별도의 라이브러리 파일이 필요 없는 경우
- inline 함수 : 함수의 정의가 헤더 파일에 포함되어 있는 경우

</aside>

직접 라이브러리를 제작을 하고, 제작한 라이브러리를 클라이언트에서 가져다 쓸 수 있도록 작성해보자

### 정적 라이브러리 사용하기

**정적 라이브러리에 포함될 함수 예시**

```cpp
int Pow(int a, int b)
{
	int value = 1;

	for(int i = 0; i < b; ++i)
	{
		value *= a;
	}
	
	return value;
}
```

**현재 솔루션에 정적 라이브러리 프로젝트 추가하기**

프로젝트 추가 > 정적 라이브러리 > 솔루션에 추가 (현재 작성 중인 솔루션에 추가할 경우!)

참고로, 라이브러리 프로젝트는 시작 프로젝트가 될 수 없는데

라이브러리 프로젝트는 빌드하게 되면 라이브러리 파일(lib)이 생성되기 때문이다!

(exe파일이 아니다!)

라이브러리 파일은 API 집합체와 같이, 필요한 곳에서 가져다 쓰기 위한 기능 모음같은 것일 뿐이다

**프로젝트 간의 빌드 순서 설정하기**

Visual Studio에서는 프로젝트 간의 의존성(종속성) 설정할 수 있다 

<aside>
<img src="https://www.notion.so/icons/directional-sign-right_blue.svg" alt="https://www.notion.so/icons/directional-sign-right_blue.svg" width="40px" /> 프로젝트 > 빌드 종속성 > 프로젝트 종속성

</aside>

![Untitled](24%2004%2029%20-%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%87%E1%85%AE%E1%86%AB,%20%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%84%85%E1%85%A5%20fe8b0a53e440494c8507be92b4c34b2f/Untitled.png)

→ Client 프로젝트가 StaticLib에 종속된다

즉, 라이브러리에 구현되어 있는 기능을 클라이언트에서 가져다 쓰는 방식이기 때문에, 라이브러리 파일이 먼저 빌드된 후에 클라이언트가 빌드되어야 한다

**정적 라이브러리(.lib)를 추가해 사용하는 방법**

1) 헤더 포함하기

<aside>
<img src="https://www.notion.so/icons/directional-sign-right_blue.svg" alt="https://www.notion.so/icons/directional-sign-right_blue.svg" width="40px" /> Client 프로젝트 > 속성 > VC++ 디렉터리 > 포함 디렉터리 > `$(SolutionDir)External\Include\`

</aside>

→ Client의 포함 디렉터리에 라이브러리의 헤더가 담긴 Include 폴더를 추가함으로써, 우리가 참조할 라이브러리 파일을 include 할 수 있게 된다!

```cpp
#include <StaticLib/staticlib_func.h>
```

→ 포함 디렉터리를 시작 경로로, StaticLib에 있는 staticlib_func.h를 참조할 수 있다

<aside>
✍️ **#include 시에 사용하는 표기 “ “와 < >의 차이**

- `“ “` : 상대 경로(현재 작업 디렉토리를 기준으로 지정), 현재 소스파일이 위치한 (지금 기준으로는 main.cpp) 디렉토리에서 해당 헤더를 찾을 때

- `< >` : 포함 경로 (파일이나 디렉토리의 위치를 절대적으로 지정), 포함 디렉토리에서 해당 헤더를 찾을 때 사용

</aside>

2) 라이브러리 파일 연결하기

현재까지는 헤더만 include한 것이기 때문에, 실질적인 라이브버리의 구현이 담겨있는 lib 파일도 연결되어야 한다!

<aside>
<img src="https://www.notion.so/icons/directional-sign-right_blue.svg" alt="https://www.notion.so/icons/directional-sign-right_blue.svg" width="40px" /> Client 프로젝트 > 속성 > VC++ 디렉터리 > 라이브러리 디렉터리 > `$(SolutionDir)External\Library\`

</aside>

라이브러리 디렉터리를 설정했다면, 이제 pragma comment를 통해 링킹하도록 작성하면 된다

```cpp
#pragma comment(lib, "StaticLib/StaticLib_D.lib")
```

결론적으로..

```cpp
#include <StaticLib/staticlib_func.h>
#pragma comment(lib, "StaticLib/StaticLib_D.lib")
```

→ 이제부터 Client 프로젝트의 main.cpp 파일에서 Pow 함수를 사용할 수 있다!

**솔루션에 있는 라이브러리 프로젝트는 계속해서 유지해야 할까?**

프로젝트는 코드를 빌드하기 위한 과정이기 때문에, 빌드가 완료된 lib 파일이 있다면 솔루션에 라이브러리 프로젝트가 없더라도 라이브러리를 불러올 수 있다!

하지만 우리는 지금 라이브러리를 계속해서 제작하며 수정해나가는 과정이기 때문에.. 프로젝트를 포함해 가져가도록 하자

### 동적 라이브러리 사용하기

**동적 라이브러리(.dll)를 추가해 사용하는 방법**

동적 라이브러리 프로젝트를 빌드하면 두 가지 파일이 생성된다

정상적으로 빌드가 됐을 경우에 두 가지 파일이 생성되는데..

.lib → 구현된 코드정보에 대한 맵핑 정보 정도만.. 암시적 링크 제공 (즉, 없어도 된다!)

.dll → 정적 라이브러리 개념으로 lib와 같은 코드의 집합체 같은 부분…

*(4/30 추가한 부분)*

동적 라이브러리가 정상적으로 빌드되기 위해선 다음과 같은 키워드 선언이 필요하다

함수를 선언할 때 `extern “C” __declspec(dllexport)` 키워드를 붙여주며 함수를 선언해줘야 한다

ex)

```cpp
extern "C" __declspec(dllexport) float floor(float f);
```

그래서 이게 무슨 의미길래? 하나하나씩 뜯어보자!

```cpp
extern "C" __declspec(dllexport)
```

- `extern “C”` : C++에서는 name mangling이라는 과정을 거쳐 컴파일되는데, 이를 방지하는 기능을 한다! 즉, 함수의 이름이 변경되지 않고 그대로 유지되게끔 한다. C++ 라이브러리를 사용할 때 유용한 키워드
- `__declspec(dllexport)` : 해당 함수나 변수를 외부에서 접근할 수 있도록 하는 역할! 이 지시어를 통해 해당 함수나 변수를 DLL에서 노출시켜, 외부에서 DLL을 사용할 때 호출할 수 있다

반대로, 사용하는 Include 폴더 내의 헤더파일(즉, Client에서 포함하려는 헤더파일)에서는 적용할 키워드가 조금 다르다! 

아까의 경우는 라이브러리 파일의 실질적인 구현이기 때문에, 해당 함수가 외부에서 호출될 수 있도록 개방하는 입장이었다면, 지금은 가져와서 사용하려는 입장인거니까..!

dllexport → dllimport로 변경해 작성해줘야 한다

동적 라이브러리에서 함수나 변수를 가져와야 할 때 사용!

ex)

```cpp
extern "C" __declspec(dllimport) float floor(float f);
```

그런데 이렇게 되면.. 항상 동적 라이브러리를 추가할 때마다 이중으로 헤더를 관리해야 하기 때문에, 여간 번거로운 것이 아니다!

따라서 다음과 같이 전처리기를 활용해, 한번에 작성하는 방법이 있다

즉, 이중으로 헤더를 관리해야 하므로.. 번거로움이 있기 때문에 다음과 같이 전처리기를 응용해서 사용할 수 있다

```cpp
#ifdef DYNAMICLIB_EXPORTS
#define MY_DLL extern "C" __declspec(dllexport)
#else
#define MY_DLL extern "C" __declspec(dllimport)
#endif

MY_DLL float floor(float f);
```

**동적 라이브러리를 적용해 사용해보기**

먼저, Include에 있는 헤더파일을 포함해준다!

```cpp
#include <DynamicLib/DynamicLib_Func.h>
```

이때, 동적 라이브러리를 빌드해 생성된 dll 파일은 우리의 Client 실행 파일과 같은 폴더 내에 존재해야 한다

→ 시스템이 DLL을 자동으로 로드해 프로그램이 필요한 기능을 사용할 수 있게 되기 때문에! 별도의 경로 설정이나 환경 변수를 설정하지 않아도 프로그램을 실행할 수 있게 해준다

동적 라이브러리를 로드하는 방법은 명시적 링크 / 암시적 링크가 있는데,

먼저 **명시적 링크**를 사용해 DLL을 직접 로드하고 사용해보자

```cpp
#include <DynamicLib/DynamicLib_Func.h>

// ...

typedef float (*Dll_Func)(float);           // 함수 포인터 선언

// ...
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
	HMODULE library = LoadLibrary(L"DynamicLib_D.dll");
	
	Dll_Func pFunc = nullptr;
	pFunc = (Dll_Func)GetProcAddress(library, "floor");
	
	float f = pFunc(56.45f);
	
	FreeLibrary(library);
}
```

- `LoadLibrary` : 프로그램이 실행될 때 DLL을 로드하는 함수, DLL 파일의 경로를 인자로 받아서 해당 DLL을 메모리에 로드한 후에 핸들을 반환
- `GetProcAddress` : 로드된 DLL에서 필요한 함수의 주소를 가져오며, DLL 핸들과 함수이름을 인자로 받아서 해당 함수의 주소를 반환
- `FreeLibrary` : DLL의 핸들을 인자로 받아 해당 DLL을 메모리에서 언로드하고 해제
- 단점이 있다면, 필요한 작업이 많아진다. 암시적 링크와 비교했을때 압도적으로 나는 코드 줄 차이… 메모리 할당 / 주소 활용 / 메모리 해제 등 해야할 작업이 많아서 까다롭다

다음으로는 **암시적 링크**를 사용하는 방법!

→ 명시적 링크처럼 번거로운 방법 없이 lib 파일로 링크해주면 된다!

```cpp
#include <DynamicLib/Dll_Func.h>
#ifdef _DEBUG
#pragma comment(lib, "DynamicLib//DynamicLib_D.lib");
#else
#pragma comment(lib, "DynamicLib//DynamicLib.lib");
#endif
```

암시적 링크는 프로그램이 실행될 때 자동으로 DLL을 로드하여 사용하는 방식이다!

프로그램이 실행될 때 DLL을 필요한 메모리에 로드하고, 해당 함수를 호출할 때 찾아서 사용하는 방식이다. 암시적 링크를 사용하면 프로그램 코드에 DLL의 함수나 변수를 사용하는 코드를 명시적으로 작성하지 않아도 되지만, 딱히 동적 라이브러리의 이점을 활용할 수 있는지가 애매…해지기도 하고, 실행 파일의 크기가 증가하게 된다.

우리가 구현하려는 내용은 정적 라이브러리로 충분하기 때문에.. DirectX를 진행하는 동안은 정적 라이브러리를 활용해 구현한다고 한다!