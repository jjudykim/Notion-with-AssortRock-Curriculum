# 2023/12/06 - 전역변수, 정적변수, 분할 구현

태그: C++, 입문
날짜: 2023/12/06
상위 항목: Week2 (Week2%204d4cda48e32a448b92e6b91b7bd876af.md)
주차: 0001_Week1~9

재귀함수를 사용한 피보나치 수열 내용은 지난 수업 정리에 마저 이어서 정리했음!

→ [2023/12/05 - 함수, 스택, 재귀 함수](2023%2012%2005%20-%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE,%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8,%20%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20187c5295ba8d4d4ab944b8e0947ab976.md) 

지역변수 & 정적변수 정리하고 넘어가기

<aside>
📒 [4.2 전역 변수, 정적 변수, 내부 연결, 외부 연결](https://www.notion.so/4-2-6319605bfdb4449f979275b3806185d6?pvs=21)

</aside>

### 전역변수

: 함수(지역) 호출과 종료에 상관없이 유지되는 변수로, **데이터 영역에 저장**된다

데이터 영역에 저장되었다는 것은, 메모리 및 변수가 프로그램 시작 시 초기화되며 프로그램 종료 시 해제된다는 것이다

→ 즉, 프로그램 실행 도중에는 계속해서 유지되는 영역이다

지역변수와 전역변수의 차이를 코드를 통해서 알아보자

우리가 Test()함수가 실행된 횟수를 세고싶다고 가정했을 때, 어떻게 해야할까?

1. Test 함수 내에서 지역변수만 호출해서 진행되는 경우

```cpp
#include <iostream>

int Test()
{
	int i = 0;
	i++;
}

int main()
{
	Test();  // 1
	Test();  // 1
	Test();  // 1

	return 0;
}
```

→ 함수 내에서 선언된 i는 지역변수이기 때문에 함수의 스택 프레임과 같이 생성되고 소멸된다. 즉, Test가 실행될 때마다 새로 생기고 없어진다는 뜻. 이렇게는 실행 횟수를 구할 수 없다

1. 전역변수 global을 선언해서 Test 함수에서 값을 변경하는 경우

```cpp
#include <iostream>

int global = 0;

int Test()
{
	global++;
	return global;
}

int main()
{
	Test();  // 1
	Test();  // 2
	Test();  // 3

	return 0;
}
```

→ 전역변수 global은 프로그램의 시작과 종료까지 계속해서 유지되는 메모리이기 때문에, Test 함수의 스택프레임의 생성과 소멸에 관련없이 값을 저장할 수 있다

2번 코드의 메모리를 그림으로 그려보면 다음과 같다

![Untitled](2023%2012%2006%20-%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE,%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%20c52cb49782114683814318098d46d27f/Untitled.png)

**전역변수의 특징**

- 접근 가능한 영역이 특정 함수 영역에 국한되지 않고, main함수나 다른 함수 내에서도 사용이 가능하다
    
    → 즉, Scope에 제한을 받지 않는다 (심지어는 다른 파일에도! 쓴다고 알려주기만 하면 된다) 
    
- 단, 어디에서든지 접근이 가능하므로 보안성이 없어진다
    
    → 그렇다면 다른 함수에서 접근하지 못하도록 선언하려면? `static` 키워드를 사용한다
    

### 정적 변수(static)

- 데이터 영역 메모리에 존재한다
- 선**언된 곳에서만 사용이 가능**하다 → *지역변수 같은 특징*을 갖고 있네!
    
    → 선언된 곳이 함수 안이라면 함수 내에서만..
    
    전역변수처럼 main함수 밖에서 선언되었다면 그 파일 내에서만 사용 가능!
    
- 선언되는 순간에, **초기화가 단 한번만** 일어난다

위 코드를 전역 변수를 사용하지 않고!!! 정적 변수를 이용해 재구성해보자면,

```cpp
int Test()
{
	static int my_global = 0;

	return ++my_global;
}

int main()
{
	Test();  // 1
	Test();  // 2
	Test();  // 3

	🚨 cout << my_global;     // static 변수는 선언된 범위 내에서 접근할 수 없다
	return 0;
}
```

### 분할 구현

먼저, 분할 구현을 하기 위해서는 함수의 선언과 정의를 구분할 필요부터 있다!

**함수의 선언**

```cpp
int Add(int, int);       // -> 함수의 원형 부분만 선언
```

- 컴파일러에게 함수가 정의되어 있음을 미리 알려주는 것이다
    
    → 링킹 과정에서 함수의 호출부분과 정의 부분을 연결해줘야 하는데, 컴파일 조차 안되면 할 수 없으니까!
    
- 선언은 함수의 호출보다 위에 존재해야 한다
    
    → 마찬가지로, 컴파일러에게 알려주기 위해서
    

**함수의 정의**

```cpp
int Add(int a, int b)
{
	return a + b;
}
```

- 함수의 선언을 통해 함수의 정의 부분은 코드의 어느 위치에 있든 상관없게 되었다! 컴파일러가 일단 존재는 알고 있으니까 😽

그렇다면 왜 분할 구현을 해야할까..

→ cpp 파일은 용량 제한이 있다! (추후에 코드가 누적해서 쌓이게 된다면 컴파일이 안될 수도 있다)

또 용량 제한이 아니더라도.. 기능 및 함수를 분할하고 파일을 나누는 것이 여러 명이서 작업하는 환경에서도 중요하고, 나중에 코드를 재구성하거나 모듈화하기에도 훨씬 유리하다

이제, 파일을 한번 나눠보자

main.cpp

```cpp
#include <iostream>

// Add 함수의 선언
// -> 컴파일러에게 어딘가에 Add함수가 있으니까 태클걸지 말라고 살짝쿵 말해준다~
int Add(int, int);

int main()
{
	int i = Add(2, 3);
	
	return 0;
}
```

math.cpp

```cpp
// 만약, 어느 파일에서라도 Add 함수를 정의해주지 않으면 링크에러 발생
int Add(int a, int b)          
{
	return a + b;
}
```

그런데 만약, math 파일에 엄청나게 많은 함수가 정의되어 있고…

그 속에서 내가 원하는 함수를 찾아와서, 함수의 원형을 내가 실행하고 싶은 파일에 선언하는 것은 아주 번거롭다!! (벌써 텍스트로 적는 것도 번거로움 어휴)

그렇기 때문에 헤더파일을 작성한다(`.h`)

→ 보통 헤더파일에는 함수의 선언 정보만 작성한다!

그렇다면 내가 실행하고 싶은 파일에서는 해당 헤더파일만 include 하면, 그곳에 선언되어 있는 함수들을 자유롭게 사용할 수 있을 것이다!

참고로, `#include “…”`는, 지정된 파일을 현재 파일에 복사/붙여넣기 해달라는 전처리 명령이다!