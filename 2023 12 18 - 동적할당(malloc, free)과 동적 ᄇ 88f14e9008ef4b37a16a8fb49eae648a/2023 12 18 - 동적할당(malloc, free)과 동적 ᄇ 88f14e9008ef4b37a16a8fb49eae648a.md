# 2023/12/18 - 동적할당(malloc, free)과 동적 배열의 구현(1)

태그: C++, CS, 자료구조, 중급, 초급
날짜: 2023/12/18
상위 항목: Week4 (Week4%20d4bcf132c05941958a5653faa4dd0faf.md)
주차: 0001_Week1~9

### 동적 할당이 왜 필요할까?

*왜? 동적할당이 필요할까?*

1. 전역 변수 배열(main 함수 밖에 선언한 배열)은 
    
    → **데이터 영역**을 사용한다
    
    즉, 프로그램 실행 시에 메모리를 할당하고, 프로그램 종료 시에 메모리를 해제하기 때문에 프로그램이 실행되는 동안 메모리의 크기를 가변적으로 변경할 수 없다
    
2. 지역 변수 배열(main 함수, 또는 어느 함수 안에 선언한 배열)은
    
    → **스택 영역**을 사용한다
    
    만약, 배열의 크기를 확정짓지 않는 경우) `int arr[] = {};` → 불가능!
    
    : 초기 데이터를 입력하면 그 개수만큼의 배열로 인식한다
    
    만약, 배열의 크기를 변수로 지정하는 경우) → 불가능!
    
    ```cpp
    const int arrSize = 200;
    int arr[arrSize] = {};
    ```
    
    : 변수는 런타임 중에 데이터가 변경될 수 있으므로, 배열이 선언된 메모리 영역의 크기를 계산할 수 없다
    
    즉, 각 함수의 호출 시 할당할 스택의 크기를 확정지을 수가 없게 된다
    

### 동적 할당이란?

프로그램이 실행하는 도중에, 즉 런타임 중에 실시간으로 필요한 메모리를 할당받거나 해제하는 작업이다. 힙(heap) 영역에서 일어난다!

우리가 지금 배우는 것은 C스타일의 동적할당!

<iostream>에는 힙 영역에 메모리를 할당하는 함수가 내장되어 있다 → 바로 `malloc()`, memory allocater

```cpp
void* pData = malloc(100);
```

→ 100byte만큼의 메모리영역을 힙 영역에 할당하고, 해당 메모리의 시작 주소값을 반환

왜 malloc 함수는 `void*` 타입으로 반환할까?

→ 여러 타입의 포인터로 접근할 수 있기 때문에!!

전에는 이미 특정 자료형, 즉 특정 용도로 만들어진 공간을 그 자료형에 맞는 포인터로 가리켜서 원래의 목적대로 사용했었다! ex) `int arr[30] = {};` → arr은 int 타입밖에 담을 수 없고 int의 크기인 4byte만큼 각 원소가 떨어져 있음

그러나 `malloc()`이 할당받은 공간은 *용도가 정해지지 않은 빈 공간*이기 때문에, 해당 메모리의 주소만 알고 있으면 내가 원하는 타입의 포인터로 해당 주소를 타입 캐스팅해, 내가 원하는 단위(자료형)로 접근 및 데이터 읽기, 쓰기가 가능하다!

→ 즉, 특정 자료형으로 해석될 여지를 주지 않고, **메모리를 할당받은 프로그래머가 그곳의 사용 용도를 결정하게끔** 한다!

예시 코드로 보자면,

```cpp
void* pData = malloc(100);

int* pInt = (int*) pData;

pInt[0] = 100;
pInt[1] = 200;
pInt[24] = 2500;
// ...
```

→ 이렇게 malloc을 통해 100byte의 공간을 할당받고, 해당 공간을 int 타입으로 해석하게끔 타입 캐스팅을 해줬다!

따라서 우리는 할당받은 메모리를 총 25개의 공간 (`sizeof(int) / 100`)을 int 타입으로 사용할 수 있다!

### 동적 할당의 위험성

**할당받은 공간 이상을 사용하는 경우**

할당받았던 메모리인 100byte 이상의 공간에 데이터를 쓰게 된다면 어떻게 될까?

```cpp
pInt[25] = 200;
```

→ 이렇게 작성하면, 할당받은 100byte 공간을 초과하게 된다.

그런데 동적 할당에서 이게 위험한 이유는, **컴파일 에러가 발생하지 않기 때문**이다!!

*스택 영역*이나 *데이터 영역*은, 컴파일 타임에 메모리의 크기가 정해져야 하기 때문에 메모리의 영역을 초과하는 접근을 할 경우 컴파일 에러가 발생하게 된다. 또, 그렇기에 프로그래머가 직접 할당받은 메모리를 해제할 필요도 없다!

그러나 동적 할당에 사용되는 **힙 영역**은, 프로그램 실행 도중에 얼마든지 할당받고 해제할 수 있는 영역이기 때문에, 컴파일 타임에 데이터의 접근이 메모리 영역을 초과하는 것인지 확인할 수 없다.

또한, 힙 영역에서 할당받은 메모리 공간의 끝에는 **마킹비트**(할당받은 메모리 영역의 끝을 알리는 역할)가 들어있는데, 초과해서 메모리를 사용할 경우 이 마킹비트를 훼손하게 된다! 즉, 우리가 할당받은 메모리의 끝이 어디인지를 모르게 된다!

이 경우에 할당받았던 메모리를 해제하려고 하면, **힙 손상(Heap Corruption)이 발생**하게 된다

따라서 힙 영역에서 할당받은 공간은 초과해서 사용하지 않도록 각별히 주의해야 한다! 힙 손상 오류는 발생 및 해결까지 굉장한 시간이 소요될 수 있다 😟

**할당한 메모리를 해제해주지 않는 경우**

힙 영역에 할당받았던 공간을 해제할 때에는 `free()` 를 사용해준다. 매개변수로는 해제하려는 메모리 공간의 주소나 해당 공간을 가리키는 포인터를 넣어주면 된다!

그러나 free를 해주지 않는다면, 그 메모리 영역은 사용중인 상태로 남게 되는 것이다! 이때 메모리 누수(leak)이 발생하게 된다. 메모리 누수가 심각하게 누적될 경우, 시스템 메모리(RAM) 부족 현상으로 재부팅을 해야하는 상황이 발생한다

### 동적 할당을 활용한 자료구조의 구현 (1) - 동적 배열

우리는 동적 할당을 활용해 C++ 수업 동안 3가지의 자료구조를 구현해볼 것이다! 물론 STL로 다 구현이 되어있지만, 직접 구현을 해봄으로써 그 원리를 이해해보자 😽

```cpp
동적 배열(가변 배열)            <vector>   -> 오늘 해볼 것!
연결형 리스트(linked list)      <list>
이진 탐색 트리                  <map>
```

```cpp
#pragma once

// 동적 배열의 역할을 수행할 수 있는 자료형이자,
// 데이터를 관리하는 컨테이너 DArr 정의
struct DArr
{
	// 배열의 주소를 저장하는 포인터 변수 pData
	int* pData;

	// 현재 공간에 멤버가 얼마나 할당됐는지를 확인하기 위한 변수
	int MaxCount;       // 허용 가능한 최대 공간 개수
	int CurCount;       // 현재 채워진 데이터 개수
};

// 헤더파일에서는 함수의 선언만 구현한다!
// 만약, 함수를 외부에서 단독호출하기를 원하지 않는다면
// 헤더파일에서 선언을 명시하지 않고 cpp 파일에서 바로 구현한다

// 동적 배열의 초기화
void InitDArr(DArr* _pArr);

// 동적 배열의 멤버 추가
void PushData(DArr* _pArr, int _Data);

// 동적 배열 메모리 공간의 재할당
void Realloc(DArr* _pArr);

// 동적 배열의 멤버 접근
int GetData(DArr* _pArr, int _Idx);

```

```cpp
#include <iostream>
#include <assert.h>     // assert(nullptr)일 경우 컴파일 오류 발생
#include "DArr.h"

void InitDArr(DArr* _pArr)
{
	_pArr->MaxCount = 4;
	_pArr->CurCount = 0;

	// 설정한 최대 크기만큼, 원하는 데이터 타입의 메모리 공간을 할당해 pData에 해당 주소 대입!
	_pArr->pData = (int*)malloc(sizeof(int) * _pArr->MaxCount);
}

void PushData(DArr* _pArr, int _Data)
{
	if (_pArr->MaxCount <= _pArr->CurCount)
	{
		// 이때부터 메모리 공간이 모자란거니까, 공간을 확장시켜줘야 한다!
		// 그런데, 원래 기존에 할당받았던 메모리를 이어서 크게 확장할 방법은 없고,
		// 새로운 더 큰 메모리 공간을 할당받아, 해당 주소로 이사를 해야한다!
		Realloc(_pArr);
	}

	// 배열의 현재 index에 접근해 데이터 할당
	_pArr->pData[_pArr->CurCount++] = _Data;
}

// 재할당 realloc!
void Realloc(DArr* _pArr)
{
	// 1. 수용할 수 있는 크기를 더 크게 갱신하고, 해당 크기 만큼의 메모리 공간을 할당받는다
	_pArr->MaxCount *= 2; 
	int* pNew = (int*)malloc(_pArr->MaxCount * sizeof(int));

	// 2. 기존에 가지고 있던 데이터를 새로운 곳으로 옮겨둔다
	for(int i = 0; i < CurCount; i++)
	{
		pNew[i] = _pArr->pData[i];
	}

	// 3. 기존에 할당받았던 메모리 공간을 해제
	free(_pArr->pData);

	// 4. 새로운 공간의 메모리 공간으로 지정(갱신)해준다
	_pArr->pData = pNew;
}

int GetData(DArr* _pArr, int _Idx)
{
	// assert는 디버깅 모드에서 개발자가 오류가 생기면 치명적일 것이라는 곳에 심어 놓는 에러 검출용 코드
	// assert(false)일 경우에 컴파일 오류 발생!
	// 접근하려는 index가 CurCount보다 크거나 같을 경우, 
	// 해당 공간은 nullptr이거나 접근 불가능한, 할당받은 크기 외의 공간!
	// 따라서 index가 CurCount보다 작을 경우에만, 배열의 해당 index 멤버 반환
	assert(!(_pArr->CurCount <= _Idx));
	return _pArr->pData[_Idx];
}
```

```cpp
#include <iostream>
#include "DArr.h"

int main()
{
	// 동적 배열의 데이터를 관리하는 컨테이너 DArr
	DArr arr = {};

	// 동적 배열의 초기화 과정
	InitDArr(&arr);

	// 동적 배열의 멤버 추가
	PushData(&arr, 10);
	PushData(&arr, 20);
	PushData(&arr, 30);
	PushData(&arr, 40);

	// 초기에 할당했던 공간 이상으로 확장한 후 멤버 추가
	PushData(&arr, 10);
	PushData(&arr, 10);
	
	int data = 0;
	for (int i = 0; i < arr.CurCount; i++)
	{
		// 동적배열의 i번째 index의 멤버에 접근
		data = GetData(&arr, i)
		std::cout << data << std::endl;
	}

	return 0;
}
```