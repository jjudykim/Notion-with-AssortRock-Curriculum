# 2023/11/30 - 비교 연산자, 논리연산자, 조건문, 반복문, 비트쉬프트 연산자

태그: C++, 입문
날짜: 2023/11/30
상위 항목: Week1 (../../Week1%20b504431a81c04149b2f5d2508cc1502f.md)
주차: 0001_Week1~9

### 비교연산자

비교연산자의 결과값은 참/거짓으로 도출된다

→ ***0은 거짓***으로 보고, 0이 아닌 모든 수를 참으로 본다 (대표격인 숫자가 1)

참, 거짓을 다루는 자료형 bool(1),

표현 체계는 정수타입에 해당하지만, 0이 아닌 모든 수를 1(참)으로 바꾸어서 저장한다.

**비교연산자의 종류**

- `==` : 같은 지를 비교 → 같으면 참(1), 같지 않으면 거짓(0)
- `!=` : 같지 않은지를 비교 → 같지 않으면 참(1), 같으면 거짓(0)
- `>` : 왼쪽이 더 큰지를 비교 → 왼쪽이 더 크다면 참(1), 같거나 작다면 거짓(0)
- `<` : 오른쪽이 더 큰지를 비교 → 오른쪽이 더 크다면 참(1), 같거나 작다면 거짓(0)
- `>=` : 왼쪽이 더 크거나 같은지를 비교 → 왼쪽이 같거나 더 크다면 참(1), 작다면 거짓(0)
- `<=` : 오른쪽이 더 크거나 같은지를 비교 → 오른쪽이 같거나 더 크다면 참(1), 작다면 거짓(0)

→ 비교 연산자의 결과는 참(1), 또는 거짓(0)

### 논리 연산자의 이해를 위한 조건문

if 구문(조건문)과 함께 많이 사용한다

→ 코드의 흐름제어와 분기처리가 가능해진다!

먼저, 조건문에 대해 훑고 넘어가보자

**if문(else-if, else)**

```cpp
**if**(참이나 거짓을 판별할 수 있는 문장)
{
	// 참일 경우에 실행되는 statements
}

// else-if문은 생략 가능하다 (if 없이 단독사용 불가능)
**else if** (if의 내용을 제외한 또 다른 조건이 설정되어 있는 문장)
{
	// 참일 경우에 실행되는 statements
	// 만약 위쪽에서 한 if 또는 else if에라도 걸린다면 생략된다
}

//else문은 생략 가능하다 (if 없이 단독사용 불가능)
**else** 
{
	// 모든 조건의 결과가 거짓일 경우에 실행되는 statements
	// 어떤 조건에도 해당하지 않을 때를 잡아내고 싶은 경우!
}
```

- if와 else if가 연결되어 있는 경우, 하나의 조건만 성공할 수 있다!
- if - else if - else문 아래에 새로운 if가 등장할 경우에는 별개의 다른 조건문으로 처리된다 (조건 공유 X)

→ 각각의 조건이 별개로 검사되어야 하는지(연속적인 if문의 사용), 아니면 전체의 조건에서 세부적인 설정을 나눠서 엮을 것인지(if-else if-else문의 사용)를 잘 판단하기!

**switch-case문**

```cpp
switch(검사할 변수)
{
case 100:
	// 검사할 변수 == 100인 경우에 실행되는 statements
	break;
case 60:
	// 검사할 변수 == 60인 경우에 실행되는 statements
	break;
case 40:
	// 검사할 변수 == 40인 경우에 실행되는 statements
	break;
default:
	// 하나도 해당되는 case가 없을 경우 기본적으로 실행되는 statements
}
```

- 각 case의 마지막에 break를 이용해서 swtich 구문을 종료한다
- 중간에 `break;` 가 없다면, 아래에 있는 case도 연이어서 실행된다
    
    : 여러 case의 조건을 묶고 싶은 경우 case를 모아서 한번에 break 처리할 수도 있다!
    
    → 의도적으로 활용할 수 있는 부분이지만, 실수(의도치 않은 여러 case의 작업 처리)가 발생할 수도 있으니까 주의하기
    

### 논리연산자

그럼 본격적으로 **논리연산자**에 대해 알아보도록 하자

→ 양쪽 피연산자의 참, 거짓 여부를 연결 다시 참, 거짓 여부를 판별한다

- `&&`(And)
    
    왼쪽, 오른쪽이 모두 참인가요? → 모두 참일때 참(1), 하나라도 거짓이면 거짓(0)
    
    여러 조건 상황을 판별했을 때, 모든 상황이 참일 경우에만 어떤 기능을 하고 싶을 때 활용
    
    ex 1)
    
    ```cpp
    // 100은 200보다 작은가요? 그리고, 400은 300보다 큰가요?
    if (100 < 200 && 400 > 300)
    {
    	// ...
    } 
    ```
    
    → 두 조건이 모두 참이므로, 연산 결과는 참이므로 if 안에 있는 statements 실행
    
    ex 2)
    
    ```cpp
    // 600은 1000보다 큰가요? 그리고, 3은 5보다 작은가요?
    if (600 > 1000 && 3 < 5)
    {
    	// ...
    }
    ```
    
    → 첫번째 조건이 거짓이기 연산 결과는 거짓이므로 때문에 if 안에 있는 statements가 실행되지 않음
    
- `||`(or)
    
    왼쪽, 오른쪽 둘 중 하나라도 참인가요? → 하나라도 참일때 참(1), 모두 거짓이면 거짓(0)
    
    여러 조건 상황을 판별했을 때, 단 한 상황이라도 참일 경우에 어떤 기능을 하고 싶을 때 활용
    
    ex 1)
    
    ```cpp
    // 100은 200보다 작은가요? 그리고, 400은 300보다 큰가요?
    if (100 < 200 && 400 > 300)
    {
    	// ...
    } 
    ```
    
    → 두 조건이 모두 참이므로, 연산 결과는 참이므로 if 안에 있는 statements 실행
    
    ex 2)
    
    ```cpp
    // 600은 1000보다 큰가요? 그리고, 3은 5보다 작은가요?
    if (600 > 1000 && 3 < 5)
    {
    	// ...
    }
    ```
    
    → 첫번째 조건이 거짓이지만 두번째 조건이 참이기 때문에, 연산 결과는 참이므로 때문에 if 안에 있는 statements가 실행
    
    ex 3)
    
    ```cpp
    // a에 100이 할당되었을 때, 
    // a는 30과 동일한가요? 또는, a는 50과 동일한가요?
    int a = 100;
    if (a == 30 || a == 50)
    {
    	// ...
    }
    ```
    
    → 두 조건이 모두 거짓이기 때문에, 연산 결과는 거짓이므로 때문에 if 안에 있는 statements가 실행되지 않음
    

### 반복문

지정된 코드를 원하는 횟수만큼 반복해서 동작하고 싶을 때 활용하는 문법

**for문**

```cpp
for(변수 초기화(1); 반복 조건 테스트(true/false)(2); 반복 수행마다 수행(4))
{
	// 반복할 statements (3)
}
```

→ 괄호 안의 숫자를 실행 순서라고 했을 때, 반복문은 다음과 같이 실행된다

(1) → (2) → (3) → (4) → (2) → (3) → (4) → (2) → (3) → (4) … → (2)

- (1)은 반복문에서 사용할 변수를 초기화하는 것이기 때문에 맨 처음 한 번만 실행
- (2)를 검사했을 때 false로 반환되는 시점에 for문 탈출!

ex 1) 

```cpp
for(int i = 0; i < 5; i++)
{
	printf("문장을 출력한다!\n");
}
```

**while문**

```cpp
변수 초기화;

while(반복을 검사할 조건 테스트)
{
		// while문을 멈출 수 있는, 조건을 중단할 수 있는 statements 필요
		반복 수행마다 수행
}
```

ex 1) 

```cpp
int j = 0;
while (j < 5)
{
	printf("while 문 출력\n");
	j++;
}
```

**continue와 break**

→ 반복문 내부 제어에서 활용 (for문, while문 모두)

- **continue**
    
    : 반복문 내에서 `continue`를 만나게 되면, 아래 구문들을 무시한 채로 그 즉시 *반복 조건 테스트* 시점으로 skip하게 된다!
    
    반복문을 중단하는 건 아님, 이어서 실행하지만 해당 시점만 skip
    
- **break**
    
    : 반복문 내에서 break를 만나게 되면, 그 즉시 반복문을 탈출하게 된다
    
    반복문 강제 중단
    

### 비트 쉬프트 연산자

→ 비트 값을 변경시켜버리는 연산자, 비트 단위로 자리수를 이동시킨다

`>>`, `<<`

- `>>` : 비트를 오른쪽으로 한 칸 밀어라!
    
    1칸 옮겼을 때 10진수 기준 1/2배의 결과값 도출 → 2의 승수로 나눈 몫
    
    ```cpp
    int i = 128 >> 1;
    // 1의 이진수 0000 0000 0000 0000 0000 0000 1000 0000을 오른쪽으로 한 칸 민다 
    // 연산 결과로 i에 담겨있는 이진수는 0000 0000 0000 0000 0000 0000 0100 0000 -> 64
    ```
    

- `<<` : 비트를 왼쪽으로 한 칸 밀어라!
    
    1칸 옮겼을 때 10진수 기준 2배의 결과값 도출 → 2의 승수로 곱한 값