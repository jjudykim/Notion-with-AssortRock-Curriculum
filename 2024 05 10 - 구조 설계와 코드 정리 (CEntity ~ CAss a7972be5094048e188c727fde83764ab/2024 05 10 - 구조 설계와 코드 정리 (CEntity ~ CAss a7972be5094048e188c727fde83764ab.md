# 24/05/10 - êµ¬ì¡° ì„¤ê³„ì™€ ì½”ë“œ ì •ë¦¬ (CEntity ~ CAsset)

íƒœê·¸: C++, DirectX11, ì¤‘ê¸‰
ìƒìœ„ í•­ëª©: Week24 (Week24%20d7c7179c6b2f49348c9827ed8755dacc.md)
ì£¼ì°¨: 0011_Week20~29

### êµ¬ì¡° ì„¤ê³„ & ì½”ë“œ ì •ë¦¬

ì§€ê¸ˆê¹Œì§€ ì‘ì„±í–ˆë˜ ì½”ë“œëŠ” ë”°ë¡œ ê°ì²´ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³ , Tempë¼ëŠ” ê³¼ì •ì—ì„œ ì‚¼ê°í˜•ì„ ì§ì ‘ì ìœ¼ë¡œ ê·¸ë ¸ë‹¤. ê·¸ëŸ°ë° ì´ì œ ìš°ë¦¬ê°€ ì‚¼ê°í˜•ìœ¼ë¡œ ë§Œë“  ê°œë… ìì²´ê°€, ì•ìœ¼ë¡œëŠ” Meshë¼ëŠ” í•˜ë‚˜ì˜ ëª¨ì–‘ì´ ë˜ê³ , í•˜ë‚˜ì˜ ì—ì…‹ìœ¼ë¡œ ì‚¬ìš©ë  ê²ƒì´ë‹¤

â†’ ë”°ë¼ì„œ Gameì— ì‚¬ìš©ë  Objectë“¤ì„ ìƒì„±í•˜ê¸° ìœ„í•œ ê·¸ ê¸°ë°˜ë“¤ì„ ë‹¤ì§€ëŠ” ì‘ì—…ë“¤, ì¦‰ ëª¨ë“ˆí™”ë¥¼ ìœ„í•œ êµ¬ì¡° ì„¤ê³„ì™€ ì½”ë“œ ì •ë¦¬ë¥¼ ì§„í–‰í•´ë³´ì!!

ëª©í‘œëŠ”.. Temp íŒŒì¼ì„ ì ìš©í•˜ì§€ ì•Šë”ë¼ë„ ì˜ ì‹¤í–‰ì´ ë˜ê²Œë” ëª¨ë“ˆí™”ê°€ ì§„í–‰ë˜ëŠ” ê²ƒ! ğŸ˜³

**Filter ë° í´ë˜ìŠ¤ ì¶”ê°€**

<aside>
ğŸ“ *í•„í„° ì¶”ê°€*
**04. Level
05. Asset** > Mesh / MeshData / Material / Prefab / Texture / Sound / GraphicShader / ComputeShader
**06. GameObject**
**07. Component**

</aside>

### ëª¨ë“  Objectë“¤ì˜ ì¡°ìƒ í´ë˜ìŠ¤, CEntity ì‘ì„±í•˜ê¸°

ëª¨ë“  ì˜¤ë¸Œì íŠ¸ë“¤ì˜ ê¸°ë°˜ì´ ë˜ëŠ” **Entity í´ë˜ìŠ¤**ë¥¼ ìƒì„±í•´ë³´ì

```cpp
#pragma once

class CEntity
{
private:
	static UINT g_ID;

private:
	wstring       m_Name;
	const UINT    m_ID;
	
public:
	void SetName(const wstring& _Name) { m_Name = _Name; }
	const wstring& GetName() { return m_Name; }
	UINT GetID() { return m_ID; }
	
	virtual CEntity* Clone() = 0;
	
public:
	CEntity();
	CEntity(const Centity& _Other);
	virtual	~CEntity();
};
```

```cpp
#include "pch.h"
#include "CEntity.h"

UINT CEntity::g_ID = 0;

CEntity::CEntity()
	: m_ID(g_ID++)
{
}

CEntity(const Centity& _Other)
	: m_ID(g_ID++)
	, m_Name(_Other.m_Name)
{
}

CEntity::~CEntity()
{
}
```

### Assetê³¼ ì´ë¥¼ ê´€ë¦¬í•˜ëŠ” Asset Manager, ê·¸ë¦¬ê³  Asset ì¤‘ í•˜ë‚˜ì¸ Mesh ì œì‘í•˜ê¸°

ë¨¼ì €, CEntityë¥¼ ìƒì†ë°›ëŠ” Assetì¸ **CAsset**ì„ ì‘ì„±í•´ë³´ì

```cpp
#pragma once
#include "CEntity.h"

class CAsset :
	public CEntity
{
private:
	wstring           m_Key;
	wstring           m_RelativePath;
	const ASSET_TYPE  m_Type;               // ê° Assetì€ ASSET_TYPEì„ ë©¤ë²„ë¡œ ê°€ì§„ë‹¤!
	
public:
	const wstring& GetKey() { return m_Key; }
	const wstring& GetRelativePath() { return m_RelativePath; }
	ASSET_TYPE GetAssetType { return m_Type; } 

private:
	void SetKey(const wstring& _Key) { m_Key = _key; }
	void SetRelativePath(const wstring& _Path) { m_RelativePath = _Path; }
	
public:
	virtual void Binding() = 0;      // ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜) GPUì—ê²Œ í•´ë‹¹ ì—ì…‹ì„ ì „ë‹¬í•˜ëŠ” í•¨ìˆ˜
	virtual CAsset* Clone() { return nullptr; }
		
public:
	CAsset(ASSET_TYPE _Type);
	~CAsset();
	
	friend class CAssetMgr;
};
```

```cpp
#include "pch.h"
#include "CAsset.h"

CAsset::CAsset(ASSET_TYPE _Type)
	: m_Type(_Type)
{
}

CAsset::~CAsset()
{
}

```

â†’ ì¶”ìƒí´ë˜ìŠ¤ë¡œ ë§Œë“¤ê¸° ìœ„í•œ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ `Binding` ì¶”ê°€

Bindingì€ GPUì˜ íŒŒì´í”„ë¼ì¸ì— ìì›ì„ í• ë‹¹í•˜ê³  ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ ì„¤ì •í•˜ëŠ” ê³¼ì •ì„ ì˜ë¯¸í•œë‹¤!
ìš°ë¦¬ëŠ” ì´ë¯¸ ë°”ì¸ë”©ì˜ ì˜ë¯¸ëŠ” ëª¨ë¥´ë”ë¼ë„, ì´ë¯¸ íŒŒì´í”„ë¼ì¸ì— ìì›ì´ ë°”ì¸ë”©ë˜ë„ë¡ í•˜ëŠ” ì‘ì—…ë“¤ì€ ì‘ì„±í–ˆì—ˆë‹¤ :3

ê·¸ë¦¬ê³  ì´ë•Œ ë©¤ë²„ë¡œ ì‚¬ìš©ë , `ASSET_TYPE`ì„ ì •ì˜í•´ì£¼ì

enum.hë¥¼ ì œì‘í•´ì„œ, Asset Type enum classë¥¼ ì œì‘í•´ì£¼ê¸°!

```cpp
// ...
#include "enum.h"
```

```cpp
#pragma once

enum class ASSET_TYPE
{
	MESH,
	MESH_DATA,
	MATERIAL,
	PREFAB,
	TEXTURE,
	SOUND,
	GRAPHIC_SHADER,
	COMPUTE_SHADER,
	END,
}
```

ì´ëŸ° Assetë“¤ì„ ë“±ë¡í•˜ê³ , ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” Asset Managerì¸ **CAssetMgr í´ë˜ìŠ¤**ë¥¼ ì‘ì„±í•´ë³´ì (í‹€ë§Œ!)

```cpp
#pragma once

class CAssetMgr
	: public CSingleton<CAssetMgr>
{
	SINGLE(CAssetMgr);

public:
	void Init();
}
```

```cpp
#include "pch.h"
#include "CAssetMgr.h"

CAssetMgr::CAssetMgr()
{
}

CAssetMgr::~CAssetMgr()
{
}
```

ì´ì œ, Assetì„ ìƒì†ë°›ëŠ”! ê·¸ë¦¬ê³  Assetì˜ ì¢…ë¥˜ ì¤‘ í•˜ë‚˜ì¸ **CMesh**ë¥¼ ì œì‘í•´ë³´ì

```cpp
class CMesh :
	public CAsset
{
private:
	ComPtr<ID3D11Buffer> m_VB;           // Vertexë“¤ì„ ì €ì¥í•  ë²„í¼
	ComPtr<ID3D11Buffer> m_IB;           // Indexë¥¼ ì €ì¥í•  ë²„í¼
	
	UINT                 m_VtxCount;
	UINT                 m_IdxCount;
	
	D3D11_BUFFER_DESC    m_VBDesc;
	D3D11_BIFFER_DESC    m_IBDesc;
	
	void*                m_VtxSysMem;    // Vertex ì •ë³´ë¥¼ ê¹Šì€ ë³µì‚¬í•  í¬ì¸í„°
	void*                m_IdxSysMem;    // Index ì •ë³´ë¥¼ ê¹Šì€ ë³µì‚¬í•  í¬ì¸í„°
	
public:
	int Create(Vtx* _SysMem, UINT _VtxCount, UINT* _IdxSysMem, UINT _IdxCount);
	virtual void Binding() override;
	void render();
	
public:
	CMesh();
	~CMesh();
}
```

```cpp
CMesh::CMesh()
	: CAsset(ASSET_TYPE::MESH)
	, m_VtxCount(0)
	, m_IdxCound(0)
	, m_VBDesc{}
	, m_IBDesc{}
	, m_VtxSysMem(nullptr)
	, m_IdxSysMem(nullptr)
{
}

CMesh::~CMesh()
{
	if (m_VtxSysMem != nullptr)
		delete m_VtxSysMem;r
		
	if (m_IdxSysMem != nullptr)
		delete m_IdxSysMem;
}

int CMesh::Create(Vtx* _VtxSysMem, UINT _VtxCount, UINT* _IdxSysMem, UINT _IdxCount)
{
	m_VtxCount = _VtxCount;
	m_IdxCount = _IdxCount;
	
	// ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ ìƒì˜ Vertex Buffer / Index Buffer -> ê¹Šì€ ë³µì‚¬ë¡œ ë³µì‚¬
	m_VtxSysMem = new Vtx[m_VtxCount];
	memcpy(m_VtxSysMem, _VtxSysMem, sizeof(Vtx) * m_VtxCount);
	
	m_IdxSysMem = new UINT[m_IdxCount];
	memcpy(m_IdxSysMem, _IdxSysMem, sizeof(UINT) * m_IdxCount);
	
	// Vertex Buffer ìƒì„±
	m_VBDesc.ByteWidth = sizeof(Vtx) * m_VtxCount;
	m_VBDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	m_VBDesc.Usage = D3D11_USAGE_DEFAULT;
	m_VBDesc.CPUAccessFlags = 0;
	m_VBDesc.MiscFlags = 0;
	m_VBDesc.StructureByteStride = 0;
	
	D3D11_SUBRESOURCE_DATA tSub = {};
	tSub.pSysMem = _VtxSysMem;
	
	if (FAILED(DEVICE->CreateBuffer(&m_VBDesc, &tSub, m_VB.GetAddressOf())))
	{
		MessageBox(nullptr, L"VertexBuffer ìƒì„± ì‹¤íŒ¨", L"Mesh ìƒì„± ì‹¤íŒ¨", MB_OK);
		return E_FAIL;
	}
	
	// Index Buffer ìƒì„±
	m_IBDesc.ByteWidth = sizeof(UINT) * m_IdxCount;
	m_IBDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
	m_IBDesc.Usage = D3D11_USAGE_DEFAULT;
	m_IBDesc.CPUAccessFlags = 0;
	m_IBDesc.MiscFlags = 0;
	m_IBDesc.StructureByteStride = 0;
	
	tSub.pSysMem = _IdxSysMem;
	
	if (FAILED(DEVICE->CreateBuffer(&m_IBDesc, &tSub, m_IB.GetAddressOf())))
	{
		MessageBox(nullptr, L"IndexBuffer ìƒì„± ì‹¤íŒ¨", L"Mesh ìƒì„± ì‹¤íŒ¨", MB_OK);
		return E_FAIL;
	}

	return S_OK;
}

void CMesh::Binding()
{
	// Vertex Bufferì™€ Index Bufferì— ëŒ€í•œ IA ë‹¨ê³„ì˜ ì„¤ì •
	UINT stride = sizeof(Vtx);
	UINT offset = 0;
	CONTEXT->IASetVertexBuffers(0, 1, m_VB.GetAddressOf(), &stride, &offset);
	CONTEXT->IASetIndexBuffer(m_IB.Get(), DXGI_FORMAT_R32_UINT, 0);
}

void CMesh::render()
{
	Binding();
	CONTEXT->DrawIndexed(m_IdxCount, 0, 0);
}

```

ê·¸ë ‡ë‹¤ë©´ ì´ì œ, Tempì—ì„œ Mesh í´ë˜ìŠ¤ë¥¼ í™œìš©í•´ ì—ì…‹ ê°ì²´ë¥¼ í•˜ë‚˜ ìƒì„±í•´ë³´ì!

**Tempì—ì„œ ì—ì…‹ ê°ì²´ì¸ Mesh ìƒì„±í•˜ê¸°**

```cpp
// ...
#include "CEntity.h"
#include "CMesh.h"

tTransform g_ObjTrans = {};
CMesh* g_Mesh = nullptr;

// ì „ì—­ Vertex Shader
// ì „ì—­ Pixel Shader
// ì—ëŸ¬ Blob
// ë ˆì´ì•„ì›ƒ
// Constant Buffer ìƒì„±
// ...

TempInit()
{
	g_ObjTrans.Scale = Vec4(1.2f, 1.2f, 1.2f, 1.f);
	
	// Vertex Buffer ìƒì„±
	Vtx arrVtx[4] = {};

	arrVtx[0].vPos = Vec3(-0.5f, 0.5f, 0.f);
	arrVtx[0].vColor = Vec4(1.f, 0.f, 0.f, 1.f);

	arrVtx[1].vPos = Vec3(0.5f, 0.5f, 0.f);
	arrVtx[1].vColor = Vec4(0.f, 1.f, 0.f, 1.f);

	arrVtx[2].vPos = Vec3(0.5f, -0.5f, 0.5f);
	arrVtx[2].vColor = Vec4(0.f, 0.f, 1.f, 1.f);

	arrVtx[3].vPos = Vec3(-0.5f, -0.5f, 0.f);
	arrVtx[3].vColor = Vec4(1.f, 0.f, 0.f, 1.f);
	
	// Index Buffer ìƒì„±
	UINT arrIdx[6] = {};
	arrIdx[0] = 0;	arrIdx[1] = 1;	arrIdx[2] = 2;
	arrIdx[3] = 0; 	arrIdx[4] = 2;	arrIdx[5] = 3;

	// Rect Mesh ìƒì„±
	g_Mesh = new CMesh;
	g_Mesh->Create(arrVtx, 4, arrIdx, 6);
	
	// Constant Buffer ìƒì„±
	// Vertex Shader ìƒì„±
	// Pixel Shader ìƒì„±
	// Layout ìƒì„±
	// ...
}
```

**Meshì˜ Renderì™€ Binding**

ê¸°ì¡´ì— Temp Renderì—ì„œ Vertex Bufferì™€ Index Buffer ì„¸íŒ…ë˜ì—ˆë˜ ë¶€ë¶„ì„, 
Meshë¼ëŠ” ê·¸ë˜í”½ ë¦¬ì†ŒìŠ¤ê°€ Bindingë  ë•Œ ì ìš©ë˜ê²Œë” ë³€ê²½í•´ì„œ ì‘ì„±í•´ì£¼ì!

```cpp
void CMesh::Binding()
{
	UINT stride = sizeof(Vtx);
	UINT offset = 0;
	CONTEXT->IASetVertexBuffers(0, 1, m_VB.GetAddressOf(), &stride, &offset);
	CONTEXT->IASetIndexBuffer(m_IB.Get(), DXGI_FORMAT_R32_UINT, 0);
}

void CMesh::render()
{
	Binding();         // ì™¸ë¶€ì—ì„œ Meshì— ì ‘ê·¼í•´ Bindingì„ í˜¸ì¶œí•˜ì§€ ì•Šê³ , render í˜¸ì¶œë¡œ ì—°ê²°
	
	CONTEXT->DrawIndexed(m_IdxCount, 0, 0);
}
```

ì¦‰, ì´ì œ Asset(Mesh)ì„ renderí•œë‹¤ëŠ” ê²ƒì€ í•´ë‹¹ ì—ì…‹ì´ Bindingë¨ê³¼ ë™ì‹œì— ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì„ ì‹œì‘í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤!

```cpp
void TempRender()
{
	CONTEXT->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); 
	CONTEXT->IASetInputLayout(g_Layout.Get());
	
	CONTEXT->VSSetConstantBuffers(0, 1, g_CB.GetAdressOf());
	
	CONTEXT->VSSetShader(g_VS.Get(), nullptr, 0);
	CONTEXT->PSSetShader(g_PS.Get(), nullptr, 0);
	
	g_Mesh->render();
}
```

<aside>
â“ **ë°”ì¸ë”©(Binding)ì´ë€?**

DirectXì—ì„œ ë°”ì¸ë”©ì´ë¼ëŠ” ìš©ì–´ëŠ” GPUì˜ íŒŒì´í”„ë¼ì¸ì— ìì›(ë²„í¼, í…ìŠ¤ì³, ì‰ì´ë”) ë“±ì„ í• ë‹¹í•˜ê³  ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ ì„¤ì •í•˜ëŠ” ê³¼ì •ì„ ì˜ë¯¸í•œë‹¤!
CPUì—ì„œ ìƒì„±í•˜ê³  ì„¤ì •í•œ ìì›ì„ GPUì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì¤€ë¹„í•˜ëŠ” ì‘ì—…ì— ì ìš©ë˜ê³ , ì´ ë°”ì¸ë”© ê³¼ì •ì„ í†µí•´ì„œ ê·¸ë˜í”½ íŒŒì´í”„ë¼ì¸ì´ ë°ì´í„°ë¥¼ ì½ê³  ì“°ë©°, ë Œë”ë§ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤

</aside>

### ìƒìˆ˜ ë²„í¼(Constant Buffer)ì˜ í´ë˜ìŠ¤í™”

ì•ìœ¼ë¡œ ìƒìˆ˜ë²„í¼ëŠ” Device ìª½ì—ì„œ í´ë˜ìŠ¤ë¡œ ì œì‘í•´ ê´€ë¦¬í•´ì¤„ ê²ƒì´ë‹¤!

**ìƒìˆ˜ ë²„í¼ë¥¼ ìš©ë„ì— ë”°ë¼ ë¶„ë¥˜í•˜ë„ë¡ enumìœ¼ë¡œ íƒ€ì…ì„ ì œì‘í•˜ì**

```cpp
enum class CB_TYPE
{
	TRANSFORM,
	MATERIAL,
	GLOBAL,
	END,
}
```

**Constant Bufferë¥¼ í´ë˜ìŠ¤ë¡œ ì‘ì„±**

```cpp
class CConstBuffer :
	public CEntity
{
private:
	ComPtr<ID3D11Buffer>  m_CB;
	D3D11_BUFFER_DESC     m_Desc;
	CB_TYPE               m_CBType;         // CBì˜ Typeì´ì, ë ˆì§€ìŠ¤í„° ë²ˆí˜¸ì´ê¸°ë„ í•˜ë‹¤
	
public:                                               
	int Create(CB_TYPE _type, UINT _BufferSize);
	
	void SetData(void* _pData);
	void Binding();
	
	virtual CConstBuffer* Clone() { return nullptr; }
	
public:
	CConstBuffer();
	~CConstBuffer();
}

```

```cpp
#include "pch.h"
#include "CConstBuffer.h"

#include "CDevice.h"

CConstBuffer::CConstBuffer()
	: m_Desc{}
{
}

CConstBuffer::~CConstBuffer()
{
}

int CConstBuffer::Create(CB_TYPE _type, UINT _BufferSize)
{
	// ...
}

void CConstBuffer::SetData(void* _pData)
{
	// ...
}

void CConstBuffer::Binding()
{
	// ...
}
```

ê° í•¨ìˆ˜ì˜ êµ¬í˜„ ë¶€ë¶„ì€ ë‚˜ëˆ ì„œ ë” ìì„¸íˆ ë³´ë„ë¡ í•˜ì!

**ìƒìˆ˜ ë²„í¼ì˜ Create()**

```cpp
int CCostBuffer::Create(CB_TYPE _type, UINT _BufferSize)
{
	m_CBType = _type;
	
	// D3D11_BUFFER_DESC ì„¤ì •!
	m_Desc.ByteWidth = _BufferSize;
	m_Desc.Usage = D3D11_USAGE_DYNAMIC;
	m_Desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	m_Desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	
	if (FAILED(DEVICE->CreateBuffer(&m_Desc, nullptr, m_CB.GetAddressOf())))
	{
		return E_FAIL;
	}
	return S_OK;
}
```

**ìƒìˆ˜ ë²„í¼ë¥¼ í†µí•´ Map/Unmapí•  ë°ì´í„°ë¥¼ ë„£ëŠ” SetData()**

```cpp
void CConstBuffer::SetData(void* _pData)
{
	D3D11_MAPPED_SUBRESOURCE tMapSub = {};
	CONTEXT->Map(m_CB.Get(), 0, D3D11_Map::D3D11_MAP_WRITE_DISCARD, 0, &tMapSub);
	memcpy(tMapSub.pData, _pData, m_D3sc.ByteWidth);
	CONTEXT->Unmap(m_CB.Get(), 0);
}
```

**ìƒìˆ˜ ë²„í¼ë¥¼ ë°”ì¸ë”© â†’ Binding()**

```cpp
void CConstBuffer::Binding()
{
	CONTEXT->VSSetConstantBuffers((UINT)m_CBType, 1, m_CB.GetAddressOf());
}
```

ì´ì œ ìƒìˆ˜ ë²„í¼ë¥¼ ê°ì²´ë¡œ ì œì‘í•´ì„œ, ì ìš©í•´ë³´ì

```cpp
// ì „ë°© ì„ ì–¸
class CConstBuffer;

class CDevice
	: public CSingleton<CDevice>

{
	SINGLE(CDeivce);
private:
	// ...
	CConstBuffer*     m_arrCB[(UINT)CB_TYPE::END];
	
public:
	// ...
	// Init, Clear, Present

private:
	// ...
	int CreateConstBuffer();
	
public:
	// ...
	CConstBuffer* GetConstBuffer(CB_TYPE _Type) { return m_arrCB[(UINT)_Type]; }
};
```

`ConstBuffer` ë°°ì—´ì´ Devcieì˜ ë©¤ë²„ë¡œ ì¶”ê°€ë˜ë©´ì„œ Deviceì˜ ìƒì„±ìì™€ ì†Œë©¸ìì—ëŠ” ì¡°ê¸ˆì˜ ë³€í™”ê°€ ìƒê²¼ë‹¤!

```cpp
#include "pch.h"
#include "CDevice.h"

#include "CConstBuffer.h"

CDevice::CDevice()
	: m_hWnd(nullptr)
	, m_arrCB{}
{
}

CDevice::~CDevice()
{
	// Constant Buffer í•´ì œ
	for (UINT i = 0; i < (UINT)CB_TYPE::END; ++i)
	{
		if (m_arrCB[i] != nullptr)
			delete m_arrCB[i];
	}
}
```

ê·¸ë¦¬ê³  Device ë‚´ì—ì„œ ìƒìˆ˜ ë²„í¼ë¥¼ Create í•˜ëŠ” í•¨ìˆ˜ë¥¼ í†µí•´ â†’ `CreateConstBuffer()`

í˜„ì¬ **Deviceì˜ ìƒìˆ˜ ë²„í¼ ë°°ì—´ì—, íƒ€ì…ì— ë§ëŠ” ìƒˆë¡œìš´ ìƒìˆ˜ ë²„í¼ë¥¼ í• ë‹¹**í•œë‹¤

```cpp
int CDevice::CreateConstBuffer()
{
	CConstBuffer* pCB = nullptr;
	
	// ìƒìˆ˜ ë²„í¼ ì„¤ì •
	pCB = new CConstBuffer;
	if(FAILED(pCB->Create(CB_TYPE::TRANSFORM, sizeof(tTransform)))
	{
		MessageBox(nullptr, L"ìƒìˆ˜ë²„í¼ ìƒì„± ì‹¤íŒ¨", L"ì´ˆê¸°í™” ì‹¤íŒ¨", MB_OK);
		return E_FAIL;
	}
	
	m_arrCB[(UINT)CB_TYPE::TRANSFORM] = pCB;
	
	return S_OK;
}
```

ê·¸ë¦¬ê³  ìƒìˆ˜ ë²„í¼ì˜ ìƒì„± ë‹¨ê³„ëŠ” Deviceì˜ ì´ˆê¸°í™”(Init) ê³¼ì •ì—ì„œ í•¨ê»˜ ì‹œí–‰ëœë‹¤

```cpp
int CDevice::Init(HWND _hWnd, UINT _Width, UINT _Height)
{
	// ìœˆë„ìš° í•¸ë“¤ ë° í•´ìƒë„ ê°’ ì €ì¥
	// Device, COntext ìƒì„±
	// Swap Chain ìƒì„±
	// View ìƒì„±
	// OMS ì„¤ì •
	// Viewport ì„¤ì •
	
	// ìƒìˆ˜ ë²„í¼ ìƒì„±
	if (FAILED(CreateConstBuffer())
	{
		MessageBox(nullptr, L"ìƒìˆ˜ë²„í¼ ìƒì„± ì‹¤íŒ¨", L"ì¥ì¹˜ ì´ˆê¸°í™” ì‹¤íŒ¨", MB_OK);
		return E_FAIL;
	}
	
	return S_OK;
}
```

ê·¸ë¦¬ê³ , ì´ë ‡ê²Œ Deviceì— ìƒì„±ë˜ì–´ ìˆëŠ” ìƒìˆ˜ ë²„í¼ë¥¼ ê°€ì ¸ì™€ Tempì—ì„œ ë³€ê²½í•  ë°ì´í„°ë¥¼ ì ìš©í•´ Render ì‹œì— ë°”ì¸ë”©í•  ìˆ˜ ìˆë‹¤

```cpp
void TempTick()
{
	// DT ì„¤ì •
	// í‚¤ë³´ë“œë¡œ ì¢Œí‘œ ì´ë™
	// ...
	
	CConstBuffer* pTransformCB = Device::GetInst()->GetConstBuffer(CB_TYPE::TRANSFORM);
	pTransformCB->SetData(&g_ObjTrans);
}
```

```cpp
void TempRender()
{
	CConstBuffer* pTransformCB = CDeivce::GetInst()->GetConstBuffer(CB_TYPE::TRANSFORM);
	pTransfromCB->Binding();
}
```

### Shaderë„ ì¼ì¢…ì˜ ì—ì…‹ì´ë‹¤! Shaderë¥¼ Assetí™”í•˜ê¸°

ShaderëŠ” GPUë¥¼ ì‚¬ìš©í•´ ë‹¤ì–‘í•œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ì§€ë§Œ, ê·¸ ëª©ì ê³¼ ì‚¬ìš© ë°©ë²•ì— ìˆì–´ì„œ ëª‡ ê°€ì§€ ì°¨ì´ì ì´ ìˆë‹¤!

ë¨¼ì € Graphic  Shaderì™€ Compute Shaderë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆëŠ”ë°,

> Grpahic Shader (ê·¸ë˜í”½ ì‰ì´ë”)
> 
- ì£¼ë¡œ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì˜ ì¼ë¶€ë¡œ, 3D ê·¸ë˜í”½ì„ í™”ë©´ì— ê·¸ë¦¬ëŠ”ë° ì‚¬ìš©
- Vertex, Pixel, Geometry, Hull, Domain ìœ¼ë¡œ ë” ì„¸ë¶„í™”ë˜ì–´ êµ¬ë¶„ë¨
- ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì— ë”± ë§ê²Œ ìµœì í™”ë˜ì–´ ìˆê³ , ê·¸ë˜í”½ ì—°ì‚°ì— íŠ¹í™”ë˜ì–´ ìˆìŒ

> Comput Shader(ì»´í“¨íŠ¸ ì‰ì´ë”)
> 
- DirectX11ë¶€í„° ë„ì…ëœ ê¸°ëŠ¥ìœ¼ë¡œ, ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ë³‘ë ¬ ë°ì´í„° ì²˜ë¦¬ì— ì‚¬ìš© (ê·¸ë˜í”½ íŒŒì´í”„ë¼ì¸ê³¼ ë…ë¦½ì )
- GPUì˜ ê³„ì‚° ëŠ¥ë ¥ì„ í™œìš©í•´ ê³¼í•™ì  ê³„ì‚°, ì´ë¯¸ì§€ ì²˜ë¦¬, ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ê³¼ ê°™ì€ ë¹„ê·¸ë˜í”½ì  Taskë¥¼ ìˆ˜í–‰
- ê·¸ë˜í”½ ì‰ì´ë”ë³´ë‹¤ ë©”ëª¨ë¦¬ ìì›ì— ëŒ€í•œ ì ‘ê·¼ì´ ë” ìœ ì—°í•˜ê³ , ë³µì¡í•œ ë°ì´í„° êµ¬ì¡° + ì•Œê³ ë¦¬ì¦˜ ì²˜ë¦¬ ê°€ëŠ¥

ì´ë ‡ê²Œ ìš©ë„ê°€ ë‹¤ë¥¸ ë‘ ì‰ì´ë”ë¥¼ Assetìœ¼ë¡œ êµ¬í˜„í•´ ë³¼ ê²ƒì´ë‹¤

ë”°ë¼ì„œ, ì´ ë‘ ì‰ì´ë”ì˜ ê¸°ë°˜ì´ ë˜ëŠ” Shaderë¼ëŠ” ì¤‘ê°„ ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•´ë³´ì!

**Shaderë“¤ì˜ ê¸°ë°˜ì´ ë˜ëŠ” í´ë˜ìŠ¤ â†’ CShader**

```cpp
class CShader :
	public CAsset
{
protected:
	ComPtr<ID3DBlob> m_ErrBlob;        // ì—ëŸ¬ ë¸”ë¡­
	
public:
	CShader(ASSET_TYPE _Type);
	~CShader();
};
```

```cpp
#include "pch.h"
#include "CShader.h"

CShader::CShader(ASSET_TYPE _Type)
	: CAsset(_Type)
{
}

CShader::~CShader()
{
}
```

**ê·¸ë˜í”½ ì‰ì´ë” ì œì‘ â†’ CGraphicShader()** 

```cpp
class CGraphicShader :
 public CShader
{
private:
	ComPtr<ID3DBlob>                m_VSBlob;
	ComPtr<ID3DBlob>                m_PSBlob;
	
	ComPtr<ID3D11VertexShader>       m_VS;
	ComPtr<ID3D11PixelShader>        m_PS;
	
	ComPtr<ID3D11InputLayout>        m_Layout;

	D3D11_PRIMITVIE_TOPOLOGY         m_Topology;

public:
	int CreateVertexShader(const wstring& _RelativePath, const string* _FuncName);
	int CreatePixelShader(const wstring& _RelativePath, const string* _FuncName);

	virtual void Binding() override;

public:
	CGraphicShader();
	~CGraphicShader();
}
```

```cpp
#include "pch.h"
#include "CGraphicShader.h"
#include "CDevice.h"
#include "CPathMgr.h"

CGraphicShader::CGraphicShader()
	: CShader(ASSET_TYPE::GRAPHIC_SHADER)
	, m_Topology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST)
{
}

CGraphicShader::~CGraphicShader()
{
}

int CGraphicShader::CreateVertexShader(const wstring& _RelativePath, const string& _FuncName)
{
	// ...
}

int CGraphicShader::CreatePixelShader(const wstring& _RelativePath, const string& _FuncName)
{
	// ...
}

void CGraphicShader::Binding()
{
	// ...
}
```

- Topology ì •ë³´ë¥¼ ì‰ì´ë” ë©¤ë²„ì˜ ë³€ìˆ˜ë¡œ ë§Œë“¤ì–´, ìƒì„±ìì—ì„œ ê¸°ë³¸ê°’ìœ¼ë¡œ TRIANGLE_LISTë¡œ ì´ˆê¸°í™”í•´ì¤¬ë‹¤!
    
    â†’ Binding í•  ë•Œì— í•´ë‹¹ Shaderì˜ ë©¤ë²„ë¡œ ë“¤ê³  ìˆëŠ” Topologyë¡œ ì„¸íŒ…ë˜ê²Œë”
    
- Layoutë¥¼ ì‰ì´ë” ë©¤ë²„ì˜ ë³€ìˆ˜ë¡œ ë§Œë“¤ì–´, Vertex Shaderê°€ Createë  ë•Œ Layoutë„ ê°™ì´ ìƒì„±ë  ìˆ˜ ìˆë„ë¡ ì‘ì„±í•´ ì¤„ ì˜ˆì •!

ê°ìì˜ í•¨ìˆ˜ë“¤ì„ ìì„¸íˆ ì‚´í´ë³´ì!

**Vertex Shaderë¥¼ ìƒì„± (+ Layoutë„!) â†’ CreateVertexShader()** 

```cpp
int CGraphicShader::CreateVertexShader(const wstring& _RelativePath, const string& _FuncName)
{
	wstring strFilePath = CPathMgr::GetInst()->GetContentPath();
	strFilePath += _RelativePath;
	
	HRESULT hr = D3DCompileFromFile(strFilePath.c_str(), nullptr
									, D3D_COMPILE_STANDARD_FILE_INCLUDE
								  , _FuncName.c_str(), "vs_5_0", D3DCOMPILE_DEBUG, 0
								  , m_VSBlob.GetAddressOf(), m_ErrBlob.GetAddressOf());

	if (FAILED(hr))
	{
		if (nullptr != m_ErrBlob)
		{
			MessageBoxA(nullptr, (char*)m_ErrBlob->GetBufferPointer(), "ì‰ì´ë” ì»´íŒŒì¼ ì‹¤íŒ¨", MB_OK);
		}
		else
		{
			errno_t err = GetLastError();
			wchar_t szErrMsg[255] = {};
			swprintf_s(szErrMsg, 255, L"Error Code : %d", err);
			MessageBox(nullptr, szErrMsg, L"ì‰ì´ë” ì»´íŒŒì¼ ì‹¤íŒ¨", MB_OK);
		}

		return E_FAIL;
	}
	
	DEVICE->CreateVertexShader(m_VSBlob->GetBufferPointer()
							 , m_VSBlob->GetBufferSize(), nullptr, m_VS.GetAddressOf());

	// Layout ìƒì„±
	D3D11_INPUT_ELEMENT_DESC Element[2] = {};

	Element[0].AlignedByteOffset = 0;
	Element[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	Element[0].InputSlot = 0;
	Element[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	Element[0].InstanceDataStepRate = 0;
	Element[0].SemanticName = "POSITION";
	Element[0].SemanticIndex = 0;

	Element[1].AlignedByteOffset = 12;
	Element[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	Element[1].InputSlot = 0;
	Element[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	Element[1].InstanceDataStepRate = 0;
	Element[1].SemanticName = "COLOR";
	Element[1].SemanticIndex = 0;

	DEVICE->CreateInputLayout(Element, 2
							, m_VSBlob->GetBufferPointer()
							, m_VSBlob->GetBufferSize()
							, m_Layout.GetAddressOf());

	return S_OK;
}
```

**Pixel Shaderë¥¼ ìƒì„± â†’ CreatePixelShader()**

```cpp
int CGraphicShader::CreatePixelShader(const wstring& _RelativePath, const string& _FuncName)
{
	wstring strFilePath = CPathMgr::GetInst()->GetContentPath();
	strFilePath += _RelativePath;
	
	HRESULT hr = D3DCompileFromFile(strFilePath.c_str(), nullptr
		, D3D_COMPILE_STANDARD_FILE_INCLUDE
		, _FuncName.c_str(), "ps_5_0", D3DCOMPILE_DEBUG, 0
		, m_PSBlob.GetAddressOf(), m_ErrBlob.GetAddressOf());

	if (FAILED(hr))
	{
		if (nullptr != m_ErrBlob)
		{
			MessageBoxA(nullptr, (char*)m_ErrBlob->GetBufferPointer(), "ì‰ì´ë” ì»´íŒŒì¼ ì‹¤íŒ¨", MB_OK);
		}
		else
		{
			errno_t err = GetLastError();
			wchar_t szErrMsg[255] = {};
			swprintf_s(szErrMsg, 255, L"Error Code : %d", err);
			MessageBox(nullptr, szErrMsg, L"ì‰ì´ë” ì»´íŒŒì¼ ì‹¤íŒ¨", MB_OK);
		}

		return E_FAIL;
	}

	DEVICE->CreatePixelShader(m_PSBlob->GetBufferPointer()
						    , m_PSBlob->GetBufferSize(), nullptr, m_PS.GetAddressOf());

	return S_OK;
}
```

```cpp
void CGraphicShader::Binding()
{
	// Topolgy, Layout ì„¸íŒ…
	CONTEXT->IASetPrimitiveTopology(m_Topology);
	CONTEXT->IASetInputLayout(m_Layout.Get());

	// Shader ì„¸íŒ…
	CONTEXT->VSSetShader(m_VS.Get(), nullptr, 0);
	CONTEXT->PSSetShader(m_PS.Get(), nullptr, 0);	
}
```

ê·¸ë¦¬ê³  Tempì˜ Initì—ì„œëŠ” Graphic Shader ê°ì²´ì™€ í•¨ê»˜ Vertex Shader, Pixel Shaderë¥¼ ìƒì„±í•´ì¤˜ì•¼ í•œë‹¤

```cpp
int TempInit()
{
	// ...
	// Vertex Buffer ìƒì„±
	// Index Buffer ìƒì„±
	// Rect Mesh ìƒì„±
	// ...
	// Graphic Shader ìƒì„±
	g_Shader = new CGraphicShader;
	g_Shader->CreateVertexShader(L"shader\\test.fx", "VS_Test");
	g_Shader->CreatePixelShader(L"shader\\test.fx", "PS_Test");
}

```

ì´ë¡œì¨ Tempì—ì„œ ì§ì ‘ ì‘ì„±í–ˆë˜

- Const Buffer ìƒì„± â†’ í´ë˜ìŠ¤í™”í•´ ê°ì²´ë¡œ ìƒì„±í•´ì¤¬ìœ¼ë©°
- Vertex Shader ìƒì„± â†’ Graphic Shaderì˜ ë©¤ë²„ë¡œ ìƒì„±
- Pixel Shader ìƒì„± â†’ Graphic Shaderì˜ ë©¤ë²„ë¡œ ìƒì„±
- Layout ìƒì„± â†’ Vertex Shader ìƒì„±ì‹œ í¬í•¨

í•¨ìœ¼ë¡œì¨, Tempì˜ Initì—ì„œ ì´ë“¤ì„ ìƒì„±í–ˆë˜ ì‘ì—…ë“¤ì€ ìƒëµí•  ìˆ˜ ìˆê²Œ ë˜ì—ˆ