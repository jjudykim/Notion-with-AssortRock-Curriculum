# 2024/01/16 - 추상화와 가상함수의 주의점

태그: C++, 중급
날짜: 2024/01/16
상위 항목: Week8 (Week8%2097066e5626ef4fb4ac1b17db8d09a64b.md)
주차: 0001_Week1~9

부모 클래스 포인터 타입으로 자식 클래스 객체의 주소를 가리킨 경우, ex) `Parent *p = &c;` 가상함수로 선언된 함수일 경우엔 테이블에 등록된 함수를 호출하기 때문에, 각 클래스에서 오버라이딩한 원래 버전을 사용할 수 있지만 순수하게 자식클래스부터 구현된 함수는 부모 클래스 포인터로 알 수가 없다

해결 방안 : 다운 캐스팅(down-casting)

1. 강제 캐스팅
    
    : `Child`로 강제 캐스팅 → `((Child*)pParent)` 
    
    부모 클래스 포인터에 저장된 주소가 특정 자식 클래스 객체임이 확실하다면, 해당 자식 클래스 포인터 타입으로 강제로 캐스팅해서, 실제 그 객체를 온전히 접근하는 방법
    
    → 확실한 상황일때만 사용 가능, 만약 의도한 방향이 아니라면 결과가 완전히 달라진다
    

1. **RTTI** (Runtime Type Information / Identification ) )
    
    → 동적 형변환 (dynamic_cast)
    
    ```cpp
    Child* pChild = dynamic_cast<Child*>(pParent);
    
    if (pChild != nullptr)
    {
    	pChild->SetChild(100);
    }
    ```
    
    - 해당 클래스 안에 가상함수가 하나 이상 있었어야 한다! RTTI(타입 정보)가 만들어졌어야 사용할 수 있었기 때문에

+) RTTI 확인해보기

`#include <typeinfo>`

```cpp
const type_info& info = typeid(p);
cout << info.name() << endl;
cout << info.hash_code() << endl;
```

<aside>
⭐ 부모의 가상함수를 재정의한 자식클래스의 가상함수 키워드에도 virtual 붙여주기

```cpp
virtual void derivedFunction()
{
}
```

</aside>

<aside>
⭐ “자식클래스에서 새롭게 생겨난” 가상함수에는 뒤에 override를 붙이지 않고, 부모의 가상함수를 재정의한 함수라면 override 붙여주기

```cpp
virtual void derivedFunction() override
{
}

// 자식 클래스에서 새롭게 만드는 가상함수일 경우 override를 붙이지 않는다
virtual void grandDerivedFunction()
{
}
```

</aside>

### 추상화

<aside>
📝 추상화에 대해 알아보기 전에, 간단하게 상속과 다형성 복습하고 가기!

**1) 상속**
: 부모 클래스의 기능을 물려받음, 코드의 재사용성을 올려줌, 오버라이딩을 통해 부모클래스의 기능을 재정의할 수 있음

**2) 다형성**
: 부모 클래스 포인터 타입으로, 파생되는 모든 자식 클래스 객체들의 주소를 가리킬 수 있다
> `virtual` (**가상함수**) : 각 클래스마다 타입정보를 생성하고, 주소들만 모아두는 테이블(가상함수 테이블)에 적혀있는 주소를 참조해서 실행
> 자식 클래스에서부터 추가된 함수에 대한 접근은 **다운 캐스팅**을 통해 → 1) 강제 캐스팅, 2) 동적 형변환(dynamic_cast)

</aside>

**추상화,** 추상 클래스 (Abstract Class)

: 클래스를 설계할 때 **중요한 특징과 기능을 강조**하고, 

불필요한 세부사항을 숨겨 *사용자에게 간단하고 직관적인 인터페이스를 제공하는 프로세스*

**상속을 목적**으로, 파생되는 자식 클래스들의 공통분모 역할을 하는 클래스를 추상 클래스라고 한

구체성이 없기 때문에, 해당 클래스로 객체가 생성되는 것을 방지해야 함

```cpp
class Animal
{
public:
	// 순수 가상함수
	virtual void Eat = 0;

	virtual void Move()
	{
		cout << "Move" << endl;
	}
};

class Bird
	: public Animal
{
public:
	virtual void Move() override
	{
		cout << "Fly" << endl;
	}
};

class Eagle
	: public Bird
{
public:
	// Move 함수 재정의 X
};

int main()
{
	Animal animal;
	Bird bird;
	Eagel eagle;
}
```

**순수 가상함수(Pure Virtual Function)**이 정의되어 있는 클래스는 추상 클래스로 취급한다

→ 객체 생성이 불가능해짐!

- 순수 가상함수의 목적
    - 해당 클래스를 추상클래스로 만든다 (객체 생성을 불가능케 함, 구체성이 없으니)
    - 인터페이스를 제시 (실제로 사용되기 위해서 구현해야할 목록을 제시)
- Animal을 상속받는 클래스들은 모든 자식 클래스들은 추상 클래스를 벗어나기 위해 순수 가상함수를 구현해야 한다

**순수 가상함수의 선언 방법**

```cpp
virtual void func() = 0;
```

→ 바디(구현부) 없이 함수의 프로토타입(선언부)만 있으며, 끝에 `= 0` 붙여주기

다형성으로 동적 할당한 클래스의 소멸자 호출 시 발생할 수 있는 문제 

→ 부모 소멸자가 먼저 호출된다!

해결방안 : virtual **가상 소멸자** 개념 사용

```cpp
Parent* pParent = new Child;
delete pParent;               // Parent 타입의 소멸자가 호출된다
```

이렇게 부모(특히 최상위 부모)의 소멸자를 가상함수로 구현해주면, 

자식 클래스 소멸자 먼저 호출된다

```cpp
virtual ~Parent()
{
}
```

따라서 상속할때에는 ***최상위 부모의 소멸자를 가상함수로 구현***해야 한다…

### 총 정리 - 가상함수 사용 시 주의점

1. 상속 과정에서 부모클래스의 가상함수를 오버라이딩 한 경우, 
    - virtual 키워드를 붙이지 않아도 되긴 하지만..
        
        → 일반 멤버함수와의 구별을 위해서 `virtual` 키워드를 붙이는 것이 좋다!
        
2. 부모 클래스의 가상함수를 오버라이딩한 경우와, 새로 해당 클래스에서 구현한 가상함수를 구별하기 위해 오버라이딩한 함수 뒤에 `override` 키워드를 붙인다!
    
    부모의 가상함수를 오버라이딩한 것인지, 새로 구현된 가상함수인지 구별해주는 것이 가독성이 좋다. (override 한 함수인지, 아닌지)
    
3. 상속구조의 클래스를 동적할당 할 경우, 다형성을 위해서 부모 포인터로 자식 객체의 주소를 받는 경우에 이때 객체를 소멸할 때에 **부모 타입의 포인터로 delete를 요청**하기 때문에, 소멸자의 올바른 호출을 위해서 virtual 키워드를 붙여 가상 소멸자로 만들고, 자식클래스에서 재정의된 소멸자들이 호출되게끔 한다
    
    <aside>
    ⭐ 상속구조를 설계할 때는 최상위 부모 클래스의 소멸자에 `virtual` 키워드를 붙이는 것을 반드시 잊지 말기! (가상 소멸자로 만들기)
    
    </aside>