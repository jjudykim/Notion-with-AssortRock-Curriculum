# 2024/07/09 -

ìƒìœ„ í•­ëª©: Week33 (https://www.notion.so/Week33-c25c856dcd954fe0af5f24db92f6af83?pvs=21)
ìƒíƒœ: ë©”ëª¨
ì£¼ì°¨: 0100_Week30~39

> 1êµì‹œ ë…¹ìŒë³¸ 
- [https://clovanote.naver.com/s/i8dxSz8UWY4DxYJXgzvrwYS](https://clovanote.naver.com/s/i8dxSz8UWY4DxYJXgzvrwYS)

2êµì‹œ ë…¹ìŒë³¸ 
- [https://clovanote.naver.com/s/KvPySK822cEj4tSUAmqoZjS](https://clovanote.naver.com/s/KvPySK822cEj4tSUAmqoZjS)
> 

## Drag & Dropìœ¼ë¡œ ê³„ì¸µ ê´€ê³„ ê°±ì‹ í•˜ê¸°

### Drop ë…¸ë“œë¥¼ ì§€ì •í•˜ì§€ ì•Šê³ , ë°”ê¹¥ì— ë†”ë²„ë¦¬ë©´ì„œ ê³„ì¸µ ê´€ê³„ë¥¼ íƒˆì¶œí•´ë³´ì

ìì‹ìœ¼ë¡œ í¬í•¨ë˜ì–´ ìˆëŠ” ë…¸ë“œê°€ ìì‹ ì˜ ë¶€ëª¨ ë…¸ë“œì˜ Tree êµ¬ì¡° ë‚´ì—ì„œ ë°”ê¹¥ìœ¼ë¡œ, ì¦‰ ì•„ë¬´ê²ƒë„ ì—†ëŠ” ê³³ìœ¼ë¡œ Drag & Drop ëœë‹¤ë©´? 

â†’ 1) í•´ë‹¹ ìì‹ ë…¸ë“œì˜ ê³„ì¸µ êµ¬ì¡°ê°€ ëª¨ë‘ í•´ì œë˜ê³ , 2) í•´ë‹¹ ë…¸ë“œê°€ ìµœìƒìœ„ ë¶€ëª¨ ë…¸ë“œê°€ ë˜ê²Œë” ë³€ê²½í•´ íŠ¸ë¦¬ê°€ ê°±ì‹ ë˜ë„ë¡, ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¶”ê°€í•´ë³´ì

ì´ë¥¼ ì •ë¦¬í•´ë³´ìë©´, ì–´ëŠ ë¶€ëª¨ ë…¸ë“œì— í¬í•¨ë˜ì–´ ìˆëŠ” ë…¸ë“œê°€ Dragëœ í›„ - Drop Check ì‹œì— *Dropëœ ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°*ì´ë¯€ë¡œ í•´ë‹¹ ê²½ìš°ì— ëŒ€í•œ ë¶„ê¸°ë¥¼ ì„¤ì •í•´ì£¼ì

ê¸°ì¡´ì—ëŠ” ë§ˆìš°ìŠ¤ê°€ ë¦´ë¦¬ì¦ˆ ë˜ë©´ì„œ, ë“œë˜ê·¸ëœ ë…¸ë“œ(m_DraggedNode)ì™€ ë“œëëœ ë…¸ë“œ(m_DroppedNode)ë¥¼ nullptrë¡œ ë¹„ì›Œë²„ë¦°ë‹¤!

â†’ ì—¬íƒœê¹Œì§€ëŠ” ë‘˜ ë‹¤ nullptrì´ ì•„ë‹Œ ê²½ìš°ê°€ ì¼ë°˜ì ì´ì—ˆë‹¤! ì–´ëŠ í•œ ë…¸ë“œì—ì„œ â†’ í•œ ë…¸ë“œë¡œ Drag & Dropì„ í•˜ëŠ” ê²½ìš°ë§Œì„ ì‘ì„±í–ˆì—ˆê¸° ë•Œë¬¸ì—.

ê·¸ëŸ°ë° ì´ë•Œ, ë“œë˜ê·¸ëœ ë…¸ë“œëŠ” ì¡´ì¬í•˜ëŠ” ë°˜ë©´ ë“œëëœ ë…¸ë“œê°€ nullptrì´ì—ˆë‹¤ë©´?

â†’ ì´ ê²½ìš°ê°€ ë°”ë¡œ Drag & Drop ì‹œ ê³„ì¸µ ê´€ê³„ë¥¼ íƒˆì¶œí•˜ë„ë¡ ë‚´ë¶€ì—ì„œ ë°–ìœ¼ë¡œ êº¼ë‚´ëŠ” ê²½ìš°

ë”°ë¼ì„œ í•´ë‹¹ ë¶„ê¸°ì— ëŒ€í•œ ì²˜ë¦¬ë¥¼ ì‘ì„±í•´ì£¼ì

**TreeUIê°€ Update ë  ë•Œ, Dragëœ ë…¸ë“œëŠ” ì¡´ì¬í•˜ì§€ë§Œ Dropëœ ë…¸ë“œëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°**

```cpp
void TreeUI::Update()
{
	// ...
	
	if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
	{
		// ë“œë˜ê·¸í•œ ë…¸ë“œëŠ” ì¡´ì¬í•˜ì§€ë§Œ, ë°›ëŠ” ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš°
		if (m_DragedNode && ! m_DroppedNode)    
		{
			if (m_SelfDragDropInst && m_SelfDragDropFunc)
			{
				(m_SelfDragDropInst->*m_SelfDragDropFunc)((DWORD_PTR)m_DragNode, 0);
			}
		}
		m_DroppedNode = m_DragedNode = nullptr; 
	}
}
```

â†’ í•œ UI ë‚´ì— ì¡´ì¬í•˜ëŠ” ë…¸ë“œ ê°„ì˜ ìƒí˜¸ì‘ìš©ì´ë¯€ë¡œ, Self DragDropìœ¼ë¡œ ì²˜ë¦¬

ê·¸ë ‡ë‹¤ë©´ Outlinerì˜ ê²½ìš°ì—ì„œ, Self Drag&Dropì´ ì¼ì–´ë‚  ë•Œ Delegateë¡œ í˜¸ì¶œë˜ëŠ” GameObjectAddChild í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì

ì—¬ê¸°ì„œ ì „ë‹¬ë˜ëŠ” íŒŒë¼ë¯¸í„°ëŠ” ê°ê° Drag Node, Drop Nodeë¥¼ ì˜ë¯¸í•˜ëŠ”ë°, ë§Œì•½ ìš°ë¦¬ê°€ ë°©ê¸ˆ ìƒì„±í•œ ê²½ìš°ì˜ ìˆ˜ì¸ *Drag NodeëŠ” ì¡´ì¬í•˜ì§€ë§Œ Drop Nodeê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°*ê°€ ì „ë‹¬ëœë‹¤ë©´, Delegateì¸ ì´ í•¨ìˆ˜ì—ì„œë„ í•´ë‹¹ ë¶„ê¸°ì— ëŒ€í•œ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì ¸ì•¼ í•  ê²ƒì´ë‹¤

**GameObjectAddChild í•¨ìˆ˜ì—ì„œ Drag & Dropì˜ ê²½ìš°ì˜ ìˆ˜ì— ëŒ€í•œ ë¶„ê¸° ì²˜ë¦¬**

```cpp
void Outliner::GameObjectAddChild(DWORD_PTR _Param1, DWORD_PTR _Param2)
{
	TreeNode* pDragNode = (TreeNode*)_Param1;
	TreeNode* pDropNode = (TreeNode*)_Param2;
	
	CGameObject* pDragObject = (CGameObject*)pDragNode->GetData();
	CGameObject* pDropObject = nullptr;
	
	// 1) Drop ë…¸ë“œê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°
	// : Drag ì˜¤ë¸Œì íŠ¸ë¥¼ Drop ì˜¤ë¸Œì íŠ¸ì˜ ìì‹ìœ¼ë¡œ í¸ì…ì‹œí‚¨ë‹¤
	if(pDropNode)
	{
		pDropObject = (CGameObject*)pDropNode->GetData();
		pDropObject->AddChild(pDragObject);
	}
	
	// 2) Drop ë…¸ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°
	// : í˜„ì¬ ê³„ì¸µ ê´€ê³„ì˜ íƒˆì¶œ ì˜ë„ë¡œ ë³´ê³  í•´ë‹¹ Drag ì˜¤ë¸Œì íŠ¸ë¥¼ ìµœìƒìœ„ ë¶€ëª¨ë¡œ ë§Œë“¤ì–´ì¤€ë‹¤
	else
	{
		if (!pDragObject->GetParent())
			return;
		
		// í˜„ì¬ ë¶€ëª¨ ì˜¤ë¸Œì íŠ¸ì™€ì˜ ì—°ê²°ì„ í•´ì œí•˜ê³ ,
		pDragObject->DeregisterChild();
		
		// ë³¸ì¸ ì†Œì† ë ˆì´ì–´ì— ìµœìƒìœ„ ë¶€ëª¨ë¡œì„œ ì¬ë“±ë¡ì„ ì§„í–‰		
		CLevelMgr::GetInst()->GetCurrentLevel()->RegisterAsParent(pDragObject->GetLayerIdx(), pDragObject);
	}
	
	// íŠ¸ë¦¬ ë‚´ìš©ì„ ê°±ì‹ 
	RenewLevel();
}
```

- 
- ì´ë•Œ, `RegisterAsParent`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ìƒˆë¡œ ì œì‘í•´ì¤¬ë‹¤. ì´ì— ì£¼ëª©í•´ë³´ì!
    
    : í˜„ì¬ Drag Nodeì— í•´ë‹¹í•˜ëŠ” ì˜¤ë¸Œì íŠ¸ê°€ ìµœìƒìœ„ ë¶€ëª¨ê°€ ë˜ì—ˆê¸° ë•Œë¬¸ì—, í•´ë‹¹ Level Managerê°€ ê´€ë¦¬í•˜ëŠ” Level â†’ Layerì— ì†Œì†ëœ Parent Objectì— í¬í•¨ë˜ì–´ì•¼ í•œë‹¤ (ìš°ë¦¬ëŠ” Layerë§ˆë‹¤ ì†Œì†ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ Parent Object, ëª¨ë“  Object ì´ë ‡ê²Œ ë‹´ê³  ê´€ë¦¬í•˜ê³  ìˆì—ˆë‹¤)
    
    ìš°ë¦¬ê°€ Layerì— Objectë¥¼ Addí•˜ê¸° ìœ„í•´ì„œëŠ” 
    
    1) ì˜¤ë¸Œì íŠ¸ê°€ ë‹¤ë¥¸ ë ˆì´ì–´ ì†Œì†ì´ê±°ë‚˜ 
    
    2) ì˜¤ë¸Œì íŠ¸ê°€ ì–´ëŠ ë ˆì´ì–´ì—ë„ ì†Œì†í•˜ì§€ ì•Šì„ ë•Œ ì— í•´ë‹¹ë˜ì–´ì•¼ í•œë‹¤
    
    í•˜ì§€ë§Œ í•´ë‹¹ ì˜¤ë¸Œì íŠ¸ëŠ” ì´ë¯¸ ë³¸ì¸ì´ ì†Œì†í•˜ê³  ìˆë˜ Layerê°€, ë“±ë¡í•˜ë ¤ëŠ” Layerì™€ ë™ì¼í•˜ê¸° ë•Œë¬¸ì— `AddObject`ë¥¼ í†µí•´ì„  ìƒˆë¡­ê²Œ ë“±ë¡í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œâ€¦
    
    ì¬ë“±ë¡í•˜ëŠ” ê³¼ì •ì˜ í•¨ìˆ˜ì¸ `RegisterAsParent`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì œì‘í•´,  ë‹¨, ì´ë¯¸ ë³¸ì¸ì´ ì†Œì†í•˜ê³  ìˆë˜ Layerê°€ ìˆì—ˆìœ¼ë¯€ë¡œ ì¬ë“±ë¡í•˜ëŠ” ê³¼ì •ì´ í•„ìš”í•˜ë‹¤
    

ë”°ë¼ì„œ `CLevel`, `CLayer` ìª½ì—ì„œ, ì›ë˜ ì´ Level, Layerì˜ ì†Œì†ì´ì§€ë§Œ ê³„ì¸µêµ¬ì¡°ê°€ ë³€ê²½ë˜ë©´ì„œ ì¬ë“±ë¡í•´ì•¼ í•˜ëŠ” ìƒí™©ì¼ ê²½ìš°ì— í˜¸ì¶œí•˜ê¸° ìš©ì´í•œ í•¨ìˆ˜ì¸ `RegisterAsParent`ë¥¼ ì‘ì„±í•´ë³´ì

**Layerì— ì†Œì†ëœ Objectë¥¼ ì¬ë“±ë¡í•˜ëŠ” í•¨ìˆ˜, RegisterAsParent**

```cpp
class CLevel :
	public CEntity
{
private:
	// ...

public:
	// ...
	void RegisterAsParent(int LayerIdx, CGameObject* _Object);
	// ...
}
```

```cpp
void CLevel::RegisterAsParent(int LayerIdx, CGameObject* _Object)
{
	m_Layer[LayerIdx]->RegisterAsParent(_Object);
}
```

**Level ë‹¨ìœ„ì—ì„œ í•´ë‹¹ Layerì— í˜¸ì¶œí•œ RegisterAsParent**

```cpp
class CLayer :
	public CEntity
{
private:
	// ...

public:
	// ...
	void RegisterAsParent(CGameObject* _Object);
	// ...
}
```

```cpp
void CLayer::RegisterAsParent(CGameObject* _Object)
{
	// assert ë˜ëŠ” ì¡°ê±´
	// 1) í˜„ì¬ Layerì™€ Objectì˜ Layer Indexê°€ ê°™ì§€ ì•Šì€ ê²½ìš°
	// 2) Objectì˜ ë¶€ëª¨ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš° (Objectê°€ ìµœìƒìœ„ ë¶€ëª¨ê°€ ì•„ë‹Œ ê²½ìš°)
	assert(_Object->GetLayerIdx() == m_LayerIdx && !_Object->GetParent());
	
	m_Parents.push_back(_Object);
}
```

### Tree UIë¡œ ê³„ì¸µ ê´€ê³„ ì„¤ì • ì‹œ, ë¶€ëª¨ê°€ ìì‹ ë…¸ë“œì˜ ìì‹ì´ ë  ìˆ˜ ì—†ë„ë¡ ë§‰ì•„ë³´ì

ë‹¤ìŒê³¼ ê°™ì€ ê³„ì¸µ êµ¬ì¡°ê°€ êµ¬ì„±ë˜ì–´ ìˆëŠ” Tree UIê°€ ìˆë‹¤ê³  ê°€ì •í•´ë³´ì

![Untitled](2024%2007%2009%20-%20ce0e896863a74df697efab8c0b6f2a40/Untitled.png)

ì´ë•Œ ë§Œì•½, Drag & Dropì„ ì´ìš©í•´ Point Lights ë…¸ë“œë¥¼ Drag í•´ì„œ Point Light Childë¡œ Drop ì‹œí‚¤ë©´ ì–´ë–»ê²Œ ë ê¹Œ?

ì¦‰, ë¶€ëª¨ê°€ ìì‹ ì˜ ìì‹ìœ¼ë¡œ ë“±ë¡ë˜ì–´ ìˆëŠ” ë…¸ë“œì— ìì‹ìœ¼ë¡œ ë“¤ì–´ê°€ë„ë¡ ëª…ë ¹í•œë‹¤ë©´?

â†’ ë¬´í•œì˜ êµ´ë ˆê°€ ëŒê²Œ ë˜ëŠ”.. ë§ì´ ì•ˆë˜ëŠ” ìƒí™©ì´ê¸° ë•Œë¬¸ì—!! 

í•´ë‹¹ ìƒí™©ì— ëŒ€í•œ ì˜ˆì™¸ë¥¼ ì„¤ì •í•´ ì²˜ë¦¬í•´ì£¼ë„ë¡ í•˜ì

ì´ë¥¼ ìœ„í•´ì„œ, ê°€ì¥ ë¨¼ì € Game Objectì—ì„œ, ì–´ë–¤ Objectê°€ ë³¸ì¸ì˜ ë¶€ëª¨(ë˜ëŠ” ì¡°ìƒ)ì¸ì§€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ í•˜ë‚˜ë¥¼ ë§Œë“¤ì–´ì£¼ì

**ì¸ìë¡œ ë“¤ì–´ì˜¨ Objectê°€ ë³¸ì¸ì˜ ì¡°ìƒì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜, IsAncestor**

```cpp
class CGameObject :
	public CEntity
{
private:
	// ...
	
public:
	// ...
	bool IsAncestor(CGameObject* _Object);
	
	// ...
};
```

```cpp
bool CGameObject::IsAncestor(CGameObject* _Object)
{
	CGameObject* pObject = m_Parent;
	
	// ë‚´ê°€ ë¶€ëª¨ ì˜¤ë¸Œì íŠ¸ê°€ ì¡´ì¬í•œë‹¤ë©´?
	while(pObject)
	{
		// ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¨ ì˜¤ë¸Œì íŠ¸ê°€ ë‚˜ì˜ ë¶€ëª¨ ì˜¤ë¸Œì íŠ¸ì™€ ë™ì¼í•œì§€ ë¹„êµ
		if (pObject == _Object)
			return true;
		else
			// ì¡°ìƒì„ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë„ë¡ Parent ë°›ì•„ì˜¤ê¸°..
			pObject = pObject->GetParent(); 
	}
	
	// ì¡°ìƒì„ ëª¨ë‘ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë„, ì¼ì¹˜í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ false
	return false; 
}
```

ê·¸ë ‡ë‹¤ë©´ ì´ë ‡ê²Œ ì œì‘í•œ `IsAncestor` í•¨ìˆ˜ë¥¼ í™œìš©í•´, Drag & Drop ì‹œì— í˜„ì¬ Dragë˜ëŠ” ë…¸ë“œê°€ Dropë˜ëŠ” ë…¸ë“œì˜ ë¶€ëª¨ëŠ” ì•„ë‹Œì§€ íŒë‹¨í•´ì•¼ í•œë‹¤!

â†’ ìì‹ìœ¼ë¡œ ë“¤ì–´ê°ˆ ì˜¤ë¸Œì íŠ¸ê°€ ë¶€ëª¨(ì¡°ìƒ) ì¤‘ í•˜ë‚˜ì˜€ë‹¤ë©´ ë¬´ì‹œí•˜ë„ë¡

```cpp
void Outliner::GameObjectAddChild(DWORD_PTR _Param1, DWORD_PTR _Param2)
{
	TreeNode* pDragNode = (TreeNode*)_Param1;
	TreeNode* pDropNode = (TreeNode*)_Param2;
	
	CGameObject* pDragObject = (CGameObject*)pDragNode->GetData();
	CGameObject* pDropObject = nullptr;
	
	if (pDropNode)
	{
		pDropObject = (CGameObject*) pDropNode->GetData();
		
		// ìì‹ìœ¼ë¡œ ë“¤ì–´ê°ˆ ì˜¤ë¸Œì íŠ¸ê°€ ë¶€ëª¨(ì¡°ìƒ) ì¤‘ í•˜ë‚˜ì˜€ë‹¤ë©´ ë¬´ì‹œ
		if (pDropObject->IsAncestor(pDragObject))
			return;
		
		pDropObject->AddChild(pDragObject);
	}
}
```

## Post Process (í›„ì²˜ë¦¬)

ëª¨ë“  ë Œë”ë§ì´ ë‹¤ ëë‚˜ê³  ë‚œ ë’¤ì— ì²˜ë¦¬ë˜ëŠ” ì‘ì—…

ìƒˆë¡œìš´ ì˜¤ë¸Œì íŠ¸ê°€ ë Œë”ë§ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ë§ˆë¬´ë¦¬ ì‘ì—…, ë¦¬í„°ì¹­ê°™ì€?

ê·¸ëŸ¼ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì„ í†µí•´ ì´ ì‘ì—…ì„ ì–´ë–»ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆì„ì§€..?

Render Managerì—ì„œ PostProcess ìš©ë„ì˜ í…ìŠ¤ì³ë¥¼ í•˜ë‚˜ ìƒì„±

```cpp
CRenderMgr
{
	Ptr<CTexture>    m_PostProcessTex;
}
```

```cpp
void CAssetMgr::CreateEngineTexture()
{
	Vec2 Resolution = CDevice::

	// PostProcess ìš©ë„ í…ìŠ¤ì³ ìƒì„±
	m_PostProcessTex = CAssetMgr::GetInst()->CreateTexture(L"PostProcessTexture"
	, (UINT)Resolution.x, (UINT)Resolution.y
	, DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_BIND_SHADER_RESOURCE);
}
```

```cpp
void CAssetMgr::Init()
{
	// Asset Managerê°€ ì´ˆê¸°í™”ë  ë•Œ ë§Œë“¤ì–´ë†“ì€, Post Processìš© í…ìŠ¤ì³ë¥¼ ì°¸ì¡°
	m_PostProcessTex = CAssetMgr::GetInst()->FindAsset<CTexture>(L"PostProcessTex");	
}
```

- í•´ìƒë„ëŠ” ë°˜ë“œì‹œ í˜„ì¬ Render Target Textureì™€ ë™ì¼í•´ì•¼ í•¨
- 

<aside>
ğŸ—’ï¸ [ì¶”ê°€ ì‚¬í•­]
Bind Flag ì¡°í•©ì— ëŒ€í•œ ì´ì•¼ê¸°

</aside>

ë³µì‚¬ â†’ í›„ì²˜ë¦¬ â†’ ë Œë”ë§ í•˜ëŠ” ì¼ë ¨ì˜ ê³¼ì •ì— ëŒ€í•´ì„œ ì •ë¦¬í•´ë³´ê¸°

```cpp
enum SHADER_DOMAIN
{
	// ...
	DOMAIN_POSTPROCESS,         // "í›„ì²˜ë¦¬ ë‹¨ê³„" ì¶”ê°€
	
	DOMAIN_DEBUG,
}
```

â†’ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ ìƒì—ì„œ ì‚¬ìš©ë˜ëŠ” ì‰ì´ë” ì¤‘, ë¬´ì¡°ê±´ ê°€ì¥ ë§ˆì§€ë§‰ ìˆœì„œì— í˜¸ì¶œ

Render Managerì—ì„œ Copyí•˜ëŠ” í•¨ìˆ˜ ì œì‘

```cpp
CRenderMgr
{
	void PostProcessCopy();
}
```

```cpp
void CRenderMgr::PostProcessCopy()
{
	// RenderTarget -> PostProcessTex
	CONTEXT->CopyResource(m_PostProcessTex->GetTex2D().Get(), pRTTex->GetTex2D().Get());
}
```

- `CopyResource()` í•¨ìˆ˜ì— ëŒ€í•˜ì—¬

```cpp
pShader = new CGraphicShader;

pShader->CreateVertexShader(L"shader\\postprocess.fx", "VS_GrayFilter");
pShader->CreatePixelShader(L"shader\\postprocess.fx", "PS_GrayFilter");

pShader->SetRSType(RS_TYPE::CULL_NONE);
pShader->SetDSType(DS_TYPE::NO_TEST_NO_WRITE);
pShader->SetBSType(BS_TYPE::DEFAULT);

pShader->SetDomain(SHADER_DOMAIN::DOMAIN_POSTPROCESS);

```

GrayFilter Shader ì „ìš© ì¬ì§ˆ ìƒì„±

```cpp
pMtrl = new CMaterial();
pMtrl->SetShader(FindAsset<CGraphicShader>(L"GrayFilterShader"));
pMtrl->SetTexParam(TEX_0, FindAsset<CTexture>

```

Post Process ì „ìš© ì˜¤ë¸Œì íŠ¸ ìƒì„±

```cpp
CGameObject* pGrayFilterObj = new CGameObject;
pGrayFilterObj->AddComponent(new CTransform);
pGrayFilterObj->AddComponent(new CMeshRender);

pGrayFilterObj->MeshRender()->SetMesh(CAssetMgr::GetInst()->FindAsset<CMesh>(L"RectMesh"));
pGrayFilterObj->MeshRender()->SetMaterial(CAssetMgr::GetInst()->FindAsset<CMaterial>(L"GrayFilterMtrl"));

m_CurLevel->
```

- Transform Component ì¶”ê°€ â†’ ë³¸ì¸ì˜ Transformì— ìƒê´€ ì—†ì´ í•´ë‹¹ êµ¬ì—­ì— í•œì •ë˜ì§€ ì•Šê³ , í™”ë©´ ì „ì²´ì— ì ìš©
- MeshRender Component ì¶”ê°€ â†’

Post Process ë Œë”ë§ì€ ê°€ì¥ ë§ˆì§€ë§‰ ë‹¨ê³„ì— ì¼ì–´ë‚˜ë„ë¡..

```cpp
for (size_t i = -; i < m_vecPostProcess.size(); ++i)
{
	CRenderMgr::GetInst()->PostProcessCopy();
	m_vecPostProcess[i]->Render();
}
```

Post Processì˜ HLSL íŒŒì¼ ì‘ì„±

```cpp
#ifndef _POSTPROCESS
#define POSTPROCESS

// =======================
//    GrayFilterShader
// =======================

struct VS_IN
{
	float3 vPos : POSITION;
	float2 vUV : TEXCOORD;
};

struct VS_OUT
{
	float4 vPosition : SV_Position;
	float2 vUV : TEXCOORD;
};

VS_OUT VS_GrayFilter(VS_IN _in)
{
	VS_OUT output = (VS_OUT) 0.f;
	
	output.vPosition = float4(_in.vPos.xy * 2.f, 0.f, 1.f);
	output.vUV = _in.vUV;
	
	return output;
}

float4 PS_GrayFilter(VS_OUT _in) : SV_Target
{
	float4 vColor = g_tex_0.Sample(g_sam_0, _in.vUV);
	float Average = (vColor.x + vColor.y + vColor.z) / 3.f
	vColor = float4(Average, Average, Average, 1.f);
	
	return vColor;
}

#endif
```

â†’ ì‰ì´ë”ì½”ë“œ ë¶„ì„í•´ë³´