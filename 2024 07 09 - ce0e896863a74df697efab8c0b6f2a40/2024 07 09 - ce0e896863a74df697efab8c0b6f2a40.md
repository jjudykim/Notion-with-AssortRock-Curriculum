# 2024/07/09 -

상위 항목: Week33 (https://www.notion.so/Week33-c25c856dcd954fe0af5f24db92f6af83?pvs=21)
상태: 메모
주차: 0100_Week30~39

> 1교시 녹음본 
- [https://clovanote.naver.com/s/i8dxSz8UWY4DxYJXgzvrwYS](https://clovanote.naver.com/s/i8dxSz8UWY4DxYJXgzvrwYS)

2교시 녹음본 
- [https://clovanote.naver.com/s/KvPySK822cEj4tSUAmqoZjS](https://clovanote.naver.com/s/KvPySK822cEj4tSUAmqoZjS)
> 

## Drag & Drop으로 계층 관계 갱신하기

### Drop 노드를 지정하지 않고, 바깥에 놔버리면서 계층 관계를 탈출해보자

자식으로 포함되어 있는 노드가 자신의 부모 노드의 Tree 구조 내에서 바깥으로, 즉 아무것도 없는 곳으로 Drag & Drop 된다면? 

→ 1) 해당 자식 노드의 계층 구조가 모두 해제되고, 2) 해당 노드가 최상위 부모 노드가 되게끔 변경해 트리가 갱신되도록, 경우의 수를 추가해보자

이를 정리해보자면, 어느 부모 노드에 포함되어 있는 노드가 Drag된 후 - Drop Check 시에 *Drop된 노드가 존재하지 않는 경우*이므로 해당 경우에 대한 분기를 설정해주자

기존에는 마우스가 릴리즈 되면서, 드래그된 노드(m_DraggedNode)와 드랍된 노드(m_DroppedNode)를 nullptr로 비워버린다!

→ 여태까지는 둘 다 nullptr이 아닌 경우가 일반적이었다! 어느 한 노드에서 → 한 노드로 Drag & Drop을 하는 경우만을 작성했었기 때문에.

그런데 이때, 드래그된 노드는 존재하는 반면 드랍된 노드가 nullptr이었다면?

→ 이 경우가 바로 Drag & Drop 시 계층 관계를 탈출하도록 내부에서 밖으로 꺼내는 경우

따라서 해당 분기에 대한 처리를 작성해주자

**TreeUI가 Update 될 때, Drag된 노드는 존재하지만 Drop된 노드는 존재하지 않는 경우**

```cpp
void TreeUI::Update()
{
	// ...
	
	if (ImGui::IsMouseReleased(ImGuiMouseButton_Left))
	{
		// 드래그한 노드는 존재하지만, 받는 노드가 없는 경우
		if (m_DragedNode && ! m_DroppedNode)    
		{
			if (m_SelfDragDropInst && m_SelfDragDropFunc)
			{
				(m_SelfDragDropInst->*m_SelfDragDropFunc)((DWORD_PTR)m_DragNode, 0);
			}
		}
		m_DroppedNode = m_DragedNode = nullptr; 
	}
}
```

→ 한 UI 내에 존재하는 노드 간의 상호작용이므로, Self DragDrop으로 처리

그렇다면 Outliner의 경우에서, Self Drag&Drop이 일어날 때 Delegate로 호출되는 GameObjectAddChild 함수를 살펴보자

여기서 전달되는 파라미터는 각각 Drag Node, Drop Node를 의미하는데, 만약 우리가 방금 생성한 경우의 수인 *Drag Node는 존재하지만 Drop Node가 존재하지 않는 경우*가 전달된다면, Delegate인 이 함수에서도 해당 분기에 대한 처리가 이루어져야 할 것이다

**GameObjectAddChild 함수에서 Drag & Drop의 경우의 수에 대한 분기 처리**

```cpp
void Outliner::GameObjectAddChild(DWORD_PTR _Param1, DWORD_PTR _Param2)
{
	TreeNode* pDragNode = (TreeNode*)_Param1;
	TreeNode* pDropNode = (TreeNode*)_Param2;
	
	CGameObject* pDragObject = (CGameObject*)pDragNode->GetData();
	CGameObject* pDropObject = nullptr;
	
	// 1) Drop 노드가 존재하는 경우
	// : Drag 오브젝트를 Drop 오브젝트의 자식으로 편입시킨다
	if(pDropNode)
	{
		pDropObject = (CGameObject*)pDropNode->GetData();
		pDropObject->AddChild(pDragObject);
	}
	
	// 2) Drop 노드가 존재하지 않는 경우
	// : 현재 계층 관계의 탈출 의도로 보고 해당 Drag 오브젝트를 최상위 부모로 만들어준다
	else
	{
		if (!pDragObject->GetParent())
			return;
		
		// 현재 부모 오브젝트와의 연결을 해제하고,
		pDragObject->DeregisterChild();
		
		// 본인 소속 레이어에 최상위 부모로서 재등록을 진행		
		CLevelMgr::GetInst()->GetCurrentLevel()->RegisterAsParent(pDragObject->GetLayerIdx(), pDragObject);
	}
	
	// 트리 내용을 갱신
	RenewLevel();
}
```

- 
- 이때, `RegisterAsParent`라는 함수를 새로 제작해줬다. 이에 주목해보자!
    
    : 현재 Drag Node에 해당하는 오브젝트가 최상위 부모가 되었기 때문에, 해당 Level Manager가 관리하는 Level → Layer에 소속된 Parent Object에 포함되어야 한다 (우리는 Layer마다 소속된 오브젝트를 Parent Object, 모든 Object 이렇게 담고 관리하고 있었다)
    
    우리가 Layer에 Object를 Add하기 위해서는 
    
    1) 오브젝트가 다른 레이어 소속이거나 
    
    2) 오브젝트가 어느 레이어에도 소속하지 않을 때 에 해당되어야 한다
    
    하지만 해당 오브젝트는 이미 본인이 소속하고 있던 Layer가, 등록하려는 Layer와 동일하기 때문에 `AddObject`를 통해선 새롭게 등록할 수 없으므로…
    
    재등록하는 과정의 함수인 `RegisterAsParent`라는 함수를 제작해,  단, 이미 본인이 소속하고 있던 Layer가 있었으므로 재등록하는 과정이 필요하다
    

따라서 `CLevel`, `CLayer` 쪽에서, 원래 이 Level, Layer의 소속이지만 계층구조가 변경되면서 재등록해야 하는 상황일 경우에 호출하기 용이한 함수인 `RegisterAsParent`를 작성해보자

**Layer에 소속된 Object를 재등록하는 함수, RegisterAsParent**

```cpp
class CLevel :
	public CEntity
{
private:
	// ...

public:
	// ...
	void RegisterAsParent(int LayerIdx, CGameObject* _Object);
	// ...
}
```

```cpp
void CLevel::RegisterAsParent(int LayerIdx, CGameObject* _Object)
{
	m_Layer[LayerIdx]->RegisterAsParent(_Object);
}
```

**Level 단위에서 해당 Layer에 호출한 RegisterAsParent**

```cpp
class CLayer :
	public CEntity
{
private:
	// ...

public:
	// ...
	void RegisterAsParent(CGameObject* _Object);
	// ...
}
```

```cpp
void CLayer::RegisterAsParent(CGameObject* _Object)
{
	// assert 되는 조건
	// 1) 현재 Layer와 Object의 Layer Index가 같지 않은 경우
	// 2) Object의 부모가 존재하는 경우 (Object가 최상위 부모가 아닌 경우)
	assert(_Object->GetLayerIdx() == m_LayerIdx && !_Object->GetParent());
	
	m_Parents.push_back(_Object);
}
```

### Tree UI로 계층 관계 설정 시, 부모가 자식 노드의 자식이 될 수 없도록 막아보자

다음과 같은 계층 구조가 구성되어 있는 Tree UI가 있다고 가정해보자

![Untitled](2024%2007%2009%20-%20ce0e896863a74df697efab8c0b6f2a40/Untitled.png)

이때 만약, Drag & Drop을 이용해 Point Lights 노드를 Drag 해서 Point Light Child로 Drop 시키면 어떻게 될까?

즉, 부모가 자신의 자식으로 등록되어 있는 노드에 자식으로 들어가도록 명령한다면?

→ 무한의 굴레가 돌게 되는.. 말이 안되는 상황이기 때문에!! 

해당 상황에 대한 예외를 설정해 처리해주도록 하자

이를 위해서, 가장 먼저 Game Object에서, 어떤 Object가 본인의 부모(또는 조상)인지를 확인할 수 있는 함수 하나를 만들어주자

**인자로 들어온 Object가 본인의 조상인지 확인하는 함수, IsAncestor**

```cpp
class CGameObject :
	public CEntity
{
private:
	// ...
	
public:
	// ...
	bool IsAncestor(CGameObject* _Object);
	
	// ...
};
```

```cpp
bool CGameObject::IsAncestor(CGameObject* _Object)
{
	CGameObject* pObject = m_Parent;
	
	// 내가 부모 오브젝트가 존재한다면?
	while(pObject)
	{
		// 입력으로 들어온 오브젝트가 나의 부모 오브젝트와 동일한지 비교
		if (pObject == _Object)
			return true;
		else
			// 조상을 거슬러 올라가도록 Parent 받아오기..
			pObject = pObject->GetParent(); 
	}
	
	// 조상을 모두 거슬러 올라가도, 일치하지 않는다면 false
	return false; 
}
```

그렇다면 이렇게 제작한 `IsAncestor` 함수를 활용해, Drag & Drop 시에 현재 Drag되는 노드가 Drop되는 노드의 부모는 아닌지 판단해야 한다!

→ 자식으로 들어갈 오브젝트가 부모(조상) 중 하나였다면 무시하도록

```cpp
void Outliner::GameObjectAddChild(DWORD_PTR _Param1, DWORD_PTR _Param2)
{
	TreeNode* pDragNode = (TreeNode*)_Param1;
	TreeNode* pDropNode = (TreeNode*)_Param2;
	
	CGameObject* pDragObject = (CGameObject*)pDragNode->GetData();
	CGameObject* pDropObject = nullptr;
	
	if (pDropNode)
	{
		pDropObject = (CGameObject*) pDropNode->GetData();
		
		// 자식으로 들어갈 오브젝트가 부모(조상) 중 하나였다면 무시
		if (pDropObject->IsAncestor(pDragObject))
			return;
		
		pDropObject->AddChild(pDragObject);
	}
}
```

## Post Process (후처리)

모든 렌더링이 다 끝나고 난 뒤에 처리되는 작업

새로운 오브젝트가 렌더링되는 것이 아니라, 마무리 작업, 리터칭같은?

그럼 렌더링 파이프라인을 통해 이 작업을 어떻게 구현할 수 있을지..?

Render Manager에서 PostProcess 용도의 텍스쳐를 하나 생성

```cpp
CRenderMgr
{
	Ptr<CTexture>    m_PostProcessTex;
}
```

```cpp
void CAssetMgr::CreateEngineTexture()
{
	Vec2 Resolution = CDevice::

	// PostProcess 용도 텍스쳐 생성
	m_PostProcessTex = CAssetMgr::GetInst()->CreateTexture(L"PostProcessTexture"
	, (UINT)Resolution.x, (UINT)Resolution.y
	, DXGI_FORMAT_R8G8B8A8_UNORM, D3D11_BIND_SHADER_RESOURCE);
}
```

```cpp
void CAssetMgr::Init()
{
	// Asset Manager가 초기화될 때 만들어놓은, Post Process용 텍스쳐를 참조
	m_PostProcessTex = CAssetMgr::GetInst()->FindAsset<CTexture>(L"PostProcessTex");	
}
```

- 해상도는 반드시 현재 Render Target Texture와 동일해야 함
- 

<aside>
🗒️ [추가 사항]
Bind Flag 조합에 대한 이야기

</aside>

복사 → 후처리 → 렌더링 하는 일련의 과정에 대해서 정리해보기

```cpp
enum SHADER_DOMAIN
{
	// ...
	DOMAIN_POSTPROCESS,         // "후처리 단계" 추가
	
	DOMAIN_DEBUG,
}
```

→ 렌더링 파이프라인 상에서 사용되는 쉐이더 중, 무조건 가장 마지막 순서에 호출

Render Manager에서 Copy하는 함수 제작

```cpp
CRenderMgr
{
	void PostProcessCopy();
}
```

```cpp
void CRenderMgr::PostProcessCopy()
{
	// RenderTarget -> PostProcessTex
	CONTEXT->CopyResource(m_PostProcessTex->GetTex2D().Get(), pRTTex->GetTex2D().Get());
}
```

- `CopyResource()` 함수에 대하여

```cpp
pShader = new CGraphicShader;

pShader->CreateVertexShader(L"shader\\postprocess.fx", "VS_GrayFilter");
pShader->CreatePixelShader(L"shader\\postprocess.fx", "PS_GrayFilter");

pShader->SetRSType(RS_TYPE::CULL_NONE);
pShader->SetDSType(DS_TYPE::NO_TEST_NO_WRITE);
pShader->SetBSType(BS_TYPE::DEFAULT);

pShader->SetDomain(SHADER_DOMAIN::DOMAIN_POSTPROCESS);

```

GrayFilter Shader 전용 재질 생성

```cpp
pMtrl = new CMaterial();
pMtrl->SetShader(FindAsset<CGraphicShader>(L"GrayFilterShader"));
pMtrl->SetTexParam(TEX_0, FindAsset<CTexture>

```

Post Process 전용 오브젝트 생성

```cpp
CGameObject* pGrayFilterObj = new CGameObject;
pGrayFilterObj->AddComponent(new CTransform);
pGrayFilterObj->AddComponent(new CMeshRender);

pGrayFilterObj->MeshRender()->SetMesh(CAssetMgr::GetInst()->FindAsset<CMesh>(L"RectMesh"));
pGrayFilterObj->MeshRender()->SetMaterial(CAssetMgr::GetInst()->FindAsset<CMaterial>(L"GrayFilterMtrl"));

m_CurLevel->
```

- Transform Component 추가 → 본인의 Transform에 상관 없이 해당 구역에 한정되지 않고, 화면 전체에 적용
- MeshRender Component 추가 →

Post Process 렌더링은 가장 마지막 단계에 일어나도록..

```cpp
for (size_t i = -; i < m_vecPostProcess.size(); ++i)
{
	CRenderMgr::GetInst()->PostProcessCopy();
	m_vecPostProcess[i]->Render();
}
```

Post Process의 HLSL 파일 작성

```cpp
#ifndef _POSTPROCESS
#define POSTPROCESS

// =======================
//    GrayFilterShader
// =======================

struct VS_IN
{
	float3 vPos : POSITION;
	float2 vUV : TEXCOORD;
};

struct VS_OUT
{
	float4 vPosition : SV_Position;
	float2 vUV : TEXCOORD;
};

VS_OUT VS_GrayFilter(VS_IN _in)
{
	VS_OUT output = (VS_OUT) 0.f;
	
	output.vPosition = float4(_in.vPos.xy * 2.f, 0.f, 1.f);
	output.vUV = _in.vUV;
	
	return output;
}

float4 PS_GrayFilter(VS_OUT _in) : SV_Target
{
	float4 vColor = g_tex_0.Sample(g_sam_0, _in.vUV);
	float Average = (vColor.x + vColor.y + vColor.z) / 3.f
	vColor = float4(Average, Average, Average, 1.f);
	
	return vColor;
}

#endif
```

→ 쉐이더코드 분석해보